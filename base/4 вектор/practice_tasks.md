# Практические задания: Вектор C++

## Задание 1: Динамический массив с автоматическим управлением памятью
**Описание:** Создайте класс `DynamicArray<T>` как упрощенную версию std::vector с основными операциями и контролем памяти.

**Требования:**
- Автоматическое управление памятью
- Методы: push_back, pop_back, at, size, capacity, reserve
- Автоматическое увеличение размера при необходимости
- Proper move/copy semantics
- Exception safety

**Тесты:**
1. Создание пустого массива и добавление элементов
2. Автоматическое увеличение capacity при переполнении
3. Правильное освобождение памяти при уничтожении
4. Копирование массива (deep copy)
5. Move constructor и move assignment
6. Исключение при обращении к несуществующему элементу
7. Reserve для предварительного выделения памяти
8. Работа с пользовательскими типами данных
9. Pop_back на пустом массиве (должно быть безопасно)
10. Stress test - добавление большого количества элементов

## Задание 2: Система управления контактами
**Описание:** Реализуйте систему управления контактами используя std::vector для хранения и поиска информации.

**Требования:**
- Структура Contact с полями name, phone, email, group
- Добавление, удаление, поиск контактов
- Группировка контактов по категориям
- Сортировка по различным критериям
- Экспорт/импорт в файл

**Тесты:**
1. Добавление нового контакта в список
2. Поиск контакта по имени
3. Поиск контакта по номеру телефона
4. Удаление контакта по имени
5. Группировка контактов по группам
6. Сортировка контактов по имени (алфавитный порядок)
7. Сортировка по дате добавления
8. Экспорт всех контактов в текстовый файл
9. Импорт контактов из файла
10. Поиск контактов по частичному совпадению

## Задание 3: Алгоритмы обработки данных
**Описание:** Создайте набор алгоритмов для работы с векторами: сортировка, поиск, фильтрация, статистические функции.

**Требования:**
- Реализация различных алгоритмов сортировки
- Бинарный поиск для отсортированных данных
- Фильтрация элементов по предикатам
- Статистические функции (среднее, медиана, мода)
- Работа с любыми сравнимыми типами данных

**Тесты:**
1. Bubble sort для vector<int>
2. Quick sort с оптимизацией для малых массивов
3. Бинарный поиск в отсортированном векторе
4. Фильтрация четных чисел из вектора
5. Вычисление среднего арифметического
6. Поиск медианы для нечетного количества элементов
7. Поиск медианы для четного количества элементов
8. Поиск наиболее часто встречающегося элемента (мода)
9. Удаление дубликатов из вектора
10. Производительность различных алгоритмов сортировки

## Задание 4: Sparse Vector (Разреженный вектор)
**Описание:** Реализуйте разреженный вектор для эффективного хранения векторов с большим количеством нулевых элементов.

**Требования:**
- Хранение только ненулевых элементов
- Методы: set, get, size, clear
- Итераторы для обхода ненулевых элементов
- Арифметические операции между разреженными векторами
- Memory-efficient storage

**Тесты:**
1. Создание разреженного вектора и установка значений
2. Получение значения по индексу (включая нулевые)
3. Установка нулевого значения (должно удалять элемент)
4. Итерирование только по ненулевым элементам
5. Сложение двух разреженных векторов
6. Скалярное произведение разреженных векторов
7. Конвертация в обычный std::vector
8. Создание из обычного вектора с автоматической оптимизацией
9. Memory efficiency - проверка экономии памяти
10. Производительность операций vs обычный vector

## Задание 5: Matrix класс на основе vector
**Описание:** Создайте класс двумерной матрицы используя std::vector<std::vector<T>> с математическими операциями.

**Требования:**
- Конструкторы для различных способов создания матрицы
- Арифметические операции: +, -, *, /
- Методы: transpose, determinant, inverse
- Доступ к элементам через operator()
- Валидация размерностей при операциях

**Тесты:**
1. Создание матрицы заданного размера
2. Инициализация матрицы из vector<vector<T>>
3. Доступ к элементам через operator()(row, col)
4. Сложение двух матриц одинакового размера
5. Умножение матриц (правильные размерности)
6. Транспонирование матрицы
7. Вычисление определителя для квадратной матрицы
8. Исключение при операциях с неподходящими размерами
9. Умножение матрицы на скаляр
10. Обращение матрицы (если возможно)

## Задание 6: Circular Buffer
**Описание:** Реализуйте кольцевой буфер фиксированного размера используя std::vector как базовое хранилище.

**Требования:**
- Фиксированный размер буфера
- Перезапись старых данных при переполнении
- Методы: push, pop, front, back, full, empty
- Итераторы в порядке добавления элементов
- Thread-safe операции (optional)

**Тесты:**
1. Создание буфера заданного размера
2. Добавление элементов до заполнения буфера
3. Перезапись старых элементов при переполнении
4. Чтение элементов в порядке FIFO
5. Проверка состояний full() и empty()
6. Итерирование по элементам в правильном порядке
7. Очистка буфера
8. Работа с пользовательскими типами данных
9. Resize буфера с сохранением данных
10. Concurrent access (если реализована thread-safety)

## Задание 7: Vector-based Database
**Описание:** Создайте простую in-memory базу данных используя vector для хранения записей с возможностью индексирования и запросов.

**Требования:**
- Структура Record с различными полями
- Индексы для быстрого поиска по полям
- SQL-подобные операции: SELECT, INSERT, UPDATE, DELETE
- Сортировка результатов по различным критериям
- Простые JOIN операции между таблицами

**Тесты:**
1. Создание таблицы и вставка записей
2. SELECT запрос с фильтрацией по полю
3. UPDATE записи по условию
4. DELETE записи по условию
5. Создание индекса по полю для ускорения поиска
6. SELECT с сортировкой по полю
7. Агрегатные функции: COUNT, SUM, AVG
8. JOIN двух таблиц по общему полю
9. Составные условия в WHERE (AND, OR)
10. Производительность запросов с индексами vs без индексов

## Задание 8: Priority Queue на основе vector
**Описание:** Реализуйте очередь с приоритетами используя std::vector и алгоритмы для поддержания heap-свойства.

**Требования:**
- Хранение элементов с приоритетами
- Операции: push, pop, top, empty, size
- Поддержание heap-свойства после каждой операции
- Возможность изменения приоритета элемента
- Пользовательские функции сравнения

**Тесты:**
1. Добавление элементов с разными приоритетами
2. Извлечение элемента с максимальным приоритетом
3. Проверка правильности heap-свойства после операций
4. Работа с пользовательскими типами и функциями сравнения
5. Изменение приоритета существующего элемента
6. Очередь с минимальными приоритетами (min-heap)
7. Merge двух priority queues
8. Производительность операций O(log n)
9. Обработка одинаковых приоритетов
10. Stress test с большим количеством операций

## Задание 9: Vector Iterator Wrapper
**Описание:** Создайте обертки для итераторов vector с дополнительной функциональностью: фильтрация, трансформация, ленивые вычисления.

**Требования:**
- FilterIterator для пропуска элементов не удовлетворяющих условию
- TransformIterator для преобразования элементов на лету
- ReverseIterator для обхода в обратном порядке
- EnumerateIterator для получения пар (index, value)
- ChainIterator для объединения нескольких контейнеров

**Тесты:**
1. FilterIterator - итерация только по четным числам
2. TransformIterator - получение квадратов чисел без изменения исходного вектора
3. ReverseIterator - обход вектора в обратном порядке
4. EnumerateIterator - получение пар (индекс, значение)
5. ChainIterator - последовательный обход нескольких векторов
6. Комбинирование итераторов: Filter + Transform
7. Ленивые вычисления - трансформация происходит только при разыменовании
8. Совместимость с STL алгоритмами
9. Производительность vs стандартные алгоритмы
10. Работа с const и non-const контейнерами

## Задание 10: Memory Pool для vector
**Описание:** Реализуйте пул памяти для оптимизации многократных выделений памяти при работе с множественными vector'ами.

**Требования:**
- MemoryPool класс для управления блоками памяти
- Кастомный аллокатор для std::vector
- Статистика использования памяти
- Возможность настройки размера блоков
- Профилирование и сравнение с стандартным аллокатором

**Тесты:**
1. Создание memory pool с заданным размером блоков
2. Аллокация памяти из пула для vector
3. Деаллокация и повторное использование памяти
4. Статистика: количество выделений, фрагментация
5. Автоматическое расширение пула при нехватке памяти
6. Работа с несколькими векторами одновременно
7. Сравнение производительности с std::allocator
8. Измерение memory overhead от использования пула
9. Thread-safety для concurrent allocations
10. Оптимизация для specific use cases (много мелких аллокаций)

---

## Критерии оценки

**Отлично (5):**
- Все тесты проходят
- Эффективное управление памятью
- Правильная работа с итераторами
- Exception safety
- Оптимальная производительность

**Хорошо (4):**
- 8-9 тестов проходят
- Корректная реализация основной функциональности
- Минимальные проблемы с памятью
- Базовая обработка ошибок

**Удовлетворительно (3):**
- 6-7 тестов проходят
- Основная функциональность работает
- Возможны memory leaks
- Неоптимальная производительность

**Неудовлетворительно (2):**
- Менее 6 тестов проходят
- Серьезные проблемы с памятью
- Неправильная работа с итераторами
- Crashи программы

## Полезные советы

### Управление памятью:
```cpp
// RAII для автоматического освобождения
class VectorWrapper {
    T* data_;
    size_t size_, capacity_;
public:
    ~VectorWrapper() { delete[] data_; }
};
```

### Эффективная работа с capacity:
```cpp
// Удваивание размера для амортизированной сложности O(1)
if (size_ == capacity_) {
    size_t new_capacity = capacity_ * 2;
    reserve(new_capacity);
}
```

### Exception safety:
```cpp
// Strong exception guarantee
void push_back(const T& value) {
    if (size_ == capacity_) {
        // Может бросить исключение
        vector<T> temp = *this;
        temp.reserve(capacity_ * 2);
        temp.emplace_back(value);
        // Если дошли сюда - все OK, можем делать swap
        swap(temp);
    } else {
        data_[size_++] = value;
    }
}
```

### Оптимизация итераторов:
```cpp
// Префиксный инкремент эффективнее постфиксного
for (auto it = vec.begin(); it != vec.end(); ++it) {
    // обработка
}
``` 