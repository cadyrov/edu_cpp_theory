Концепция Model–View–Controller
Если делать, то сразу хорошо!
Прежде чем возвести здание, специалисты разрабатывают план постройки. Также и в программировании: перед разработкой проекта необходимо подумать над его архитектурой.
В этом уроке вы начнете знакомство с популярными архитектурными решениями. Они позволяют упростить проработку собственных проектов, так как дают использовать опыт других программистов.
Знакомство с моделями и представлениями
В области архитектуры программного обеспечения есть такое понятие, как паттерн программирования. Можно встретить другое название — шаблон проектирования. Паттерн — это схема классов и их взаимодействия, помогающая решить определенную задачу разработки.
Среди часто используемых паттернов можно выделить такие: фабрика, одиночка (англ. singleton), стратегия, декоратор. У каждого из них своя область использования. 
В этом уроке вы познакомитесь с одним из часто применяемых паттернов — Model–View–Controller, или MVC, — «Модель-Представление-Контроллер».
В этом паттерне задачи, решаемые проектом, делятся на три части:
Модель. Определяет поведение программы. Модель хранит все основные данные и предоставляет программные возможности для их корректного изменения. Например, если вы проектируете видеоигру, то модель должна содержать позиции всех персонажей, их показатели здоровья, а также все игровые предметы, локации и прочие объекты.
Представление. Отображает данные для пользователя. Под Представлением чаще всего понимается интерфейс.
Контроллер. Это посредник между Представлением и Моделью. Контроллер обрабатывает действия пользователя и меняет Модель в соответствии с тем, что требуется человеку.
Существует два видения модели MVC. В первом из них Контроллер предназначен для реакции на действия пользователя. Он отделён от Представления:

Мы будем рассматривать другой вариант. В нём контроллер является посредником между Моделью и Представлением:

В Qt используется вторая схема. Как правило, Контроллер очень тесно интегрирован с Представлением. В этом случае говорят о паттерне Model–View вместо Model–View–Controller.
Вы можете лучше понять, как устроен MVC, на примере финального задания предыдущей темы — шаблонного калькулятора. В нём вы чётко отделили Контроллер от Представления (класса MainWindow), сделав его отдельным классом.

Взаимодействие классов в проекте «Калькулятор»
При этом код MainWindow не содержит никакой логики и только принимает команды контроллера, то есть его реализация достаточно проста. Код окна и модели оказался полностью изолированным. Что позволяет подключать к интерфейсу различные модели, и калькулятор работает с разными типами чисел.
При использовании этого паттерна код проекта разбит на части, у каждой из частей своя роль: модели, представления или контроллера.
Разделение выполняемых задач по разным классам позволяет сделать проект более гибким. Вносить правки и разбираться в проекте будет легче, чем если всю функциональность кода разместить в одном классе. Выделим преимущества, которые дает использование MVC:
Разделение обязанностей. При таком подходе код проекта разбит на логические части. Разные компоненты можно менять независимо. Их легче поддерживать и развивать.
Возможность замены компонентов. Одна и та же модель может работать с разными представлениями. Благодаря этому можно менять внешний вид приложения или поддерживать разные фреймворки. При этом наиболее сложная часть программы, содержащая логику её работы, остаётся неизменной.
Возможность разработки в команде. Поскольку компоненты проекта самостоятельны, их могут развивать несколько разработчиков независимо друг от друга.
Вспоминая вектор
Данные в виде списка чаще всего хранят в std::vector. Вы уже сталкивались с этим контейнером в предыдущих спринтах — размещали в нём как простые данные, так и структуры. В ближайшие несколько уроков вам предстоит расширить свои знания об этом контейнере. Но для начала давайте вспомним, как с ним работать.
Знание базы — залог успеха
Чтобы использовать вектор, необходимо подключить библиотеку: #include <vector>. После этого объявить переменную можно так:
// Подключаем библиотеку:
#include <vector>


// Создаём пустой вектор чисел:
std::vector<int> numbers{};
Тип элементов вектора располагают в угловых скобках. Например, std::vector<int>, std::vector<string>, std::vector<char> создадут вектор чисел, строк и символов. Так создаётся вектор с нулевым количеством элементов — пустой вектор.
Вспомним, как ещё можно проинициализировать этот контейнер.
Указать в круглых скобках количество элементов:
// Создает вектор из десяти элементов со значением по умолчанию.
// Для целочисленного типа это 0.
std::vector<int> numbers(10);
std::cout << numbers.size() << std::endl;
// Вывод : 10.


for(int value : numbers) {
    std::cout << value << " ";
}


std::cout << std::endl;
// Вывод : 0 0 0 0 0 0 0 0 0 0.


Если хотим заполнить определенным значением, то нужно добавить второй параметр в круглые скобки:
// Создаёт вектор из десяти элементов со значением 
// "Тик-так" во всех элементах.
std::vector<std::string> numbers(10, "Тик-так");
Можно инициализировать списком значений. Элементы списка идут через запятую и все заключены в фигурные скобки. В таком случае используется временный вектор:
std::vector<int> numbers = {1, 2, 3, 4, 5, 4, 3, 2, 1};


// Или
std::vector<int> another_numbers({10, 11, 12});
Если компилятор может вывести тип элементов, то указывать его не обязательно:
// Компилятор сам поймёт, что vector<int>.
std::vector numbers = {1, 2, 3, 4, 5, 4, 3, 2, 1};


// Надо быть осторожным, это будет vector<const char*>:
std::vector sharikov = {"Аб", "Абыр", "Абырвалг"}; // Не string!
Эта возможность доступна, начиная со стандарта C++17.
Ещё один способ — инициализировать один вектор другим:
std::vector<int> numbers = {1, 2, 3, 4, 5, 4, 3, 2, 1};
std::vector another_numbers = numbers;
Инициализируем вектор, вы используете его конструктор, как в предыдущих спринтах вы использовали конструкторы при работе с классами. Есть и более сложный вариант создания вектора — на основе указанного диапазона. Но об этом после знакомства с итераторами в следующем уроке.
Основные методы работы с вектором
Как вы уже знаете, можно добавить новый элемент в конец вектора методом push_back. По аналогии с очередью в магазине: каждый новый покупатель встает в конец очереди.
// Создаёт пустой вектор.
std::vector<std::string> queue{};


// И добавим 4 элемента:
queue.push_back("Первый покупатель");
queue.push_back("Второй покупатель");
queue.push_back("Третий покупатель");
queue.push_back("Четвёртый покупатель");
Если нужно удалить последний элемент, то используйте pop_back(). Четвёртый покупатель устал ждать и ушёл:
queue.pop_back();
Важно: нельзя вызывать этот метод на пустом векторе. Чтобы проверить, есть ли в векторе элементы, используйте empty(). В случае пустого контейнера возвращается true:
if(!queue.empty()) {
    std::cout << "Вектор не пустой. Можно вызвать pop_back()." << std::endl;
}
Метод empty() даёт информацию только о том, есть ли записи в векторе или нет, но, чтобы узнать количество элементов, необходимо использовать метод size(). Его же можно использовать, чтобы проверить, пустой вектор или нет. Достаточно сравнить результат работы метода size() с нулём. Если элементов ноль, значит, вектор пуст.
Очистить вектор можно так:
queue.clear();
На первый-последний рассчитайсь!
Для доступа к элементам вектора используют квадратные скобки или метод at(). В чём разница их применения? Предположим, у вас есть вектор, который хранит всего пять элементов, а вы пытаетесь получить значение десятого элемента. Использование квадратных скобок приведет к неопределенному поведению, так как этого элемента не существует. Метод at, который делает то же самое, в случае неправильного доступа генерирует исключение — ошибку, которую можно обработать. Как ловить исключения, которые выдает программа при выполнении, вы узнаете в следующем спринте.
У вектора есть два метода, которые позволяют получить первый и последний элементы, — это front() и back(). Рассмотрим следующий код:
// Создание вектора.
std::vector<std::string> fruits{"яблоко", "ананас", "груша", "апельсин"};


// Вывод элемента с индексом 1:
std::cout << "fruits[1]: "  << fruits[1] << std::endl;


// Вывод первого фрукта из списка:
std::cout << "Первый фрукт: " << fruits.front() << std::endl;


// Последний из списка:
std::cout << "Последний фрукт " << fruits.back() << std::endl;
Власть над итераторами
В этом уроке вам предстоит познакомиться с итератором — специальным объектом, указывающим на элемент контейнера. Вы разберетесь в операциях, которые можно выполнять с итераторами, и потренируетесь применять их на практике.
Операции с итераторами
Итераторы используются при работе с контейнерами, в том числе и с векторами. Самый простой способ получить итератор — вызвать метод begin(). Для примера возьмем вектор с именами:
std::vector<std::string> client_names = {"Bill", "Jeff", "Mark"};
// Записываем итератор в переменную iter:
/*какой-то возвращаемый тип*/ iter = client_names.begin();
Итератор, указывающий на элемент этого контейнера, имеет достаточно сложный тип  — std::vector<std::string>::iterator, включающий в себя и тип контейнера std::vector, и тип данных вектора std::string. В этом случае чаще используют auto, что делает код компактнее:
// Запишем явно возвращаемый тип:
std::vector<std::string>::iterator some_iter = client_names.begin();
// А так проще:
auto auto_iter = client_names.begin();
Итератор, возвращаемый begin(), указывает на первый элемент вектора. В этом случае — строку «Bill». Что ещё можно сделать, используя итератор в качестве переменной?
Прочитать элемент по итератору
Чтобы прочитать, что содержится в элементе, на который указывает итератор, используется унарная операция *:
// Записать прочитанный элемент в переменную.
std::string first_client_name = *some_iter; 
// Переменной first_client_name будет присвоено значение "Bill".


// Вывести в cout.
std::cout << *some_iter  << std::endl; 
// Вывод: Bill.


// Передать в функцию.
PayRoyalty(*some_iter);
Ещё эта операция называется разыменованием.
Изменить элемент по итератору
Ещё операция * подойдёт, если нужно изменить значение элемента вектора:
*some_iter = "Elon";


// Изменили первый элемент. Теперь в векторе "Elon", "Jeff", "Mark".
Прочитать поле или вызвать метод класса по итератору
Если вектор хранит не простые значения, а объекты класса или структуры, то можно обратиться к методу таким образом:
std::vector<Student> students = ...;
std::vector<Point> points = ...;


auto student_iter = students.begin();
auto points_iter = points.begin();


// Если в классе Student есть метод GetAvgScore():
std::cout << (*student_iter).GetAvgScore() << std::endl;
// Вывести поле "x" из структуры Point:
std::cout << (*points_iter).x << std::endl;
Но такая запись с разыменованием и круглыми скобками неудобна и усложняет чтение кода. Вместо этого обращение к методу класса или полю структуры через точку заменяется на стрелку:
std::cout << student_iter->GetAvgScore() << std::endl;
std::cout << points_iter->x << std::endl;
Удалить элемент по итератору
Также итератор позволяет удалить элемент вектора, если его передать в метод erase():
client_names.erase(some_iter);
Влево, вправо и за рамки
Итераторы были бы не очень полезны, если бы их нельзя было двигать. Основные операции перемещения итераторов — ++ и --:
std::vector<std::string> client_names = {"Bill", "Jeff", "Mark"};


auto some_iter = client_names.begin();


std::cout << *some_iter << std::endl; 
// Вывод: Bill.


// Подвинем итератор на шаг вправо.
some_iter++; 
std::cout << *some_iter << std::endl; 
// Вывод: Jeff.


// Также на шаг вправо, но левая операция.
// Разница между my_iter++ и ++my_iter
// такая же, как для чисел.
++some_iter; 
std::cout << *some_iter << std::endl; 
// Вывод: Mark.


// Вернём итератор на шаг назад.
some_iter--; 
std::cout << *some_iter << std::endl; 
// Вывод: Jeff.
Итератор вектора называют двунаправленным (bidirectional), потому что он поддерживает перемещения вправо и влево (++ и --). Некоторые контейнеры и диапазоны имеют однонаправленные итераторы, допускающие только движение вперёд.
Итераторы вектора являются итераторами произвольного доступа. Они поддерживают эффективное перемещение на любое расстояние.
При перемещении нельзя, чтобы итератор выходил за пределы контейнера. Например, у итератора begin() не стоит вызывать --. Это приводит к неопределенному поведению. Но есть одно исключение: находясь на последнем элементе контейнера, итератор может пойти на один шаг вправо. При этом получится корректный итератор, хотя его и нельзя разыменовывать:
std::vector<std::string> client_names = {"Bill", "Jeff", "Mark"};


auto iter = client_names.begin();


iter++;
iter++;
std::cout << *iter << std::endl; 
// Вывод: Mark.


iter++; // Итератор вышел на один элемент вправо, но это допустимо.
iter--; // Вернули итератор назад.


std::cout << *iter << std::endl; 
// Вывод:  Mark.
В этом примере мы подвинули iter на три шага вправо, и он оказался за пределами контейнера. Считается, что такой итератор указывает на фиктивный элемент (так называют элемент, которого в реальности не существует). Такой итератор нельзя разыменовывать, то есть применять к нему операцию * или ->.
Итератор, указывающий на фиктивный элемент, — важный атрибут многих алгоритмов. Чтобы его получить, даже не надо много раз вызывать операцию ++. Есть специальный метод — end(), антагонист begin(). В отличие от begin(), метод end() возвращает итератор, не указывающий на корректный элемент контейнера. Этот итератор нельзя двигать вправо, но можно подвинуть влево.

Наличие фиктивного элемента позволяет вызывать begin() даже у пустого контейнера. Действительно, begin() выдаёт итератор, указывающий на первый элемент. Но что делать, если элементов нет? Указывать на фиктивный элемент. В этом случае begin() равен end().
Использовать end() можно, например, в цикле для проверки достижения последнего элемента благодаря операции сравнения итераторов !=:
std::vector<std::string> names = {"Bill", "Jeff", "Mark"};


// Начальное значение iter — names.begin().
// Выполняем, пока iter != names.end().
// Шаг ++iter — переход к следующему элементу.
for (auto iter = names.begin(); iter != names.end(); ++iter) {
    std::cout << *iter << std::endl;
}
Помимо шагов на соседние элементы, итераторы поддерживают прыжки на заданное количество шагов. Для этого к итератору применяется прибавление и вычитание чисел:
std::vector<std::string> numbers = {"one", "two", "three", "four","five", "six", "seven"};
auto iter = numbers.begin(); // iter => one.


iter += 3; 
// iter => four. Сдвинули на 3 вправо.
auto iter2 = iter - 2; 
// iter2 => two. Сдвинули на 2 влево и записали в новую переменную.


iter -= -3; 
// iter => seven. Сдвиг на -3 влево = сдвиг на 3 вправо.
iter2 += -1; 
// iter2 => one. Сдвиг на -1 вправо = сдвиг на 1 влево.
Или можно использовать алгоритмы std:advance, std::next и std::prev для перемещения итератора:
// Сместим указатель на два вправо.
// Для вектора это то же, что и iter += 2, но
// алгоритм advance работает с любыми итераторами.
std::advance(iter, 2);


auto iter2 = std::next(iter); // iter2 = iter + 1;
auto iter3 = std::prev(iter); // iter3 = iter - 1;
Помимо перемещения итератора, операция сложения также используется, чтобы получить элемент вектора по номеру. Достаточно прибавить нужный номер к begin(). Сложение итератора и числа можно использовать, если вам требуется получить итератор на элемент по его порядковому номеру.
std::vector<std::string> numbers = {"one", "two", "three", "four", "five", "six", "seven"};
auto iter1 = numbers.begin() + 0; 
// Итератор на нулевой элемент — one.
auto iter5 = numbers.begin() + 4; 
// Итератор на четвёртый элемент — five.


int number;
std::cin >> number;
if (number >= 0 && number < numbers.size()) {
    auto some_iter = numbers.begin() + number;
}
Также получить элемент вектора по номеру можно с помощью квадратных скобок (например, таким образом: some_vector[15]).
Измеряя расстояние
Если взять два итератора и вычесть один из другого, то можно узнать, сколько между ними находится элементов. Заметьте, что мы вычитаем итераторы, а получаем число типа int:
auto iter = numbers.begin() + 1;
auto iter2 = numbers.begin() + 3;
int distance_p = iter2 - iter;
// Результат: 2.
Может получиться и отрицательный результат — если вычитать из итератора, который находится ближе к началу контейнера:
int distance_n = iter - iter2;
// Результат: -2.
Тот же результат можно получить алгоритмом distance:
std::vector<std::string> numbers = {"one", "two", "three", "four", 
                                    "five", "six", "seven"};
~~~~
int dist1 = std::distance(numbers.begin(), numbers.end()); // 7.
int dist2 = std::distance(numbers.end(), numbers.begin()); // -7.
Таким образом, если из итератора end() вычесть итератор begin(), то получится количество элементов в векторе.
Итераторы 2.0
Вы уже начали знакомство с итераторами и попрактиковались в использовании их основных операций. В этом уроке вы разберетесь в разных типах этих объектов. Узнаете, при каких условиях итераторы перестают работать корректно, и поймете, что при этом делать.
Такие разные итераторы
Вы могли задаться вопросом, зачем нужны итераторы. Ведь их можно заменить числовым индексом. Это верно в случае с вектором, но не подойдёт для других контейнеров, в которых нельзя быстро получить элемент по индексу. С такими контейнерами вы познакомитесь в следующей теме.
Несмотря на то что значение элемента вектора можно получить по числовому индексу, без итераторов не обойтись, когда нужно удалить элемент или вставить новый в центр контейнера. Также итераторы необходимы при использовании стандартных алгоритмов, таких как std::sort или std::find_if, но об этом чуть позже.
Вернёмся к вектору. Итераторы для этого контейнера бывают нескольких видов. С первым из них вы уже знакомы — это обычные итераторы типа std::vector<T>::iterator. Второй вид — константные итераторы, которые имеют тип std::vector<T>::const_iterator. Такие итераторы не позволяют менять элементы контейнера:
// Обычный итератор превращается в константный:
std::vector<T>::const_iterator iter = client_names.begin();
// Нельзя менять значение, на которое указывает const_iterator.
*iter = "Elon"; // Ошибка!
// Буква "c" в cbegin и cend позволяет получить константный итератор.
auto iter2 = client_names.cbegin();
auto iter3 = client_names.cend();
Если у вас есть константный вектор, вы не можете менять его элементы. Значит, и итераторы можно получить только константные:
void ProcessClients(const std::vector<Client>& clients) {
    // iter будет иметь тип vector<Client>::const_iterator.
    auto iter = clients.begin();
    
    // ...
}
Другой вид итераторов — реверсивные итераторы. Они позволяют проходить контейнер в обратном порядке. Их возвращают методы rbegin, rend. При этом rbegin указывает на последний элемент контейнера, rend — на фиктивный перед первым элементом контейнера. ++ будет двигать итератор в направлении от последнего элемента к первому:
std::vector<std::string> names = {"Bill", "Jeff", "Mark"};


// Тут вместо begin и end — rbegin и rend. В остальном мы
// ничего не изменили.
for (auto iter = names.rbegin(); iter != names.rend(); ++iter) {
    std::cout << *iter << std::endl; 
    // Вывод:
    //   Mark
    //   Jeff
    //   Bill
}
Если рассматривать пару итераторов как диапазон, то v.begin(), v.end() — это диапазон из всех элементов вектора v, а v.rbegin(), v.rend() — тот же диапазон, но в обратном порядке.
Полезные возможности
Вы уже знаете, что по элементам вектора можно пройти, используя упрощенный цикл range-based for (цикл for по диапазону):
std::vector<std::string> names = {"Bill", "Jeff", "Mark"};
for (const auto& value : names) {
    std::cout << value << std::endl; 
    // Вывод:
    //   Mark
    //   Jeff
    //   Bill
}
Это возможно благодаря итераторам и наличию у вектора методов begin() и end(). Ranges-based for — синтаксический сахар для варианта цикла с итератором.
Несмотря на то что этот цикл оперирует довольно сложными объектами — итераторами, его эффективность такая же, как и у обычного цикла for, использующего индексы.
// Версия с итератором так же эффективна, как и такой цикл:
for (size_t i = 0; i != names.size(); ++i) {
    std::cout << names[i] << std::endl;
}
Другие возможности
Вставка и удаление
Итераторы можно использовать для вставки и удаления элементов в любом месте вектора, а не только в конце. Для этого есть методы insert и erase.
Метод insert вставляет новый элемент в то место, на которое указывает итератор. Но на указанном месте уже есть какой-то элемент. Если бы вы разрабатывали такой метод, то в какое место он бы вставлял элемент? Перед существующим или после него? 
Ответить на этот вопрос поможет информация, которую вы уже знаете про фиктивный элемент.
Вставка перед нужным элементом позволяет вставить элемент в любое место, в том числе в конец вектора. Для этого нужно взять итератор, указывающий на фиктивный элемент.
std::vector<std::string> names = {"Bill", "Jeff", "Mark"};


auto iter = ++names.begin(); // Jeff.


// Вставили Илона перед Джеффом.
names.insert(iter, "Elon"); // Bill, Elon, Jeff, Mark.
Можно использовать возвращаемое значение. Это будет итератор, указывающий на новый элемент вектора:
auto iter2 = names.insert(iter, "Elon");
assert(*iter2 == "Elon");


++iter2; // Jeff.


// Удалим Джеффа из вектора:
auto iter3 = names.erase(iter2); // Bill, Elon, Mark


// erase возвращает итератор на элемент, следующий за удалённым.
assert(*iter3 == "Mark");
Будьте осторожны: такие операции могут быть очень неэффективными. Если нужно удалить несколько элементов, гораздо лучше использовать std::remove_if, чем удалять их по одному.
Инвалидация
С итераторами нужно быть осторожными, так как у них есть неприятная особенность — инвалидация. Это ситуация, при которой итератор перестаёт быть корректным и любая операция с ним приводит к UB (undefined behavior) — неопределённому поведению. Случается такое при любом изменении размера вектора, например при добавлении, удалении элементов, вызове метода resize().
Методы, которые инвалидируют итераторы:
insert,
erase,
push_back,
pop_back,
clear,
reserve (запомните этот метод — его рассмотрим позже),
resize.
Не инвалидируют:
все константные методы (size(), empty());
методы получения итераторов (begin(), end(), cbegin(), cend(), rbegin(), rend(), crbegin(), crend());
чтение и изменение элементов через итератор, [], метод at.
Если произошла операция, инвалидирующая вектор, то все итераторы этого вектора, полученные до этой операции, становятся некорректными. Необходимо заново проинициализировать итератор.
Инвалидация обусловлена способом хранения элементов в векторе. Вектор использует некоторую область памяти. Если добавляется новый элемент, а область памяти недостаточна, то вектор переносит элементы в новую область. При этом итераторы продолжают указывать на старую.
Чаще всего итераторы на вектор нужны в моменте: получить итератор, выполнить алгоритм. Сохранять их в долгоживущие переменные можно, но важно помнить: после любой операции, меняющей размер контейнера, итераторы станут невалидными.
Ограничения распространяются и на циклы. Например, такой цикл, дублирующий элементы, будет работать некорректно:
std::vector<int> some_vec = {10, 20, 30};


for (auto iter = some_vec.cbegin(); iter != some_vec.cend(); ++iter) {
    some_vec.insert(iter, *iter);
    iter++; // Ошибка! Итератор инвалидирован.
}
Исправим этот код и после выполнения вставки нового элемента заново запишем новое значение в итератор:
for (auto iter = some_vec.cbegin(); iter != some_vec.cend(); ++iter) {
    iter = some_vec.insert(iter, *iter);
    iter++;
}


// В массиве будут числа 10, 10, 20, 20, 30, 30.
Теперь проблема решена, так как в iter записали новое значение.
Похожая проблема будет и в range-based for:
for (auto i: some_vec) {
    if (i > 15) {
        some_vec.push_back(i); // Ошибка!
    }
    // Вектор, по которому проходит алгоритм, изменил размер.
    // Итератор инвалидирован.
}


std::vector<int> other_vec;
for (auto i: some_vec) {
    if (i > 15) {
        other_vec.push_back(i); // Ok.
    }
    // Можно вставлять в другой вектор.
    // Это не влияет на итераторы vec.
}
Управление пространством
Теперь, когда вы изучили основные методы работы с вектором и разобрались в работе итераторов, поговорим об эффективности использования этого контейнера. В этом уроке вы узнаете, в каких случаях стоит использовать вектор в реализации, а в каких лучше воспользоваться другими контейнерами.
Храним с умом
Вы уже знаете, что любой объект имеет размер, который выражается в байтах. Узнать размер объекта можно с помощью операции sizeof. Её применяют и к объекту, и к типу: результат будет одинаковый для переменных одного типа. Более того, этот результат известен на этапе компиляции:
double number = 3.14;
std::cout << "number size: " << sizeof(number) << std::endl   // 8.
          << "double size: " << sizeof(double) << std::endl;  // И тут 8.


std::vector<double> dbl_vec;


// Тут тоже получим одинаковые числа. Конкретное значение зависит от
// реализации стандартной библиотеки и компилятора.
std::cout << "dbl_vec size: " << sizeof(dbl_vec) << std::endl
          << "vector size: " << sizeof(std::vector<double>) << std::endl;
          
if constexpr (sizeof(double) < sizeof(std::vector<double>)) {
    std::cout << "Объект вектора занимает больше памяти, чем double" 
              << std::endl;
}
Убедимся, что размер объекта не меняется при добавлении элементов:
std::vector<double> dbl_vec;


// Выведет некоторое число, зависящее от платформы (например, 24):
std::cout << sizeof(dbl_vec) << std::endl;


dbl_vec.push_back(0);


// То же самое число.
std::cout << sizeof(dbl_vec) << std::endl;


for (int i = 1; i < 10000; ++i) {
    dbl_vec.push_back(i);
}


// Размер всё тот же.
std::cout << sizeof(dbl_vec) << std::endl;
Но если размер объекта не меняется, то где вектор хранит добавленные элементы? Ответ прост: в дополнительной памяти, которая выделяется в специальном пространстве — куче.
Эффективные и неэффективные операции
Можно представить объявленный вектор как пункт управления складом. Пункт управления занимает одно и то же здание, независимо от объема хранения. Он направляет грузы в удаленное хранилище.
В нашем складе — хранилище вектора — все объекты располагаются подряд, в одну линию. Это обусловлено требованиями эффективности: вы точно знаете, где искать нужный объект, если известен его номер. Поэтому плюс работы с вектором — быстрое чтение. Используйте вектор, если ваша задача требует частого считывания ячеек из последовательности. Например, если вашей программе необходимо получать данные о температуре в конкретный день.
Добавлять новый элемент в контейнер просто, если на складе есть свободное место. Он кладётся на следующую свободную ячейку. Также просто извлечь последний размещенный элемент.
Методы вставки и удаления первого элемента отсутствуют, потому что эти операции неэффективны. Тем не менее вы можете выполнить их, используя итератор. Чтобы вставить элемент в начало или середину вектора, нужно освободить место под новый. Для этого все последующие элементы нужно переместить на одну позицию вправо. Похожим образом происходит удаление.
Минус работы с вектором: вставка элемента в середину или его удаление — долгие операции, а это значит, что ваша программа будет работать не так эффективно и быстро.
Между хранилищем вектора и отдельным помещением в реальном складе есть различие. Когда реальный склад переполняется, можно арендовать помещение побольше, чтобы разместить в нём новые предметы. В этом случае нарушается важный принцип эффективного доступа: объекты будут лежать в разных местах, найти нужный будет сложнее.
Под вектор выделяется новое пространство, когда хранилище переполнено. Все объекты переносятся в это пространство. Тогда старая память (предыдущая комната) освобождается. Если продолжить метафору со складом, то это будет выглядеть так: мы размещаемся в комнате на складе побольше и переносим туда все объекты, а от прошлого помещения отказываемся.
Вставка элементов в конец вектора тоже может быть долгой, если закончилось место. Но это происходит достаточно редко.
Вместимостью склада можно управлять. Но для начала необходимо узнать, сколько есть места. Для этого у вектора есть метод capacity():
void PrintVectorInfo(const std::vector<int>& v) {
    std::cout << "size     – " << v.size() << std::endl;
    std::cout << "capacity – " << v.capacity() << std::endl;
    
    // Адрес элементов:
    std::cout << "data     – " << v.data() << std::endl;
}


int main() {
    std::vector<int> nums{1, 2, 3};
    nums.push_back(4);
    PrintVectorInfo(nums);
}


// Вывод:
// size – 4.
// capacity – 6.
// data – 0x19cff90.
// Адрес будет меняться от запуска к запуску.
Вместимость вектора — 6 элементов, но сейчас в нём 4.
Добавим еще два элемента:
// main
nums.push_back(5);
nums.push_back(6);
PrintVectorInfo(nums);
// Вывод:
// size – 6.
// capacity – 6.
// data – 0x19cff90.
Адрес не поменялся, но сейчас хранилище вектора заполнено полностью.
Добавим еще элемент:
// main
nums.push_back(7);
PrintVectorInfo(nums);
// Вывод:
// size – 7.
// capacity – 12.
// data – 0xb1bfc0.
Как видите, адрес изменился. Значит, вектор переместил элементы в новую память. Размер изменился на один, а вот вместимость увеличилась в два раза. Вектор выделяет место с запасом. Вот как выглядят расположенные элементы в памяти:

Синие квадратики — занятые ячейки, зелёные квадратики — зарезервированные, а чёрные — чужая память.
Процесс «переезда» вектора в новую память называется реаллокацией. При этом процессе и происходит инвалидация итераторов, о которой мы говорили в прошлом уроке.
Вернемся к методу resize(). Он позволяет изменять размер вектора в меньшую и бóльшую сторону. При уменьшении размера инвалидируются итераторы, начиная с отсечённого элемента. При увеличении важную роль играет вместимость: если её достаточно, то размер изменится без реаллокации, а если нет — произойдёт реаллокация и инвалидация всех итераторов. Причём новая вместимость вектора не обязательно будет совпадать с новым размером.
Представим, что вы имеете дело с реальным складом, а итератор — это координаты места, где расположен нужный объект. Если произошла реаллокация и склад переехал по новому адресу в более просторное помещение, то итератор стал недействительным. Приехав по этим координатам, вы обнаружите заброшенное здание.
Выделение новой памяти и частые «переезды» неэффективны. Если вы заранее знаете, сколько элементов будет в векторе, используйте reserve. Этот метод изменит вместимость так, чтобы она была не меньше нужного размера:
std::vector<int> nums{1, 2, 3};
nums.reserve(7); // Резервируем свободное место.
PrintVectorInfo(nums);
// size – 3.
// capacity – 7.
// data – 0xb1bfe0.
nums.push_back(4);
nums.push_back(5);
nums.push_back(6);
nums.push_back(7);
PrintVectorInfo(nums);
// size – 7.
// capacity – 7.
// data – 0xb1bfe0.
Вызов reserve позволил избежать реаллокаций и эффективно вставить элементы. Его часто используют, если нужно, например, построить вектор на основе другого вектора:
std::vector<std::string> GetStudentNames(const std::vector<Student>& students) {
    std::vector<std::string> result;
    // Знаем, что в векторе result будет столько же элементов,
    // сколько и в students. Зарезервируем под них место.
    result.reserve(students.size());
    
    // Теперь вставим без реаллокаций.
    for (const auto& s : students) {
        result.push_back(s.name);
    }
    
    return result;
}
Вектор — это подходящий вариант, если достаточно вставки элементов в конец контейнера и не требуется удаление произвольных элементов. К примеру, вам необходимо измерять активность солнца в определённое время, и программа постепенно сохраняет полученные параметры во время выполнения исследования.
Если условия задачи иные (например, требуется постоянно вставлять и удалять элементы в любом месте), то вектор подойдёт плохо. В этом случае будет эффективнее использовать другие контейнеры, с которыми вы подробно познакомитесь в этом спринте.
Вектор векторов
Помимо основных типов данных, экземпляров структур и функциональных объектов, вектор может содержать в себе и другие объекты. Например, пары (std::pair), кортежи (std::tuple) и даже другие контейнеры. При этом вектор не может хранить функции и ссылки (например, int& или const Student&).
Рассмотрим более детально, как хранятся векторы в векторе. В результате получается структура данных типа std::vector<std::vector<любой тип>>.  Элементы такого вектора — другие векторы. Выглядит это как таблица с колонками и рядами.
Например, метеостанции необходимо хранить данные, а именно температуру за каждый час каждого дня. Данные за один день — это вектор из 24 значений. Данные за разные дни тоже можно хранить в векторе:
class MeteoData {
public:
    void StoreDayTemp(const std::vector<int>& day_temp) {
        temp_data_.push_back(day_temp);
    }
    
private:
    std::vector<std::vector<int>> temp_data_;
};
Таблицы и матрицы часто применяются в программировании. Например, изображение — это тоже таблица чисел. Для эффективности чаще используют не вектор векторов, а один вектор. Для этого все строки таблицы записывают подряд, получая одну длинную строку.
Заключение
В этом уроке вы разобрались, как вектор размещается в памяти и как происходит процесс реаллокации, когда выделенная память заканчивается. Теперь вы знаете, что происходит при изменении размера вектора с помощью метода resize(), а также как зарезервировать необходимое пространство в памяти с помощью reserve().
В поисках дружбы с алгоритмами
В этом уроке вы научитесь складывать значения вектора и находить минимальные и максимальные элементы в контейнере. А также выясните, почему без итераторов не обойтись при работе с алгоритмами.
Изобретать ли велосипед
В чём преимущество использования алгоритмов стандартной библиотеки? Во-первых, код становится более компактным. Во-вторых, снижается вероятность ошибок в вашем коде, поскольку алгоритмы уже протестированы.
Давайте начнём с алгоритмов поиска и вспомним, что уже изучили.
Чтобы понять, что в векторе нет элемента, надо сравнить результат с end().
В уроке с лямбда-функциями вы использовали диапазон поиска от первого элемента и до конца вектора. Теперь в вашем арсенале есть итераторы, они позволяют лучше управлять поиском. Однократный запуск find()  по элементам вектора вернёт только самый первый элемент, а точнее — итератор. Но если этот итератор не равен end(), можно ещё раз запустить поиск, изменив начальную позицию поиска. Напишем код, который найдет все позиции, где есть пятёрка:
std::vector<int> nums{1, 2, 3, 5, 2, 3, 5, 7, 1};
auto it = nums.begin();
do {
  it = std::find(it, nums.end(), 5);
  if(it != nums.end()) {
      std::cout << std::distance(nums.begin(), it) << std::endl;
      it++;
  }
} while(it != nums.end());
// Вывод: 3 и 6.
При каждом успешном результате смещаем итератор на одну позицию вперёд, чтобы предыдущий элемент снова не попал в поиск. Кроме этого искать можно с конца — для этого используйте rbegin() и rend().
std::vector<int> nums{1, 2, 3, 5, 2, 3, 5, 7, 1};
auto it = nums.rbegin();
do {
  it = std::find(it, nums.rend(), 5);
  if(it != nums.rend()) {
      std::cout << std::distance(nums.rbegin(), it) << std::endl;
      it++;
  }
} while(it != nums.rend());
// Вывод: 2 и 5.
Перейдем к count() и count_if() — алгоритмам, считающим количество искомых элементов.
При использовании count() в векторе не обязательно проходить по элементам от begin() до end(), можно задать тот участок вектора, где необходимо что-либо посчитать. Например, как мы только что искали позиции с пятёрками.
Если сохранить итератор первого найденного элемента, то можно посчитать, сколько двоек между двумя пятёрками:
// Уже знаем, что в векторе есть две пятёрки.
// Найдём итераторы:
auto it_first = std::find(nums.begin(), nums.end(), 5);
auto it_second = std::find(it_first + 1, nums.end(), 5);
// Теперь посчитаем двойки между пятёрками:
std::cout << std::count(it_first, it_second, 2) << std::endl;
Учимся складывать
Предположим, вы решили написать программу, которая считает, сколько строк кода пишет каждый из программистов в отделе за неделю. Эту задачу можно реализовать с помощью цикла for:
// Количество строк, написанных первым программистом
// с понедельника по пятницу.
std::vector<int> first_programer = {100, 210, 134, 89, 256};
int sum_first_programer = 0;


for (int lines : first_programer) {
    sum_first_programer += lines;
}


// Количество строк, написанных вторым программистом
// с понедельника по пятницу.
std::vector<int> second_programer = {670, 110, 578, 321, 83};
int sum_second_programer = 0;


for (int lines : second_programer) {
    sum_second_programer += lines;
}
Получается много циклов. Но если использовать алгоритм std::accumulate, то код станет компактнее. Чтобы его использовать, кроме библиотеки algorithm, надо подключить библиотеку numeric. Алгоритм std::accumulate принимает на вход указатели на начало и конец контейнера, а третьим параметром — начальное значение, получится так:
std::vector<int> first_programer = {100, 210, 134, 89, 256};
int sum_first_programer = std::accumulate(
    first_programer.begin(), // Начало диапазона.
    first_programer.end(),   // Конец диапазона.
    0                        // Начальное значение.
);


std::vector<int> second_programer = {670, 110, 578, 321, 83};
int sum_second_programer = std::accumulate(
    second_programer.begin(),
    second_programer.end(), 
    0
);
Выведем результат на печать:
std::cout << sum_first_programer << std::endl;
std::cout << sum_second_programer << std::endl;
Получим — 789 строк у первого программиста, а у второго — 1762.
Кроме чисел, std::accumulate умеет складывать и символы. Возьмём вектор символов:
std::vector<char> source_line = 
    {'A', 'l', 'g', 'o', 'r', 'i', 't', 'h', 'm', 's'};
Применим std::accumulate и создадим новую строку:
std::string new_line = std::accumulate(
    source_line.begin(), 
    source_line.end(), 
    std::string{}        // Начинаем с пустой строки.
);
std::cout << new_line.c_str() << std::endl;
// Будет выведено: Algorithms.
Также этот алгоритм умеет работать и с вектором строк:
std::vector<std::string> v_str{"Hello", ", ", "Algorithms", "!"};
std::string ss = std::accumulate(v_str.begin(), v_str.end(), std::string{});
std::cout << ss.c_str() << std::endl;
// Будет выведено: Hello, Algorithms!
Вы можете использовать std::accumulate  для сложения тех типов, у которых определена операция сложения. Если необходимо сложить объекты, например, объекты структур, у которых нет встроенной операции сложения, достаточно определить ее.
// Определим структуру с двумя числами - int и double.
struct TwoNums {
    int int_num;
    double double_num;
};


// Создадим вектор экземпляров структуры TwoNums.
std::vector<TwoNums> v_structs{{1, 1.2}, {2, 1.2}, {3, 1.2}, {4, 1.2}};


// Попробуем использовать std::accumulate для сложение элементов вектора.
TwoNums  nums = std::accumulate(v_structs.begin(), v_structs.end(), TwoNums {});
Программа не соберется, и компилятор выдаст такую ошибку:
error: no match for 'operator+' (operand types are 'TwoNums' and 'TwoNums')
  __init = __init + *__first;
           ~~~~~~~^~~~~~~~~~
Она говорит о том, что нет операции сложения для двух элементов с типом TwoNums. Определим операцию сложения:
TwoNums operator+(const TwoNums& lhs, const TwoNums& rhs) {
    return {lhs.int_num + rhs.int_num, lhs.double_num + rhs.double_num};
}
При наличии определенной операции сложения std::accumulate сможет сложить элементы из контейнера с любыми типами.
Ищем минимум и максимум
Для реализации поиска максимальных и минимальных значений в стандартной библиотеке есть несколько алгоритмов, которые решают эту задачу. Их можно разделить на две группы:
std::min, std::max, std::minmax. Принимают элементы и возвращают искомое значение:
int max_int = std::max(4, 5);  // 5.
int min_int = std::min(-7, 3); // -7.
auto [min, max] = std::minmax(14, 6);  // min = 6, max = 14.
auto [min2, max2] = std::minmax(
    {-0.4, 1e+5, 2.});  // min2 = -0.4, max2 = 1e+5.
std::min_element, std::max_element, std::minmax_element. Принимают диапазон как пару итераторов и возвращают итератор на искомый элемент:
// Позиции:              0  1  2  3  4  5  6  7
std::vector<int> nums = {1, 2, 5, 6, 7, 3, 7, 1};
auto it = std::max_element(nums.begin(), nums.end());
std::cout << "Максимум на позиции " << (it - nums.begin()) 
          << ", значение: " << (*it) << std::endl;
// Напечатает:
// Максимум на позиции 4, значение: 7.
Алгоритм max_element возвратил итератор на максимальный элемент вектора. Аналогично работают min_element, minmax_element.
Все функции поиска минимума и максимума работают с типами, для которых определена операция «меньше». Для использования в этих алгоритмах других типов достаточно определить operator< для нужного типа. Вот так может выглядеть перегрузка этой операции для структуры TwoNums:
bool operator<(const TwoNums& lhs, const TwoNums& rhs) {
    auto to_tuple = [](const TwoNums& val){
        return std::tie(val.int_num, val.double_num);
    };
    
    // Сравним структуры как кортежи.
    return to_tuple(lhs) < to_tuple(rhs);
}
Найдем минимум и максимум:
// Создадим вектор экземпляров структуры TwoNums.
std::vector<TwoNums> vec{{1, 1.2}, {20, 1.8}, {20, 1.2}, {0, 1.2}};


auto [min, max] = std::minmax_element(vec.begin(), vec.end());
// *min = {0, 1.2};
// *max = {20, 1.8};
И снова лямбда
Алгоритмы min, max, minmax и их аналоги для контейнера используют стандартный компаратор std::less. Но в них можно использовать любой другой компаратор. Например, найдём максимум по модулю, используя функцию std::abs:
std::vector<int> vec_int = {-5, 3, -9, -1, 6};


// Минимум по абсолютному значению:
auto it = std::max_element(vec_int.begin(), vec_int.end(), [](int a, int b) {
    return std::abs(a) < std::abs(b); 
});


// Выведет текст - "Максимальный элемент по модулю: -9".
std::cout << "Максимальный элемент по модулю: " << *it << std::endl;
Все сравнить и упорядочить
В этом уроке вы продолжите знакомство с алгоритмами, которые применяются в работе с контейнерами. Вы узнаете, как переложить элементы вектора задом наперёд и перемешать все элементы в случайном порядке. Продолжите изучать возможности уже знакомого std::sort, а также научитесь сравнивать последовательности элементов. 
Сравнение векторов с данными — это одна из важных задач, которая встречается в различных областях, включая машинное обучение и обработку данных. Например, при поиске по изображению или классификации объектов на фото.
Сравниваем диапазоны
Векторы, как и std::tuple, можно сравнивать, используя при этом все возможные операции сравнения: <, >, <=, >=, ==, != и <=>. При этом сравнение происходит лексикографически:
// Различие в этом элементе:     ↓
std::vector<int> v1{100, 200, 3, 4, 5};
std::vector<int> v2{100, 200, 3, 2, 1, 0};


std::cout << std::boolalpha; // Манипулятор для вывода bool.


std::cout << "v1 < v2: " << (v1 < v2) << std::endl;
std::cout << "v1 > v2: " << (v1 > v2) << std::endl;
std::cout << "v1 <= v2: " << (v1 <= v2) << std::endl;
std::cout << "v1 >= v2: " << (v1 >= v2) << std::endl;
std::cout << "v1 != v2: " << (v1 != v2) << std::endl;
std::cout << "v1 == v2: " << (v1 == v2) << std::endl;


// Получим:
// v1 < v2: false
// v1 > v2: true
// v1 <= v2: false
// v1 >= v2: true
// v1 != v2: true
// v1 == v2: false
В отличие от std::tuple в этой ситуации вектор является префиксом, то есть началом другого вектора. Здесь более короткий вектор считается меньшим, чем более длинный:
std::vector<std::string> v1{"I", "love", "C++"};
std::vector<std::string> v2{"I", "love", "C++", "very", "much"};


std::cout << std::boolalpha;


// Вектор v1 – префикс v2 и поэтому v1 меньше.
std::cout << "v1 < v2: " << (v1 < v2) << std::endl; // true.
Если необходимо сравнивать не векторы целиком, а диапазоны, заданные парами итераторов, для такой задачи подойдут следующие алгоритмы:
std::equal для проверки на равенство;
std::lexicographical_compare для проверки на неравенство;
std::lexicographical_compare_three_way для трехстороннего сравнения диапазонов (операции <=>).
Например, алгоритмом equal можно проверить, что строка является палиндромом. Такая проверка иногда необходима в поиске последовательности в полученных данных.
std::string s;
std::cin >> s;


// Такой алгоритм не будет работать для русского языка,
// но проблему решит QString.
if (std::equal(s.begin(), s.end(), s.rbegin(), s.rend())) {
    std::cout << "Строка " << s << " - палиндром!" << std::endl;
} else {
    std::cout << "Увы строка " << s << " не палиндром" << std::endl;
}
Также std::equal можно использовать, чтобы проверить, что один вектор или контейнер является префиксом другого.
template<class T>
bool CheckPrefix(const std::vector<T>& prefix, const std::vector<T>& full) {
    // Префикс не может быть длиннее всей строки.
    if (prefix.size() > full.size()) {
        return false;
    }
    
    // Сравниваем вектор prefix с началом вектора full
    // длины prefix.size().
    return std::equal(prefix.begin(), prefix.end(), 
          full.begin(), full.begin() + prefix.size());
}
Если вы уверены, что во втором диапазоне не меньше элементов, то четвёртый итератор можно опустить:
template<class T>
bool CheckPrefix(const std::vector<T>& prefix, const std::vector<T>& full) {
    // Префикс не может быть длиннее всей строки.
    if (prefix.size() > full.size()) {
        return false;
    }
    
    // Указали только три итератора:
    return std::equal(prefix.begin(), prefix.end(), full.begin());
}
При этом алгоритм воспримет третий итератор как начало диапазона. Используйте эту версию алгоритма с осторожностью: она не проверяет, что второй диапазон не закончился. Алгоритм может выйти за пределы диапазона, что приводит к неопределенному поведению.
Наведём порядок
Вы уже знаете, что алгоритм std::sort позволяет упорядочить последовательность. Для его использования необходимо подключать <algorithm>. Чтобы определить, как должны быть расположены элементы после std::sort, задается отношение порядка — условие, при котором один элемент нужно располагать раньше другого при сортировке. Для этого нужен компаратор.
Чтобы разобраться, как работает сортировка данных в контейнере,  возьмем в качестве примера результаты гонок на спортивных яхтах. По правилам подсчета результатов, первое место занимает та команда, которая набрала меньше всего очков.
Используем структуру Team и определим операцию сравнения:
struct Team {
    auto operator<=>(const Team& other) const {
        return points <=> other.points;
    }
    
    std::string name;
    int points;
};
Так как в условии задано, что первое место занимает команда с наименьшим числом очков, то подходит стандартный компаратор std::less, который используется по умолчанию:
std::vector<Team> teams;
teams.push_back({.name = "Team1", .points = 5});
teams.push_back({.name = "Team2", .points = 2});
teams.push_back({.name = "Team3", .points = 26});
teams.push_back({.name = "Team4", .points = 18});


std::sort(teams.begin(), teams.end());
Мы сформировали таблицу результатов. Но ведущему надо объявлять команды для награждения в обратном порядке. Чтобы помочь ведущему, можно сделать две вещи:
Пересортировать список, используя компаратор std::greater.
При выводе элементов начать с последнего.
Либо можно применить алгоритм std::reverse, который меняет порядок элементов на противоположный:
std::reverse(teams.begin(), teams.end());
Теперь команды будут расположены в обратном порядке. Так как std::reverse работает с итераторами, то это позволяет изменить порядок как всей последовательности, так и её части.
Не стоит применять std::reverse сразу после std::sort — лучше поменять компаратор и использовать только один алгоритм. Но reverse поможет, если порядок уже известен и его нужно поменять на противоположный.
Поиск уникумов
Предположим, перед вами стоит задача удалить из вектора все дубликаты, оставив каждый встречающийся элемент по одному разу. Например, дан такой вектор: 4, 2, 6, 3, 1, 5, 3, 2, 15, 0, 3, 1. Можно решить задачу следующим образом:
std::vector<int> GetUnique(const std::vector<int>& src) {
    std::vector<int> result;
    for (auto i : src) {
        // Добавляем элемент, если его ещё нет в result.
        if (std::find(result.begin(), result.end(), i) == result.end()) {
            result.push_back(i);
        }
    }
    return result;
}
Такой алгоритм работает, но медленно. Почему — вы узнаете далее из раздела об алгоритмической сложности.
Если отсортировать вектор, получим такую последовательность:
0, 1, 1, 2, 2, 3, 3, 3, 4, 5, 6, 15.
Одинаковые элементы встали рядом. Теперь убрать дубликаты проще:
std::vector<int> GetUniqueOfSorted(const std::vector<int>& src) {
    if (src.empty()) {
        return {};
    }
    
    std::vector<int> result;
    result.push_back(src.front());
    for (auto iter = src.begin() + 1; iter != src.end(), ++iter) {
        // Если элемент не равен предыдущему добавим его.
        if (*iter != *(iter - 1)) {
            result.push_back(*iter);
        }
    }
    return result;
}
Можно ли переписать этот алгоритм таким образом, чтобы он удалял элементы из исходного вектора, а не создавал новый? 
void UniqueOfSortedInplace(std::vector<int>& src) {
    if (src.empty()) {
        return {};
    }
    
    std::vector<int> result;
    result.push_back(src.front());
    for (auto iter = src.begin() + 1; iter != src.end(), ++iter) {
        // Удаляем элемент, если он равен предыдущему.
        if (*iter == *(iter - 1)) {
            result.erase(iter);
        }
    }
    return result;
}
В таком подходе есть проблема — удаление элементов приводит к инвалидации итераторов. Именно поэтому алгоритм std::unique, решающий эту задачу, ничего не удаляет. Вместо этого он переставляет дублированные элементы в конец вектора. Затем удалить их можно одной командой:
auto to_del = std::unique(some_vec.begin(), some_vec.end());
    some_vec.erase(to_del, some_vec.end();
Как видите, мы воспользовались итератором, который вернул алгоритм. Он указывает на элементы, которые нужно удалить, — они переставлены в конец.
Алгоритм std::unique уберёт в конец только идущие подряд дубликаты. Поэтому если цель — удалить их все, то его нужно применять к отсортированному контейнеру.
Похожим образом действуют алгоритмы std::remove и std::remove_if. Они не удаляют элементы, а переставляют их в конец. Но при этом возвращают итератор на то место, с которого нужно удалять.
std::vector<int> vec = {4, 2, 6, 3, 1, 5, 3, 2, 15, 0, 3, 1};


// Удалим двойки.
auto to_del = std::remove(vec.begin(), vec.end(), 2);
vec.erase(to_del, vec.end());
// vec == {4, 6, 3, 1, 5, 3, 15, 0, 3, 1};


// Удалим нечётные числа.
auto to_del2 = std::remove_if(vec.begin(), vec.end(), [](int i){
    return i % 2 != 0;
});
vec.erase(to_del2, vec.end());
// vec == {4, 6, 0};
Наведём беспорядок
Обратная задача упорядочивания — это рандомизация расположения элементов. Это может использоваться:
при создании карточной игры, чтобы перемешать карты в колоде;
для анализа — к примеру, вы получили опытным путём набор данных, но полученную информацию хотите взять не подряд, а использовать случайную выборку;
в реализации игры для генерации случайного маршрута.
Чтобы сделать что-то случайным образом, в программировании применяют генераторы псевдослучайных чисел. Механизма получать настоящую случайность в обычных компьютерах не существует, поэтому и используются псевдослучайные числа. Такие генераторы обладают предсказуемостью. Если знать все параметры генератора, то можно вычислить, какое случайное число будет следующим. Если продолжать эту процедуру, то можно получить последовательность псевдослучайных чисел.
Вот пример последовательности из 10 чисел от 1 до 1 000 000, полученной генератором псевдослучайных чисел: 137417, 594628, 635917, 656650, 816188, 605287, 364793, 421639, 394494, 737286.
Такие последовательности кажутся хаотичными и непредсказуемыми, для этого даже существуют математические критерии. Но эти числа всё равно сгенерированы однозначным алгоритмом. Один из самых известных таких алгоритмов — вихрь Мерсенна. Для использования его в C++ существует тип std::mt19937 из заголовочного файла <random>.
// Создадим генератор.
std::mt19937 gen;
// Нам нужны числа от 1 до 1 000 000.
std::uniform_int_distribution<> dist(1, 1'000'000);


// Создаём вектор для хранения случайных чисел из пяти элементов.
std::vector<int> random_numbers(5);


// И заполним его случайными числами.
for (auto& num : random_numbers) {
    num = dist(gen);
}
Чтобы получать из генератора gen числа в определенном диапазоне, нам понадобилось создать распределение dist. Объект класса uniform_int_distribution позволяет получать из генератора целые числа в некотором диапазоне, причем все числа появляются с равной вероятностью.
При запуске этой программы вы получите такую последовательность: 814724, 135478, 905792, 835009, 126987. Как вы можете заметить, последовательность будет всегда одна и та же. Чтобы изменить её, можно поменять сид (от англ. seed — зерно). Сид задается в конструкторе генератора и может кардинально изменить числа, которые вы получите:
// Используем сид 1:
std::mt19937 gen(1);


std::uniform_int_distribution<> dist(1, 1'000'000);
std::vector<int> random_numbers(5);
for (auto& num : random_numbers) {
    num = dist(gen);
}


// Теперь в векторе будут числа 417022, 997185, 720325, 932558, 115.
Но так мы всё равно не получим случайность, ведь сид жестко задан в коде. Однако есть ещё один способ получить случайный сид — аппаратный генератор случайного значения. В C++ он задан классом std::random_device. Объект этого класса позволяет получать невоспроизводимое число на основе системного времени и других характеристик оборудования. Этот способ получения псевдослучайных чисел намного медленней и его не рекомендуется использовать для логики программы. Но можно использовать для получения сида:
// Аппаратный генератор случайного значения:
std::random_device rd;   
// Инициализация начальным значением, полученным от аппаратного генератора:
std::mt19937 gen(rd()); 
Таким образом, для получения случайных чисел нужно три компонента.
Кроме этого генератор случайных чисел можно использовать для перемешивания элементов вектора. Для этого подойдёт алгоритм std::shuffle. Он принимает диапазон вектора и генератор псевдослучайных чисел третьим параметром.
// Заполним вектор значениями.
std::vector<int> numbers{1, 2, 3, 4, 5, 6};
// Создание генератора со случайным начальным значением.
std::random_device rd;  
std::mt19937 gen_shuffle(rd());
// Перемешаем элементы в векторе.
std::shuffle(numbers.begin(), numbers.end(), gen_shuffle);
При запуске этой программы вы будете получать разные перестановки чисел в векторе. Например: 3, 1, 6, 2, 5, 4 или 4, 6, 3, 2, 5, 1.

Алгоритмов много не бывает
Третий шаг в изучении алгоритмов — знакомство с методами заполнения контейнера. На примере работы с радиоэлектронными и звуковыми сигналами вы разберетесь с алгоритмами, которые заполняют диапазоны, преобразуют и генерируют элементы в векторе. А также научитесь использовать специальный итератор, добавляющий элементы в контейнер.
Нужные данные в нужном месте
При создании вектора можно использовать конструктор, который заполнит его нужным количеством копий заданного значения:
// Десять единиц:
std::vector<int> v_nums_one(10, 1);
// Вектор из ста фраз "Do it, just do it!":
std::vector<std::string> just_do_it(100, "Do it, just do it!");
// Вектор из 42-х других векторов:
std::vector<std::vector<int>> one_two_three(42, std::vector{1, 2, 3});
Но не всегда нужны одинаковые элементы. Например, мы храним в векторе звуковую дорожку. Цифровая звуковая дорожка задаётся отсчетами или семплами, то есть числами, которые определяют параметры звука в определенный момент. Для кодирования моно дорожки хорошо подходит вектор 16-битных чисел: std::vector<std::int16_t>.
Также звук можно изобразить в виде графика.





На этом рисунке изображён меандр или прямоугольный сигнал.
Создадим вектор из 48 000 элементов и запишем в него меандр. Такое число элементов соответствует одной секунде звука при частоте дискретизации 48 000 отсчетов в секунду. Наш меандр будет состоять из ста положительных отсчетов со значением 10 000 и ста отрицательных со значением -10 000.
Значение отсчета определяет громкость сигнала (чем больше — тем громче). Количество отсчетов в одной волне определяет высоту звука. В нашем случае одиночная волна содержит 200 отсчетов (100 положительных и 100 отрицательных). Можно определить высоту звука, поделив количество отсчетов в секунду (48 000) на длину волны (200). Получается звук частотой 240 Гц.
// Создадим вектор из 48 000 нулей.
std::vector<int16_t> signal(48000, 0);


int pos = 0;
int16_t current_elem = 10000;


for(auto& elem: signal) {
    // Если дошли до 100-го, меняем знак и сбрасываем счётчик.
    if (pos++ == 100) {
        pos = 0;
        current_elem = -current_elem;
    }
    
    // Меняем элемент вектора.
    elem = current_elem;
}
Или можно использовать тернарную операцию:
for(auto& elem: signal) {
    elem = ((pos++) % 200 < 100) ? current_elem : -current_elem;
}
Второй способ компактнее, но выглядит сложно.
Если сохранить этот сигнал в звуковой файл, то получим вот что (осторожно, звук громкий):
meander-240.mp3
Так звучит меандр. Если менять параметры меандра, то можно получить звук, схожий со звучанием аккордеона или губной гармошки. 
Меандр состоит из повторяющихся элементов. Чтобы заполнять векторы с повторяющимся набором элементов, существует специальный алгоритм — std::fill. Он берёт два итератора и заполняет все элементы между ними нужным значением, которое указывается третьим параметром:
// Конструктор создаст вектор из 20 букв a:
vector<string> repeat(20, "a");
// Напечатаем 20 a:
PrintVector(repeat);
// Заполним вектор буквами b и напечатаем 20 букв b:
std::fill(repeat.begin(), repeat.end(), "b");
PrintVector(repeat);
// Заполним начало буквами c и напечатаем 10 букв c и 10 букв b:
std::fill(repeat.begin(), repeat.begin() + 10, "c");
PrintVector(repeat);
Результат работы std::fill можно изобразить следующим образом:

Заполнение вектора с помощью std::fill
(Или от начала до конца)

Заполнение вектора с помощью std::fill
Вернёмся к меандру и заполним один виток волны — 200 отсчетов (одиночный меандр), используя алгоритм fill. Чтобы сделать это, нужно вызвать std::fill дважды: для заполнения положительными значениями и для заполнения отрицательными. Это выглядит так:
std::vector<int> meander(48000, 0);
// Заполним первые 200 отсчётов – одиночный меандр.
std::fill(meander.begin(), meander.begin() + 100, 10000);
std::fill(meander.begin() + 100, meander.begin() + 200, -10000);
Если создать вектор с пятью элементами и использовать meander.begin() + 10, то это приведет к неопределенному поведению. Алгоритм std::fill не занимается созданием новых ячеек и изменением размера вектора.
У алгоритма std::fill есть напарник std::fill_n, он в качестве второго параметра принимает не итератор, а количество элементов. Как и std::fill, этот алгоритм проходит по элементам вектора, начиная от начального итератора и меняя значения:
std::fill_n(meander.begin(), 100, 10000);
Как это работает:

Один за всех
Ранее мы создали вектор с одиночным меандром, используя std::fill_n. Чтобы заполнить меандром весь вектор, необходимо скопировать одиночный меандр. Для этого применим алгоритм std::copy_n. Как и у std::fill_n, у него есть числовой параметр — количество значений. Но в отличие от std::fill_n, он работает с двумя диапазонами элементов. Эти диапазоны могут принадлежать как одному контейнеру, так и к двум разным.
std::copy_n копирует элементы из одного диапазона в другой. Он принимает три параметра:
Итератор, указывающий откуда копировать.
Количество элементов.
Итератор, указывающий куда копировать.
Так это будет выглядеть в коде:
const int wave_length = 200;
for (size_t offset = wave_length;
    offset < signal.size(); 
    offset += wave_length) {
    
    // Копируем первые wave_length элементов в позицию offset.
    std::copy_n(meander.begin(), wave_length, signal.begin() + offset);
}
Такой цикл содержит ошибку, приводящую к проблеме, которую не всегда легко обнаружить. Последнее копирование может выйти за пределы вектора. При частоте дискретизации 48 000 этого не произойдёт, так как wave_length укладывается в размере вектора целое число раз. Но если уменьшить вектор, например, до 44 100 элементов, то программа войдет в состояние неопределённости.
В условии цикла проверили: offset < signal.size(), а затем заполнили 200 элементов, начиная с offset. Условие гарантирует, что в векторе есть один свободный элемент, но не гарантирует, что их 200. Никаких дополнительных проверок copy_n не осуществляет.
Решить проблему можно двумя способами:
Будем проверять, что в векторе ещё есть 200 элементов:
for (size_t offset = wave_length;
      // Меняем условие цикла. Обратите внимание на <=.
      offset + wave_length <= signal.size(); 
      offset += wave_length) {
     
     std::copy_n(meander.begin(), wave_length, signal.begin() + offset);
 }
 
Будем копировать осторожно, проверяя, уместится ли следующая порция с информацией в оставшуюся часть контейнера:
for (size_t offset = wave_length;
      offset < signal.size();
      // Не делаем инкремент здесь.
     ) {
     
     // Определим, сколько максимально можем скопировать.
     int max_copy = signal.size() - offset;
     
     // Сколько нужно скопировать: wave_length элементов,
     // но не больше max_copy.
     auto to_copy = std::min(wave_length, max_copy);
     
     // Теперь копируем не wave_length, а to_copy.
     std::copy_n(meander.begin(), to_copy, signal.begin() + offset);


     // Сделаем инкремент здесь.
     offset += to_copy;
 }
 
Первый способ имеет недостаток: в векторе могут остаться незаполненные значения. Второй способ заполнит всё целиком.
Части строк можно копировать так же, как элементы вектора.
Добавим элементов, или знакомство с back_inserter
Как вы выяснили, при использовании fill_n, copy, copy_n необходимо следить, чтобы алгоритм не выходил за пределы контейнера. Это особенно актуально для алгоритмов, которые записывают значения, где диапазон вывода задается только одним итератором.
Но есть специальный итератор, который не заполняет существующие элементы, а создает новые — back_inserter. Его применяют в алгоритмах, которые записывают значения. back_inserter указывается как выходной итератор и тогда записываемые значения будут добавляться в конец вектора.
При использовании std::back_inserter происходит добавление элемента в нужный вектор, и в этом случае автоматически изменяется размер вектора. Вектор, в который нужно вставлять элементы, указывается в конструкторе итератора.
//  Создадим вектор без указания количества элементов:
std::vector<int16_t> signal;


// Добавим 100 чисел 10000 в signal.
std::fill_n(std::back_inserter(signal), 100, 10000);
// Добавим еще 100 чисел -10000.
std::fill_n(std::back_inserter(signal), 100, -10000);


std::cout << signal.size();
// Результат вывода на печать: 200.
Таким образом, мы можем реплицировать меандр на весь вектор с сигналом:
void ReplicateSignal(std::vector<int16_t>& signal, size_t desired_length) {
    size_t wave_length = signal.size();
    while (signal.size() < desired_length) {
        size_t max_insert = desired_length - signal.size();
        size_t to_insert = std::min(wave_length, max_insert);
        
        // В цикле будем добавлять по 200 элементов.
        std::copy_n(signal.begin(), to_insert, std::back_inserter(signal));
    }
}
Чтобы back_inserter работал эффективно, нужно добавить вызов reserve перед заполнением контейнера:
//  Создадим вектор без указания количества элементов:
std::vector<int> signal;
signal.reserve(48000);
// Код заполнения.
back_inserter основан на том, что алгоритмы copy, copy_n, fill_n работают очень просто. Например, так может быть реализован copy_n:
template<class InIter, class Size, class OutIter)
void std::copy_n(InIter in_iter, Size size, OutIter out_iter) {
    for (Size i{0}; i < size; ++i) {
        // Передвигаем оба итератора, 
        // записывая из входного итератора in_iter
        // в выходной out_iter.
        *(out_iter++) = *(in_iter++);
    }
}
У итератора back_inserter операции ++ и * ничего не делают. Поэтому запись *(inserter++) = *(in_iter++); эквивалентна inserter = *(in_iter++);. А вот присваивание переопределено — оно вызывает push_back контейнера. И в этом случае происходит добавление нового элемента в конец последовательности.
Функциональный стиль
Выше вы услышали, как звучит меандр. Тембр звучания определяет спектром звука, который показывает, какие частоты присутствуют в сигнале. Максимально простой спектр имеет синусоида. Давайте послушаем её.
std::vector<int16_t> signal;
signal.reserve(48000);


const double amplitude = 15000;
const int wave_length = 200;


for (int i = 0; i < wave_length; ++i) {
    // Далее формула синусоиды с заданной амплитудой и длиной волны.
    double value = amplitude * sin(2 * i * std::numbers::pi / wave_length);
    signal.push_back(static_cast<int16_t>(value));
}
ReplicateSignal(signal, 48000);
Вот что получится, если сохранить этот сигнал в файл:
sinus-240.mp3
Такой звук характеризуют как мягкий, округлый. Он похож на звук кларнета. Но в конце есть щелчок из-за резкого окончания волны. На меандре этот щелчок не был слышен, так как меандр сам по себе делает резкие скачки. Чтобы избавиться от щелчка, добавим затухание звука (decay) в конец сигнала:
void ApplyDecay(std::vector<int16_t>& signal, size_t max_length) {
    // Не забудем уменьшить длину.
    size_t decay_length = std::min(signal.size(), max_length);


    // Используем цикл с убывающим счётчиком.
    for(size_t i = decay_length; i > 0; --i) {
        int16_t& sample = signal[signal.size() - i];
        // Умножим сигнал на убывающую величину.
        // Здесь она вычисляется.
        double factor = double(i) / decay_length;
        sample = static_cast<int16_t>(sample * factor);
    }
}


// ...
// main()


// Сделаем затухание длиной в 25 миллисекунд.
ApplyDecay(signal, 48000 / 1000 * 25);
sinus-240-decay.mp3
Для выполнения этих операций — генерирования звука и применения затухания — мы использовали циклы. Такой стиль программирования называют императивным: в программе последовательно описываются действия. Но C++ сочетает в себе элементы другого стиля — функционального. Вы уже сталкивались с ним, когда использовали функциональные объекты.
Попробуем применить функциональный стиль к заполнению сигнала. Для этого нам пригодятся алгоритмы generate и transform. Первый имеет брата-близнеца — generate_n. Он использует функциональный объект, чтобы заполнить требуемый диапазон. Функциональный объект вызывается многократно и результаты этих вызовов используются для заполнения контейнера:
std::vector<int16_t> signal;
signal.reserve(48000);


const double amplitude = 15000;
const int wave_length = 200;


// Используем mutable-лямбда функцию. Она может менять захваченные значения.
// В данном случае меняем i, который инициализируем в 
// квадратных скобках: i = 0.
auto generator = [=, i = 0]() mutable {
    // Возвратим значение. Алгоритм generate_n добавит его
    // в вектор.
    return amplitude * sin(2 * i++ * std::numbers::pi / wave_length);
};


std::generate_n(std::back_inserter(signal), wave_length, generator);
Плюс такого подхода в том, что вы можете сохранить генератор нужного сигнала и использовать его, когда требуется. Более того, можно применять к нему различные модификации.
transform тоже записывает значения, но работает по-другому. Он читает элементы из одного диапазона, применяет к ним указанную функцию и записывает результат функции в другой диапазон. transform похож на copy, но добавляет применение функции.
Теперь используем transform, чтобы применить затухание:
void ApplyDecay(std::vector<int16_t>& signal, size_t max_length) {
    size_t decay_length = std::min(signal.size(), max_length);
    
    auto transformer = [=, i = decay_length](int16_t source) mutable {
        double factor = double(i--) / decay_length;
        return static_cast<int16_t>(source * factor);
    };


    auto start_pos = signal.end() - decay_length;
    std::transform(start_pos, signal.end(), start_pos, transformer);
}
transform принимает:
входной диапазон (два итератора),
выходной итератор,
преобразователь (функциональный объект).
Преобразователь применяется к каждому элементу входного диапазона. Результат записывается по выходному итератору. В этом случае мы использовали одинаковые входной и выходной диапазон, чтобы менять значения вектора без выделения вспомогательной памяти (по-английски часто используется слово inplace).

Дополнительный материал для экзамена (C++17 и лучшие практики)

Новые возможности C++17 для векторов
С появлением C++17 работа с векторами стала еще удобнее благодаря нескольким нововведениям:

1. Автоматический вывод типов шаблонов (CTAD - Class Template Argument Deduction)
До C++17:
std::vector<int> numbers = {1, 2, 3, 4, 5};

С C++17:
std::vector numbers = {1, 2, 3, 4, 5}; // автоматически std::vector<int>
std::vector words = {"hello", "world"}; // автоматически std::vector<const char*>

2. Структурированные привязки (Structured bindings)
auto [min_it, max_it] = std::minmax_element(vec.begin(), vec.end());
std::cout << "Min: " << *min_it << ", Max: " << *max_it << std::endl;

3. Улучшенная работа с алгоритмами
// Параллельные алгоритмы (требует execution policy)
std::sort(std::execution::par, vec.begin(), vec.end());

Лучшие практики работы с векторами

1. Предварительное резервирование памяти
// Плохо - множественные реаллокации
std::vector<int> data;
for (int i = 0; i < 1000; ++i) {
    data.push_back(i);
}

// Хорошо - одна аллокация
std::vector<int> data;
data.reserve(1000);
for (int i = 0; i < 1000; ++i) {
    data.push_back(i);
}

2. Использование emplace_back вместо push_back для объектов
struct Point {
    int x, y;
    Point(int x, int y) : x(x), y(y) {}
};

// Менее эффективно - создание временного объекта
std::vector<Point> points;
points.push_back(Point(1, 2));

// Более эффективно - конструирование на месте
points.emplace_back(1, 2);

3. Правильное удаление элементов
// Удаление всех четных чисел
std::vector<int> numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
auto new_end = std::remove_if(numbers.begin(), numbers.end(), 
                              [](int n) { return n % 2 == 0; });
numbers.erase(new_end, numbers.end());

4. Использование range-based for с правильными типами
// Для чтения - const auto&
for (const auto& item : expensive_objects) {
    // обработка без копирования
}

// Для изменения - auto&
for (auto& item : numbers) {
    item *= 2;
}

// Для простых типов - auto
for (auto value : numbers) {
    std::cout << value << " ";
}

Типичные ошибки и их избежание

1. Инвалидация итераторов
// ОШИБКА
for (auto it = vec.begin(); it != vec.end(); ++it) {
    if (*it == target) {
        vec.erase(it); // Итератор инвалидирован!
    }
}

// ПРАВИЛЬНО
for (auto it = vec.begin(); it != vec.end();) {
    if (*it == target) {
        it = vec.erase(it); // erase возвращает следующий валидный итератор
    } else {
        ++it;
    }
}

2. Выход за границы
// ОШИБКА - нет проверки границ
int value = vec[vec.size()]; // Неопределенное поведение

// ПРАВИЛЬНО
if (!vec.empty()) {
    int value = vec.back();
}
// или
int value = vec.at(index); // Генерирует исключение при выходе за границы

3. Неэффективное копирование
// ОШИБКА - ненужное копирование
std::vector<std::string> process_data(std::vector<std::string> data) {
    // обработка
    return data;
}

// ПРАВИЛЬНО - передача по ссылке
std::vector<std::string> process_data(const std::vector<std::string>& data) {
    std::vector<std::string> result;
    // обработка
    return result;
}

Продвинутые техники

1. Кастомные аллокаторы
// Пример использования кастомного аллокатора
std::vector<int, std::allocator<int>> standard_vec;
// Можно использовать специализированные аллокаторы для оптимизации

2. Использование std::vector<bool> - особый случай
// std::vector<bool> - специализация, не является истинным контейнером
std::vector<bool> flags(100, false);
// Нельзя получить указатель на элемент: &flags[0] - ошибка компиляции

3. Двумерные векторы
// Создание матрицы
std::vector<std::vector<int>> matrix(rows, std::vector<int>(cols, 0));

// Более эффективная альтернатива - плоский вектор
std::vector<int> flat_matrix(rows * cols, 0);
// Доступ: flat_matrix[row * cols + col]

Оптимизация производительности

1. Использование shrink_to_fit для освобождения лишней памяти
std::vector<int> data(1000000);
data.resize(100);
data.shrink_to_fit(); // Освобождает неиспользуемую память

2. Избегание частых вставок в середину
// Неэффективно для больших векторов
for (int i = 0; i < 1000; ++i) {
    vec.insert(vec.begin(), i);
}

// Лучше собрать данные, затем reverse
std::vector<int> temp;
for (int i = 0; i < 1000; ++i) {
    temp.push_back(i);
}
std::reverse(temp.begin(), temp.end());

3. Использование move-семантики
std::vector<std::string> source = {"a", "b", "c"};
std::vector<std::string> dest = std::move(source); // Перемещение вместо копирования

Совместимость и переносимость

1. Гарантии исключений
// std::vector предоставляет строгую гарантию исключений для:
// - push_back (если T имеет noexcept move constructor)
// - emplace_back
// - pop_back (noexcept)

2. Требования к типам элементов
// Для хранения в векторе тип должен быть:
// - CopyConstructible или MoveConstructible
// - CopyAssignable или MoveAssignable
// - Destructible

Заключение дополнительного материала

Эффективная работа с std::vector требует понимания его внутреннего устройства, особенностей управления памятью и правильного использования алгоритмов. Современные стандарты C++ предоставляют множество инструментов для оптимизации работы с векторами, но важно помнить о базовых принципах и избегать типичных ошибок.

