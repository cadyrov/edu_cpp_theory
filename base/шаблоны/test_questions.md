# Тест по теме "Шаблоны в C++"

## Вопрос 1
Что такое строгая типизация в C++?
A) Возможность изменять тип данных во время выполнения
B) Невозможность изменить тип данных во время выполнения, все типы определяются при компиляции
C) Автоматическое приведение типов
D) Использование только примитивных типов данных

## Вопрос 2
Какое ключевое слово используется для создания шаблона?
A) generic
B) template
C) class
D) typename

## Вопрос 3
Что означает инстанцирование шаблона?
A) Создание объекта класса
B) Генерация кода по шаблону с конкретными типами
C) Удаление шаблона из памяти
D) Компиляция программы

## Вопрос 4
Какие два ключевых слова можно использовать для объявления типового параметра шаблона?
A) class и struct
B) typename и class
C) template и generic
D) auto и decltype

## Вопрос 5
Что произойдет при компиляции следующего кода?
```cpp
template<typename T>
class Square {
public:
    T CountArea() {
        return a_ * b_;
    }
private:
    T a_, b_;
};

int main() {
    Square<std::string> sq_str;
    // sq_str.CountArea(); // эта строка закомментирована
}
```
A) Ошибка компиляции сразу при объявлении Square<std::string>
B) Ошибка компиляции только при вызове CountArea()
C) Код скомпилируется успешно
D) Предупреждение компилятора

## Вопрос 6
Где принято размещать определения методов шаблонных классов?
A) В .cpp файлах
B) В .h файлах вместе с объявлением класса
C) В отдельных .template файлах
D) В любом месте

## Вопрос 7
Что такое выведение типов (type deduction) в шаблонных функциях?
A) Ручное указание типов программистом
B) Автоматическое определение типов компилятором по аргументам
C) Преобразование типов во время выполнения
D) Проверка типов на этапе компиляции

## Вопрос 8
Какой результат выведет следующий код?
```cpp
template<typename T>
T Sum(T a, T b) {
    return a + b;
}

int main() {
    std::cout << Sum(10, 20) << std::endl;
}
```
A) Ошибка компиляции
B) 30
C) 1020
D) Неопределенное поведение

## Вопрос 9
Что произойдет при компиляции этого кода?
```cpp
template<typename T>
T Sum(T a, T b) {
    return a + b;
}

int main() {
    Sum(10.1, 10); // разные типы аргументов
}
```
A) Код скомпилируется, результат будет 20.1
B) Код скомпилируется, результат будет 20
C) Ошибка компиляции из-за неоднозначности типов
D) Предупреждение, но код скомпилируется

## Вопрос 10
Какое ключевое слово используется для автоматического определения типа возвращаемого значения?
A) decltype
B) auto
C) typename
D) template

## Вопрос 11
Что такое tuple в C++?
A) Контейнер для элементов одного типа
B) Шаблонный класс для хранения нескольких значений разных типов
C) Указатель на функцию
D) Тип данных для строк

## Вопрос 12
Как получить второй элемент tuple?
A) tuple[1]
B) tuple.get(1)
C) std::get<1>(tuple)
D) tuple.at(1)

## Вопрос 13
Что делает следующий код?
```cpp
auto [a, operation, b] = std::tuple(627, "-"s, 27);
```
A) Создает три отдельные переменные
B) Распаковывает tuple в три переменные
C) Создает массив из трех элементов
D) Вызывает ошибку компиляции

## Вопрос 14
Что такое std::optional?
A) Контейнер, который всегда содержит значение
B) Тип, который может содержать значение или быть пустым
C) Указатель на опциональные данные
D) Шаблон для создания необязательных параметров

## Вопрос 15
Как проверить, содержит ли std::optional значение?
A) if (opt.empty())
B) if (opt.has_value())
C) if (opt != nullptr)
D) if (opt.size() > 0)

## Вопрос 16
Что произойдет при выполнении этого кода?
```cpp
std::optional<int> opt;
int value = *opt;
```
A) value будет равно 0
B) Ошибка компиляции
C) Неопределенное поведение
D) Исключение std::bad_optional_access

## Вопрос 17
Что такое нетиповые параметры шаблонов?
A) Параметры, которые не имеют типа
B) Параметры-значения, известные на этапе компиляции
C) Параметры, которые могут быть любого типа
D) Параметры, определяемые во время выполнения

## Вопрос 18
Какие типы могут быть нетиповыми параметрами шаблонов?
A) Только целочисленные
B) Целочисленные, логические, указатели
C) Любые типы данных
D) Только строки и числа

## Вопрос 19
Что делает следующий код?
```cpp
template<typename T, size_t Size>
struct Array {
    T data[Size];
};

Array<int, 5> arr;
```
A) Создает динамический массив
B) Создает статический массив фиксированного размера
C) Создает вектор размера 5
D) Вызывает ошибку компиляции

## Вопрос 20
Что такое if constexpr?
A) Условный оператор, выполняющийся во время выполнения
B) Условный оператор, проверяющий условие на этапе компиляции
C) Макрос для условной компиляции
D) Функция для проверки констант

## Вопрос 21
Какой результат выведет этот код?
```cpp
template<bool flag>
void test() {
    if constexpr (flag) {
        std::cout << "true";
    } else {
        std::cout << "false";
    }
}

int main() {
    test<true>();
}
```
A) true
B) false
C) Ошибка компиляции
D) Ничего не выведет

## Вопрос 22
Что такое специализация шаблонов?
A) Создание более быстрых версий шаблонов
B) Определение шаблона по-разному для разных типов
C) Оптимизация шаблонов компилятором
D) Использование шаблонов только для специальных случаев

## Вопрос 23
Как объявляется полная специализация шаблона класса?
A) template<typename T> class MyClass<int>
B) template<> class MyClass<int>
C) class MyClass<int> : public MyClass<T>
D) specialization class MyClass<int>

## Вопрос 24
Что произойдет при компиляции этого кода?
```cpp
template<typename T>
T Max(T a, T b) {
    return a > b ? a : b;
}

template<>
std::string Max(std::string a, std::string b) {
    return a.length() > b.length() ? a : b;
}

int main() {
    std::cout << Max(std::string("hello"), std::string("world"));
}
```
A) Выведет "hello"
B) Выведет "world"
C) Ошибка компиляции
D) Неопределенное поведение

## Вопрос 25
Что такое частичная специализация шаблона?
A) Специализация только части методов класса
B) Специализация шаблона для группы типов, а не конкретного типа
C) Неполная реализация шаблона
D) Специализация только для примитивных типов

## Вопрос 26
Какой код демонстрирует частичную специализацию?
```cpp
// Вариант A
template<typename T, typename U>
class Pair {};

template<typename T>
class Pair<T, std::string> {};

// Вариант B
template<typename T>
class Container {};

template<>
class Container<int> {};
```
A) Вариант A
B) Вариант B
C) Оба варианта
D) Ни один из вариантов

## Вопрос 27
Что означает принцип DRY в программировании?
A) "Don't Repeat Yourself" - не повторяйся
B) "Do Right Yesterday" - делай правильно вчера
C) "Debug Rapidly Yearly" - отлаживай быстро ежегодно
D) "Develop Robust Yearly" - разрабатывай надежно ежегодно

## Вопрос 28
Какое преимущество дают шаблоны по сравнению с макросами?
A) Более быстрая компиляция
B) Обработка компилятором с учетом содержимого, а не простая замена текста
C) Меньший размер исполняемого файла
D) Поддержка только в новых версиях C++

## Вопрос 29
Что произойдет при выполнении этого кода?
```cpp
template<int N>
int factorial() {
    return N * factorial<N-1>();
}

template<>
int factorial<0>() {
    return 1;
}

int main() {
    std::cout << factorial<5>();
}
```
A) Выведет 120
B) Выведет 5
C) Ошибка компиляции
D) Бесконечная рекурсия

## Вопрос 30
В чем основное отличие статических массивов от векторов?
A) Статические массивы быстрее векторов
B) Размер статических массивов фиксирован на этапе компиляции
C) Статические массивы могут хранить только примитивные типы
D) Векторы не поддерживают индексацию 