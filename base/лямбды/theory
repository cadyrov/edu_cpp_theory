Кто хочет поработать?
Действие как объект
Предположим, вам необходимо разработать программу для кофейни, где подают разные напитки: кофе, чай, какао.
Для этого создадим три функции:
using OrderId = size_t;
int MakeCoffee(OrderId order_number) {
  // Приготовить кофе.
  // Вернуть стоимость приготовленного кофе.
}
int MakeCocoa(OrderId order_number) {
  // Приготовить какао.
  // Вернуть стоимость приготовленного какао.
}
int MakeTea(OrderId order_number) {
  // Приготовить чай.
  // Вернуть стоимость приготовленного чая.
}
Официант получает заказ, потом идёт к баристе и говорит, что надо приготовить. Создадим enum для типов напитков:
enum class DrinkType {
  kCoffee,
  kCocoa,
  kTea
};
Листок заказа официанта можно представить как вектор с данными (типы напитков):
std::vector<DrinkType> drinks;
Напишем функцию, которая примет на вход номер заказа и этот вектор, затем будет выполняться приготовление нужных напитков:
int DoOrder(OrderId order_number, const std::vector<DrinkType>& order) {
    int cost = 0;
    for (DrinkType type_drink : order) {
        switch (type_drink) {
        case DrinkType::kCoffee: 
          cost += MakeCoffee(order_number);
          break;
        case DrinkType::kCocoa:
          cost += MakeCocoa(order_number);
          break;
        case DrinkType::kTea:
          cost += MakeTea(order_number);
          break; 
        }
    }
    return cost;
}
Сейчас меню разнообразное — и количество case невелико. Но если добавлять другие напитки, код будет разрастаться, становясь всё более громоздким. Хорошо было бы сразу размещать в контейнер действия, которые можно запустить на исполнение. Сейчас вы уже умеете сохранять числа и строки в переменные, теперь надо научиться сохранять действие и работать с этим созданным объектом. Такое сохраненное действие называется функциональным объектом.
Разберемся, что скрывается под нашим типом CookAction. Он связан с созданием функционального объекта, который проще всего получить из имеющейся обычной функции. Но нельзя просто присвоить в переменную объявление функции:
// Так не сработает.
auto action = MakeCoffee(OrderId); // Ошибка!
int cost = action(3);
Код не скомпилируется. Чтобы сохранить функцию в переменную, используется обёртка std::function. Это шаблон класса, который позволяет использовать функцию как значение. Значение можно записать в переменную или добавить в вектор. В качестве шаблонного параметра std::function принимает сигнатуру функции, которую может сохранить:
// Теперь CookAction – функция,
// принимающая OrderId и возвращающая int.
using CookAction = std::function<int (OrderId)>;

int DoOrder(OrderId order_number, const std::vector<CookAction>& order) {
  int cost = 0;
  for (CookAction action : order) {
    cost += action(order_number);
  }
  
  return cost;
}
Объект типа std::function<...> можно сконструировать из обычной функции. При этом мы не вызываем функцию, то есть не указываем её аргументы. Пишем только имя. Так, например, можно вызвать DoOrder, передав в контейнере имена функций, которые надо будет вызвать для выполнения заказа:
// Кофе и два чая в заказ 15.
DoOrder(15, {MakeCoffee, MakeTea, MakeTea});
Вы могли заметить, что мы указали сигнатуру в качестве шаблонного параметра. На самом деле сигнатура здесь — это тип, который описывает использование функции. Он описывает функциональный объект, который получается из обычной функции. В отличие от std::function, нельзя создать переменную такого типа или сложить объекты в вектор. Таким образом, std::function добавляет больше возможностей примитивному функциональному типу.
Обобщенную схему объявления переменной типа std::function можно представить так:
std::function<возвращаемый_тип(параметры функции)> имя_переменной;
Важно, что описанная сигнатура должна быть идентична функции, которую вы будете сохранять в этот объект. Это напоминает присваивание обычных переменных. К примеру, следующий код не скомпилируется, потому что типы не совпадают:
int number;
std::string str = "";
number = str;
Даже если функции делают разные операции, но имеют одинаковые сигнатуры, их можно будет записать в эту переменную.Используем правильные варианты функций для присваивания их в функциональные объекты, которые затем можно вызвать. Обратите внимание: для работы с std::function надо подключить #include <functional>.
#include <functional>
#include <iostream>

void SayHello(const std::string& name) {
    std::cout << "Привет, " << name<< "!" << std::endl;
}

void WriteMessage(const std::string& message) {
    std::cout << message << std::endl;
}

void PrintReversed(const std::string& text) {
    // Простейший способ перевернуть текст.
    std::cout << std::string(text.rbegin(), text.rend()) << std::endl;
}

int main() {
  // Объявление.
  std::function<void(const std::string&)> action;
  
  // Присвоим и вызовем функцию SayHello.
  action = SayHello;
  action("Студент Практикума");
  
  // Теперь изменим выполняемое действие, присвоив функцию WriteMessage.
  action = WriteMessage;
  action("Это урок об изучении функциональных объектов");
  
  // Ещё раз поменяем выполняемое действие.
  action = PrintReversed;
  action("Раз два три четыре пять");
}
Но вернёмся к нашему типу CookAction, который мы передали как тип создаваемого вектора действия. Под этим именем как раз скрывается std::function с описанной сигнатурой функции int (OrderId), то есть std::function<int(OrderId)>. Чтобы не писать столь сложный тип, можно упростить, используя using:
using CookAction = std::function<int(OrderId)>;
Теперь можно создать вектор для хранения объектов с типом CookAction:
using CookAction = std::function<int(OrderId)>;
std::vector<CookAction > order;

order.push_back(MakeCoffee);
order.push_back(MakeCocoa);
Теперь мы можем выполнить действия, которые поместили в контейнер. Для этого используем цикл for:
for (CookAction action : order) {
  cost += action(order_number);
}
Функторы
Вы увидели, как сохранить в std::function функцию. Но можно сохранить и другой объект. Главное требование — возможность использовать круглые скобки: object(...). Такие объекты object называют функторами. Можно сделать свой класс функтором, если определить в нём операцию круглые скобки — operator().
Создадим простой функтор, который возвращает void и имеет параметр типа const std::string&:
class Action {
public:
  void operator()(const std::string& text) {
    std::cout << "Печать текста: '" 
              << text << "'" << std::endl;
  }
};
Так же, как при работе со структурами и классами, вам необходимо:
создать экземпляр;
вызвать метод класса или структуры.
Action action;
// operator() — это название метода.
// После него нужны еще одни скобки.
action.operator()("Привет");

// Результат работы:
// Печать текста: 'Привет'
Как и в других случаях, название операции можно убрать:
Action action;
// "Вызываем" объект, как будто это функция.
// На самом деле вызываем operator().
// Так гораздо короче.
action("Привет");
Создав объект типа с определённым operator(), его можно поместить в std::function. Для этого можно создать переменную или временный объект:
struct SayGoodMorning {
    void operator()(const std::string& name) {
        std::cout << "Доброе утро, " << name<< "!" << std::endl;
    }
};

int main(int argc, char *argv[]) {    
    // Вариант 1: 
    // Cоздать объект.
    SayGoodMorning say;
    
    // Запись в std::function.
    std::function<void(const std::string&)> action_say = say;
    
    //Вариант 2 — без создания экземпляра структуры.
    std::function<void(const std::string&)> action_say = SayGoodMorning{};
    // Вызов.
    action_say("Друг");
}
Альфа, бета? Лямбда!
В прошлом уроке вы научились создавать функциональные объекты с помощью функторов и обычных функций. В этом вы познакомитесь с одним из самых удобных и гибких способов создания объектов — с лямбда-функциями. Как и любое другое средство языка, лямбда-функции могут принести пользу, а могут навредить. В уроке вы узнаете о границах применимости таких функций и будете учиться извлекать из них только пользу.
Создание локальных функций
Возьмём для примера программу, реализующую хор зверушек. У каждого солиста своя партия. Напишем код, где для каждого исполнителя есть отдельная функция:
void CatSing() {
  cout << "Мяу, Мяу, Мяу" << endl;
}

void DogSing() {
  cout << "Гав, Гав, Гав" << endl;
}

void DuckSing() {
  cout << "Кря, Кря, Кря" << endl;
}

int ChoralSing() {
  CatSing();
  DogSing(); 
  DuckSing()
}
Нам понадобилось три функции, которые очень похожи и используются только в ChoralSing. Чтобы не засорять глобальное пространство имён, мы бы хотели перенести их внутрь ChoralSing. Но напрямую разместить одну функцию внутри другой нельзя. Зато можно внутри функции разместить класс или структуру. Такой класс будет называться локальным, из него можно сделать функтор, поместив в него operator():
int ChoralSing() {
    // Структура внутри функции.
    // Она называется локальной.
    struct AnimalSong {
        void operator()(std::string x) const {
            std::cout << x << ", " << x << ", " << x << std::endl;
        };
    };
    
    AnimalSong song;
    song("Мяу");
    song("Гав");
    song("Кря");
}
Стало лучше — мы смогли убрать три функции и сократить количество кода. Но можно сделать ещё лучше. В C++ есть синтаксический сахар для функтора внутри функции. Этот объект называется лямбда-функцией:
int ChoralSing() {
    // Лямбда-функция записывается в переменную song.
    /* какой-то тип */ song = [](std::string x) {
      std::cout << x << ", " << x << ", " << x << std::endl;
    };
    
    // Трижды вызовем лямбда-функцию.
    song("Мяу"); 
    song("Гав");  
    song("Кря"); 
}
Под капотом компилятор создает структуру. Тип её нам неизвестен. Но знать его не обязательно, ведь можно написать auto:
int ChoralSing() {
    // Пишем auto — компилятор сам выведет тип.
    auto song = [](std::string x) {
        std::cout << x << ", " << x << ", " << x << std::endl;
    };

    // ...
}
Чтобы записать лямбда-выражение, понадобилось три вида скобок:
Пустые квадратные [] — основной признак лямбда-функции.
Круглые с параметрами, как у обычной функции, (std::string x).
Фигурные — с телом функции {...}.
Похожий эффект был бы, если бы мы создали обычную функцию с именем song. 
А что вернем?
В лямбда-функциях тип возвращаемого значения выводится автоматически на основании оператора return:
auto make_song_text = [](std::string x) {
    using namespace std::literals;
    // На основании этого return компилятор
    // поймёт, что лямбда возвращает std::string.
    return x + ", "s + x + ", "s + x;
};

// Вызываем лямбда-функцию, получая результат.
std::string my_text = make_song_text("Мяу");
assert(my_text == "Мяу, Мяу, Мяу");
Но есть возможность указать тип явно. Он указывается после стрелки (символов ->) между списком параметров и телом лямбды:
// Указываем тип явно: лямбда принимает
// std::string и возвращает его же.
auto make_song_text = [](std::string x) -> std::string {
    using namespace std::literals;
    return x + ", "s + x + ", "s + x;
};
Сохранение в другую переменную
Лямбда-функция — это выражение. Их можно свободно писать в любом месте внутри функции. Значение этого выражения сохраняется в переменную. С лямбда-функцией можно делать то же, что и с любым другим объектом: передавать в функцию как аргумент, возвращать из функции, пересохранять в другую переменную:
// Объявили:
auto song = [](std::string x) {
    std::cout << x << ", " << x << ", " << x << std::endl;
};

// Сохранили в другую переменную:
auto save_song = song;
В прошлом уроке вы познакомились с классом-обёрткой std::function, в который мы сохраняли обычные функции и функторы.
Добавим в этот список теперь и лямбда-функции. Напомним: чтобы записать объект в обертку std::function, необходимо совпадение сигнатур — возвращаемый тип и входные данные должны быть идентичными.
// Создадим лямбда-функцию.
auto lambda_song = [](std::string x) {
    std::cout << x << ", " << x << ", " << x << std::endl;
};
// Сохраним в std::function.
std::function<void(std::string x)> song = lambda_song;
    
// Вызовем.
song("До-ми-соль"s);
Лямбда и захват по ссылке
Рассмотрим ещё один пример работы со строкой. Возьмём реализацию функции деления ее на части. Запятая будет в качестве разделителя. Пустые части будем игнорировать. Попробуем написать эту функцию так:
std::vector<std::string> Split(const std::string& input_string) {
    std::vector<std::string> result;
    
    std::string cur_str;
    for(char c : input_string) {
        if (c == ',') {
            if (cur_str != "") {
                result.push_back(cur_str);
            }
            cur_str = "";
        } else {
            cur_str += c;
        }
    }
    
    return result;
}
Чтобы функция ничего не теряла, добавим в её конец вставку строки:
std::vector<std::string> Split(const std::string& input_string) {
    std::vector<std::string> result;
    
    std::string cur_str;
    for(char c : input_string) {
        if (c == ',') {
            if (cur_str != "") {
                result.push_back(cur_str);
            }
            cur_str = "";
        } else {
            cur_str += c;
        }
    }
    
    if (cur_str != "") {
        result.push_back(cur_str);
    }
    cur_str = "";
    
    return result;
}
if (cur_str != "") {
    result.push_back(cur_str);
}
cur_str = "";
Исправив ошибку, мы создали дублирование, убрать которое поможет лямбда-функция. Попробуем написать её:
std::vector<std::string> Split(const std::string& input_string) {
    std::vector<std::string> result;
    std::string cur_str;
    
    // Объявляем лямбду.
    auto add_part = []{
        // Тут будет ошибка!
        if (cur_str != "") {
            result.push_back(cur_str);
        }
        cur_str = "";
    };
    
    // Сам алгоритм.
    for(char c : input_string) {
        if (c == ',') {
            add_part();
        } else {
            cur_str += c;
        }
    }
    
    add_part();
    
    return result;
}
Исключили дублирование, но есть одна проблема: код не работает. Дело в том, что лямбда не может получить доступ к переменным функции — cur_str и res.
Мы можем исправить эту ошибку, добавив всего один символ & в квадратные скобки. Эти скобки не только показывают, что перед нами лямбда, но и применяются для передачи данных внутрь неё:
// Добавили "&"  ↴
auto add_part = [&]{
    // Ошибки нет.
    if (cur_str != "") {
        result.push_back(cur_str);
    }
    cur_str = "";
};
Амперсанд означает, что будет выполняться захват внешних переменных по ссылке, то есть лямбда сможет менять переменные и эти изменения будут видны вызывающему коду.
Посмотрим на код лямбды через «волшебные очки», которые показывают, во что компилятор преобразует код:
struct TempClass {
    // Захваченные переменные стали параметрами конструктора.
    TempClass(std::vector<std::string>& result, std::string& cur_str)
     : result(result), cur_str(cur_str) { }

    void operator()() const {
        if (cur_str != "") {
            result.push_back(cur_str);
            cur_str = "";
        }
    }

private:
    // Захваченные переменные появились как приватные члены.
    std::vector<std::string>& result;
    std::string& cur_str;
};
// Создаём функтор, передавая ему ссылки
// на переменные функции.
auto add_part = TempClass(result, cur_str);
Используя лямбда-функцию, мы исключили дублирование и сделали реализацию более простой для восприятия.
Фабрика действий
Используя захват данных, можно менять не только переменные, но и само действие лямбды. При этом применяют фабрику функторов — функцию, которая возвращает лямбду:
auto CreateSinger(const std::string& voice) {
    auto lambda = [/* захват данных */](){
        std::cout << voice << ", " << voice << ", " << voice 
                  << std::endl;
    };

    return lambda;
}
Посмотрите на эту функцию внимательно. Если вызвать CreateSinger("Мяу"), получим функтор. Если сохранить его в переменную и вызвать, то каждый вызов функтора трижды выведет «Мяу»:
auto meow_singer = CreateSinger("Мяу");
// При вызове функтора не нужно использовать параметр:
meow_singer();
meow_singer();
meow_singer();

auto bark_singer = CreateSinger("Гав");
bark_singer();
Также в переменную bark_singer записали созданную лямбду с тройным выводом «Гав». Вот что получится:
Мяу, Мяу, Мяу
Мяу, Мяу, Мяу
Мяу, Мяу, Мяу
Гав, Гав, Гав
Чтобы код корректно работал, надо подумать, как передать значение внутрь лямбды. Если использовать &, то программа потерпит фиаско: в лямбде сохранится ссылка на параметр функции voice, но эта строка будет уничтожена сразу после вызова CreateSinger, так как переменная является локальной. В таком случае используют захват по значению — вместо & пишется =:
auto CreateSinger(const std::string& voice) {
    // Поставили "=" для захвата по
    // значению    ↴
    auto lambda = [=](){
        std::cout << voice << ", " << voice << ", " << voice 
                  << std::endl;
    };
}
При таком захвате значение используемой переменной (voice) скопируется внутрь лямбды.
Рассмотрим следующую фабрику функторов: 
auto MakeAdder(int n) {
    auto adder = [=](int m){
        return n + m;
    };
    
    return adder;
}
Теперь вы разобрались, как создать локальные функции в виде лямбда-выражений, и познакомились с двумя способами захвата информации — по ссылке и по значению. Подведём итог, когда и какой тип захвата использовать.
По ссылке ([&]):
когда надо предоставить возможность вносить изменения;
при использовании лямбды внутри функции для изменения переменных этой функции.
По значению ([=]):
время жизни переменной короче, чем время жизни лямбды;
при создании фабрики функторов — возврате лямбды из функции.
В этом уроке вы узнали о фабрике функторов и о том, как обернуть лямбду в std::function.
Это пригодится вам в практической части урока. В ней вы улучшите реализацию программы для подсчёта статистики и усовершенствуете программу с кнопками!
Ничего лишнего — предикат
В этом уроке вы будете изучать предикаты. Узнаете, как с их помощью задавать условия поиска. И как использовать предикаты, чтобы сортировать, фильтровать, удалять и подсчитывать элементы в векторе.
Считаем всё на свете
Функции, которые не имеют побочного эффекта, называют чистыми функциями. Они ничего не выводят, не меняют глобальных переменных и аргументов, не читают и не записывают файлы. Иными словами, ничего не меняют во внешнем мире, а занимаются только вычислением. Если вызвать чистую функцию повторно с теми же аргументами, то результат окажется неизменным. Использование таких функций предпочтительно, так как их поведение предсказуемо.
Если чистая функция возвращает bool, то её называют предикатом.
Примером предиката может быть проверка числа на положительное значение:
bool IsPositive(int n) {
    return n > 0;
}
Кроме обычных функций, предикатом может выступать функциональный объект, созданный на основе std::function или с помощью лямбда-функции.
Предикат нужен, чтобы проверять некоторое условие. Как правило, оно соответствует прилагательному или причастию. Строка может быть пустой, слово — содержащим букву «а», а число — отрицательным. Всё это можно выразить предикатом.
Возьмем в качестве примера группу учеников, каждый из которых характеризуется:
средней оценкой за полугодие;
списком оценок;
фамилией и именем;
днём рождения;
полом.
Получится структура, в которой для информации про пол ученика определим enum:
enum class Gender {
    MALE, FEMALE, UNKNOWN
};

struct Student {
    double mean_score; // Средняя оценка.
    Gender gender;
    int birth_year;
    std::string first_name;
    std::string last_name;
    std::vector<int> all_scores;
};
Чтобы сохранить школьный класс, будем использовать вектор с типом Student:
std::vector<Student> students = {...};
Предположим, мы хотим посчитать статистику по классу — к примеру, количество девочек:
int CountGirls(const std::vector<Student>& students) {
    int count = 0;
    for (const auto& student: students) {
        if (student.gender == Gender::FEMALE) {
          ++count;
        }
    }
    
    return count;
}
В другом месте необходимо посчитать количество отличников:
int CountExcellent(const std::vector<Student>& students) {
    int count = 0;
    for (const auto& student: students) {
        if (student.mean_score >= 4.5) {
            ++count;
        }
    }
    
    return count;
}
Если нам нужно посчитать количество учеников, родившихся зимой или получивших хоть одну двойку, то в каждой такой функции мы выполняем один и тот же порядок действий:
Организуем переменную для счётчика.
Создаём цикл прохода по всем элементам вектора, в котором при выполнении условия наращиваем счетчик.
Возвращаем счётчик.
Получаем дублирование практически во всём — кроме условия.
Предикат спешит на помощь
Давайте напишем функцию, которая будет считать всё, что мы захотим. Но как передать условие в функцию? Это можно сделать в виде функционального объекта. Зададим тип функционального объекта, используя std::function:
int CountSome(const std::vector<Student>& students,
               const std::function<bool (Student s)>& what_to_count) {
    int count = 0;
    for (const auto& student: students) {
        if (what_to_count(student)) {
            ++count;
        }
    }
    
    return count;
}
Для каждой характеристики — свой предикат. Вместо большого количества разных функций, которые считали данные по разным заданным характеристикам, теперь нам нужна только одна функция CountSome. В неё передаем предикат, затем можем подсчитать всё:
int girls = CountSome(students, [](Student t){ 
  return t.gender == Gender::FEMALE;
});

int excellent_students = CountSome(students, [](Student t){ 
  return t.mean_score >= 4.5;
});
Функцию CountSome можно сделать более универсальной. Сейчас она принимает на вход вектор с определенным типом. Вы уже знакомы с шаблонами, поэтому можно сделать так, чтобы функция принимала вектор с любыми типами:
template<class T>
int CountSome(const std::vector<T>& students,
              const std::function<bool (const T&)>& what_to_count) {
    int count = 0;
    for (const auto& student: students) {
        if (what_to_count(student)) {
            ++count;
        }
    }
    return count;
}
Использование std::function требует больше ресурсов — при каждом вызове будет обращение к отдалённой памяти. Такие функции не могут встраиваться. Чтобы повысить эффективность, вместо типа std::function<bool (const T&)> можно использовать шаблонный аргумент. Он не так выразителен, но зато более эффективен:
template<class T, class Predicate>
int CountSome(const std::vector<T>& students,
              const Predicate& what_to_count) {
    int count = 0;
    for (const auto& student: students) {
        if (what_to_count(student)) {
            ++count;
        }
    }
    return count;
}
Глядя на сигнатуру, нельзя понять, какие параметры принимает предикат. Зато это хорошо будет знать компилятор: для каждого предиката он будет компилировать функцию заново. А значит, сможет применить все оптимизации, как если бы мы скопировали весь код CountSome, указав вместо абстрактного предиката конкретную функцию.
Алгоритмы и предикаты
Мы написали функцию CountSome. Оказывается, подобная функция уже есть в C++! Это std::count_if из стандартных алгоритмов, для использования которых необходимо подключить библиотеку #include <algorithm>. Отличие std::count_if от нашей функции в том, что она принимает не вектор, а диапазон, заданный двумя итераторами (вы познакомитесь с ними в следующем спринте). Пока что мы будем использовать диапазон, применяя методы begin и end, что соответствует диапазону от начала и до конца контейнера:
int girls = std::count_if(students.begin(), students.end(), [](Student t){ 
    return t.gender == Gender::FEMALE;
});
Если в качестве предиката используется обычная функция, то она должна соответствовать требованиям, применимым к предикатам. То есть принимать в качестве параметра один объект и возвращать тип bool. При работе с функцией в качестве предиката используется лишь ее именование:
// Функция-предикат.
bool IsGirl(Student student) {
    return student.gender == Gender::FEMALE;
}

...
// Использование:
int girls = std::count_if(students.begin(), students.end(), IsGirl);
У алгоритма count_if есть напарник — count, который может посчитать количество элементов контейнера, равных определенному. Например, количество двоек в векторе или букв 'S' в строке. В этом случае в качестве третьего параметра указывается не предикат, а значение, которое алгоритм будет искать в последовательности. В нашей структуре, которая характеризует группу учеников, есть поле с оценками all_scores. Так как этот контейнер не хранит сложных данных, то достаточно использовать count. Посчитаем количество пятёрок:
// Возьмём определенного студента из вектора.
Student student = students[num];

// Прочитаем контейнер с его оценками.
const std::vector<int>& scores = student.all_scores;

// Используем std::count для подсчета пятёрок:
int fives_count = std::count(scores.begin(), scores.end(), 5);
Если нам понадобится узнать, есть ли в оценках двойка, то можем также использовать std::count. Если двоек нет, то результатом алгоритма будет ноль.
Для проверки наличия элемента достаточно проходить контейнер до первого вхождения нужного элемента. std::count будет всегда идти до конца и поэтому неэффективен для такой задачи. Лучше выбрать std::find:
// Используем std::find для проверки наличия двоек:
/*какой-то тип*/ is_exist = std::find(scores.begin(), scores.end(), 2);
Если std::count возвращает тип int, то с std::find ситуация сложнее. Он не просто отвечает, есть ли такой элемент в последовательности (для чего бы подошёл тип bool), а возвращает итератор, указывающий на нужный элемент. Либо scores.end(), если элемент не найден:
auto is_exist = std::find(scores.begin(), scores.end(), 2);
if(is_exist == scores.end()) {
  std::cout << "Двоек нет!" << std::endl;
}
Мы рассмотрели проверку контейнера на наличие элемента. Если понадобится реализовать более сложное условие (например, найти чётное число или яркий цвет в списке цветов), то нужно использовать другой алгоритм с постфиксом _if — std::find_if. Как и std::count_if, ему нужен предикат в качестве третьего параметра.
В предикатах можно использовать любые вычисления, в том числе алгоритмы. Например, проверим, есть ли в классе двоечник:
auto first_bad_student = std::find_if(
    students.begin(), students.end(), [](Student t){ 
        // Проверяем, есть ли в оценках двойка.
        auto pos = std::find(t.scores.begin(), t.scores.end(), 2);
        return t.scores.end() != pos;
    }
);

if (first_bad_student == students.end()) {
    std::cout << "Двоечников нет!" << std::endl;
}
Так же как и std::find, алгоритм вернет итератор на первый элемент, который соответствует условию.
Кроме подсчёта и проверки наличия элементов, предикаты могут использоваться для фильтрации их последовательности, то есть удаления элементов с определёнными характеристиками. Например, так можно удалить пустые строки из вектора:
std::vector<std::string> v_strings = {"Предикат", "", "нужен", ", чтобы", "фильтровать, ", "искать, ", "", "", "проверять", ""};

// Сохраняем предикат проверки строки на пустоту.
auto is_empty = [](const std::string& s){ 
    return s.empty();
};

// Удаляем из вектора все пустые строки.
std::erase_if(v_strings, is_empty);

// Выводим результат.
for (auto str : v_strings) {
    std::cout << str << " ";
}
// Результат: "Предикат нужен, чтобы фильтровать, искать, проверять".
Пустые строки можно удалить проще. Подойдёт erase, который удалит строки, равные "":
std::vector<std::string> v_strings = {"Предикат", "", "нужен", ", чтобы", "фильтровать, ", "искать, ", "", "", "проверять", ""};
std::erase(v_strings, "");
Но erase не подойдет, если нужно, например, удалить строки без буквы «а»:
std::vector<std::string> v_strings = {"Предикат", "", "нужен", ", чтобы", "фильтровать, ", "искать, ", "", "", "проверять", ""};

auto has_no_a = [](const std::string& s){ 
    return s.find("а") == std::string::npos;
};

// Удаляем строки без "а".
std::erase_if(v_strings, has_no_a);

// Результат: "Предикат фильтровать, искать,".
Алгоритм std::erase_if работает только со стандарта C++20, до этого использовался std::remove_if, который переставляет удаляемые элементы в конец и возвращает итератор на первый из них. После его работы нужно вызвать метод erase() для окончательного удаления элементов, которые оказались в «хвосте»:
std::vector<std::string> v_strings = {"Предикат", "", "нужен, чтобы", "фильтровать,", "искать,", "", "", "проверять", ""};

auto is_empty = [](const std::string& s){ 
    return s.empty();
};

// Новый последний элемент:
auto new_end = std::remove_if(v_strings.begin(), v_strings.end(), is_empty);

// Удаляем "хвост" вектора.
v_strings.erase(new_end, v_strings.end());

// Выводим результат.
for(auto str : v_strings) {
    std::cout << str << std::endl;
}
Теперь, когда вы изучили, как использовать лямбда-функции в качестве предикатов для поиска, проверки и фильтрации последовательностей, пришло время применить знания на практике.
Быстрее, выше, сильнее — компаратор
Из этого урока вы узнаете, как можно упорядочить хаос. Речь пойдёт о сортировке информации.
В программировании часто нужно что-то сортировать:
файлы в проводнике по алфавиту,
товары в интернет-магазине по стоимости,
результаты поиска по релевантности.
Ещё сортировку используют для ускорения алгоритмов. К примеру, поиск информации в отсортированном массиве выполнится в разы быстрее, чем в неупорядоченном.
Наводим порядок
Существует множество алгоритмов сортировки, но вам не нужно их реализовывать, так как в C++ уже есть готовая функция — std::sort. Она входит в библиотеку стандартных алгоритмов, которая подключается через #include <algorithms>.
Чтобы отсортировать вектор, нужно вызвать его методы begin() и end() и передать результаты в качестве параметров std::sort. Это будет означать сортировку от начала (англ. begin) до конца (англ. end). Например, так можно отсортировать вектор чисел:
std::vector<int> int_vector{10, 5, -3, -12, 5};
    
// Отсортируем числа:
std::sort(int_vector.begin(), int_vector.end());
// Результат вывода на печать: -12, -3, 5, 5, 10.
Или, например, вектор строк:
std::vector<std::string> string_vector = 
    {"C++", "is", "the", "best", "programming", "language", 
     "in", "the", "World"};
// Отсортируем вектор от начала до конца.
std::sort(string_vector.begin(), string_vector.end());
// После сортировки слова встанут в таком порядке:
// C++ World best in is language programming the the.
Из этого примера вы можете увидеть, что сортировка выполняется по возрастанию: от меньшего элемента к большему. Для строк выполняется лексикографическое сравнение по порядку в таблице ASCII. Не стоит забывать, что заглавные и строчные буквы имеют разное значение в таблице ASCII. Как ни парадоксально, заглавная буква считается меньшим элементом, чем аналогичная строчная. В результате сортировки строки выстроились по алфавиту, но слова с заглавных букв идут в начале.
А если мы хотим отсортировать в другом порядке? От большего к меньшему или по длине строки?
В этом случае нужно ввести другое отношение порядка — условие, при котором один элемент нужно располагать раньше другого при сортировке. Например, для сортировки от меньшего к большему мы использовали отношение порядка «меньше». Меньший элемент следует расположить раньше большего. Кодом это выражается так:
auto less = [](auto lhs, auto rhs) {
    // Вернуть true, если lhs меньше rhs.
    return lhs < rhs;
};
Такой предикат сравнивает два элемента и возвращает bool. Его называют компаратором. Компаратор всегда работает с двумя объектами и в качестве результата возвращает тип bool. Используемый компаратор влияет на то, какой порядок в результате получится.
Компаратор — не любая функция. Он должен обладать свойствами математического порядка, такими как транзитивность: если элемент А меньше элемента В, а элемент В меньше элемента С, то должно выполняться условие, что А меньше С.
Возьмём для примера порядок, который сравнивает только длины строк. Он будет располагать левее более короткую строку. На языке кода это выглядит так:
// Компаратор проверяет, что длина первой строки 
// (lhs) меньше длины второй строки (rhs).
// Сортировка по такому компаратору будет начинать с коротких строк.
[](std::string lhs, std::string rhs) {
    return lhs.size() < rhs.size();
}
Чтобы использовать компаратор при сортировке, его передают в качестве третьего параметра в функцию std::sort. Например, упорядочим числа по убыванию:
std::vector<int> int_vector = {1, 9, 3, 17, 26, 5, 14};
auto comparator = [](int lhs, int rhs){ 
    // Компаратор определит, должно ли lhs идти раньше rhs.
    // Сортировка по убыванию, значит, раньше идёт большее число.
    // Возвращаем true, если lhs больше.
    return lhs > rhs; 
};

// Вывод на печать до сортировки:
// 1, 9, 3, 17, 26, 5, 14

std::sort(int_vector.begin(), int_vector.end(), comparator);

// Вывод на печать:
// 26, 17, 14, 9, 5, 3, 1
В случае несложного компаратора его можно не записывать в переменную, а сразу передать параметром в std::sort:
std::sort(int_vector.begin(), int_vector.end(), 
    [](int lhs, int rhs){ return lhs > rhs; }
);
Можно вовсе не писать этот компаратор, а воспользоваться уже готовым std::greater, который выполняет сортировку по убыванию:
// Так как std::greater – тип, а sort принимает объект, нужно
// поставить пустые скобки, чтобы создать объект типа: std::greater{}.
std::sort(int_vector.begin(), int_vector.end(), std::greater{});
Если компаратор не указывать, то по умолчанию будет использоваться std::less. Он сортирует элементы в порядке возрастания.
Таким образом, если для сортировки достаточно использовать стандартные std::greater и std::less, то можно сэкономить время и не создавать собственный компаратор.
У less и greater есть необязательный шаблонный параметр, позволяющий указывать тип сравниваемых значений. 
Лень — двигатель прогресса, или когда можно не сортировать
Есть вероятность, что элементы в последовательности уже расположены в том порядке, который требуется. Тогда запуск действия по сортировке лишний, он будет снижать эффективность программы. К примеру, следующий вектор уже включает числа, расположенные по убыванию:
std::vector<int> count_down = {10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0};
Как проверить, отсортирована ли последовательность? Для этого используют функцию std::is_sorted, которая возвращает true, если элементы расположены в требуемом порядке. По умолчанию — по возрастанию. std::is_sorted возвращает false при нахождении первого элемента, не соответствующего порядку.
Код проверки вектора с числами:
// Проверяемая последовательность.
std::vector<int> count_down = {10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0};

// Запуск проверки. Компаратор передали третьим параметром.
bool check_is_sorted = std::is_sorted(
                         count_down.begin(), 
                         count_down.end(), std::greater<int>())
От простого к сложному
Пока мы рассматривали простые типы, но чаще всего приходится работать с более сложными объектами, которые представлены, к примеру, структурами. Рассмотрим структуру, которая описывает запланированное домашнее дело или рабочую задачу:
struct Time {
    int hour; // Часы.
    int min;  // Минуты.
    auto operator<=>(Time) const = default; // Операция сравнения.
};

struct Task {
    std::string name;
    Time time_start;
};
У нас есть список из нескольких дел, которые размещены в упорядоченном виде в векторе. Наша задача — составить из них расписание:
Task task1 = {
    .name = "Выполнить задание по С++", 
    .time_start = {.hour = 9, .min = 15}};
Task task2 = {
    .name = "Тренировка в фитнес-клубе", 
    .time_start = {.hour = 20, .min = 40}};
Task task3 = {
    .name = "Встретиться с друзьями", 
    .time_start = {.hour = 18, .min = 10}};
Task task4 = {
    .name = "Записать новый рилс", 
    .time_start = {.hour = 20, .min = 25}};
Task task5 = {
    .name = "Послушать вебинар", 
    .time_start = {.hour = 17, .min = 10}};

std::vector<Task> tasks = {task1, task2, task3, task4, task5};
Чтобы отсортировать список дел по времени, используем компаратор, сравнивающий время:
auto compare_time = [](const Task& lhs, const Task& rhs){
    return lhs.time_start < rhs.time_start;
};
Применим созданный компаратор к списку дел:
sort(tasks.begin(), tasks.end(), compare_time);
Теперь задачи будут отсортированы по времени корректно! Выведем расписание дел на печать:
09:15 Выполнить задание по С++
17:10 Послушать вебинар
18:10 Встретиться с друзьями
20:25 Записать новый рилс
20:40 Тренировка в фитнес-клубе
Кроме лямбда-функций, в std::sort можно использовать и обычные. Преобразуем наш компаратор и сделаем из него именованную функцию:
bool CompareTime(const Task& lhs, const Task& rhs){
    return lhs.time_start < rhs.time_start;
};
Чтобы использовать функцию, надо передать третьим параметром в std::sort только ее наименование:
sort(tasks.begin(), tasks.end(), CompareTime);
Другой способ упорядочить дела — по названию в алфавитном порядке. Передадим в качестве компаратора лямбда-функцию, которая сравнивает поля name двух экземпляров структуры Task:
std::sort(tasks.begin(), tasks.end(), [](const Task& lhs, const Task& rhs){
    return lhs.name < rhs.name;
});
Такая сортировка будет учитывать регистр символов, и строки, начинающиеся с прописных букв, будут идти в начале.
Упорядочить строки без учёта регистра поможет Qt — используем функцию QString::compare:
std::vector<QString> strings = {"Яблоко", "банан", "Апельсин", "арбуз"};
std::sort(strings.begin(), strings.end(), 
    [](const QString& lhs, const QString& rhs){
        // Qt::CaseInsensitive задаёт регистронезависимое сравнение.
        return QString::compare(lhs, rhs, Qt::CaseInsensitive) < 0;
    }
);
// Получим: "Апельсин", "арбуз", "банан", "Яблоко".
// При обычной сортировке получится "Апельсин", "Яблоко", "арбуз", "банан".
Обратите внимание на код — в нём мы сравнили результат вызова с нулём. Это связано с особенностью функции QString::compare, которая может возвращать значение одного из трёх типов:
отрицательное число, если lhs меньше rhs;
ноль, если lhs == rhs;
положительное число, если lhs больше rhs.
Таким образом:
QString::compare(lhs, rhs, …) < 0 означает, что lhs < rhs;
QString::compare(lhs, rhs, …) > 0 означает, что lhs > rhs;
QString::compare(lhs, rhs, …) == 0 означает, что lhs == rhs.
При этом сравнение выполняется нужным способом: с учётом регистра или без учёта регистра, в зависимости от третьего параметра.
Один столбец хорошо, а два лучше
Часто мы сортируем экземпляры структуры или класса по некоторому параметру (например, задачи по времени их начала). В этом случае не ясно, как быть, если время начала у двух задач совпадает. Мы можем выбрать другой параметр и сортировать по нему при совпадении первого. Такая сортировка вам уже знакома, она называется лексикографической. Сделаем такой компаратор:
bool CompareTimeAndName(const Task& lhs, const Task& rhs) {
    // Если время первой задачи меньше, то она идёт раньше (true).
    if (lhs.time_start < rhs.time_start) {
        return true;
    }
    // Если время первой задачи больше, то она идёт позже (false).
    if (lhs.time_start > rhs.time_start) {
        return false;
    }
    // Остался случай, когда время совпадает, — сравниваем имя.
    return lhs.name < rhs.name;
};
Код получился довольно сложным, но его можно упростить. Лексикографическое упорядочивание уже реализовано для std::tuple, воспользуемся этим:
bool CompareTimeAndName(const Task& lhs, const Task& rhs) {
    // Сравниваем два std::tuple.
    return std::tuple(lhs.time_start, lhs.name) < 
           std::tuple(rhs.time_start, rhs.name);
};
Создание std::tuple вызывает копирование. Эффективнее использовать std::tie:
bool CompareTimeAndName(const Task& lhs, const Task& rhs) {
    // tie создаст tuple без копирования.
    return std::tie(lhs.time_start, lhs.name) < 
           std::tie(rhs.time_start, rhs.name);
};
Основной недостаток std::tie — он не может работать с временными значениями:
Point point;

// Ошибка! Временное значение в tie.
auto tie = std::tie(point.x + point.y, point.x - point.y);

// Ок.
int sum = point.x + point.y;
int diff = point.x - point.y;
auto tie = std::tie(sum, diff);


Если сравнение — неотъемлемая часть структуры, можно для удобства создать метод для построения std::tuple:
struct Task {
    std::string name;
    Time time_start;
    
    auto AsTuple() const {
        return std::tie{time_start, name};
    }
};

bool CompareTimeAndName(const Task& lhs, const Task& rhs) {
    // tie создаст tuple без копирования.
    return lhs.AsTuple() < rhs.AsTuple();
};
Скобки, скобки и ещё раз скобки — колбэк
От звания мастера лямбда-функций вас отделяет этот урок.
Здесь вы узнаете о функциях обратного вызова и поймете, как они связаны с лямбда-функциями. Ещё вам предстоит познакомиться с шаблонными лямбдами, которые будут полезны в работе: с ними удобнее программировать и они помогут избежать дублирования кода.
Перейдемы к теории.
Программируем в функциональном стиле
Из предыдущих уроков вы узнали, что функциональные объекты используются как:
Компараторы — для сортировки последовательности в соответствии с заданными условиями.
Предикаты — чтобы искать элемент по заданным параметрам.
Ещё один вариант использования функциональных объектов — функции обратного вызова (англ. callback). Их особенность в том, что они не вызываются прямо в коде, а передаются в другую вызываемую функцию, где она будет вызвана в случае наступления какого-либо ожидаемого события.
В качестве колбэк-функций могут использовать любые функциональные объекты, но проще всего в этом случае применять лямбда-функции.
Рассмотрим код, который выполняет действие для каждого чётного числа в контейнере:
int main() {
    std::vector<int> numbers = {1, 2, 3, 4, 5};
    
    auto even_action = [](int n){
        std::cout << "Обнаружено чётное число: " << n << std::endl;
    };
    
    for(auto num : numbers) {
        if (num % 2 == 0) {
            even_action(num);
        }
    }
}
В коде, который взяли за пример, есть два этапа: проверка условия и выполнение действия. Они простые, поэтому соединены в одной функции.
Попробуем применить к этому коду колбэк-функцию. Для этого оставим в main только код действия, а цикл, находящий чётные числа, вынесем из него:
// Функция вызывает колбэк для чётных чисел.
template <typename Callback>
void DoIfEven(const std::vector<int>& numbers, Callback callback) {
    for(auto num : numbers) {
        if (num % 2 == 0) {
            callback(num);
        }
    }
}

int main() {
    std::vector<int> numbers = {1, 2, 3, 4, 5};

    // even_action — это колбэк-функция.
    auto even_action = [](int n){
        std::cout << "Обнаружено чётное число: " << n << std::endl;
    };

    // DoIfEven вызовет наш колбэк для всех чётных чисел.
    DoIfEven(numbers, even_action);
}


Таким образом мы превратили even_action в функцию обратного вызова. Она передаётся в DoIfEven в качестве аргумента и будет вызвана при наступлении события — обнаружении четного числа.
Функции, которые могут принять другие функции в качестве аргументов или возвращать их как результат работы, называют функциями высшего порядка.
Функции обратного вызова позволяют снизить связи между частями программы и улучшить архитектуру. Благодаря этому код, определяющий момент события, отделяется от кода, реагирующего на это событие. Так вносить изменение в работу программы будет проще.
Классы и колбэк
Функции обратного вызова можно использовать не только в качестве аргументов функций, но и при организации взаимодействия классов. Рассмотрим как пример проект программы, задача которой — отслеживать состояние компьютера: температуру процессора и количество свободной памяти на диске.
В случае превышения лимита температуры или при количестве памяти меньше минимального надо зафиксировать событие в журнале событий. Разделим функционал по трём классам — сканер Scanner, логгер Logger и основной класс StateComputer.

Диаграмма классов
Задача сканера — следить за двумя характеристиками. У него есть два публичных метода, которые позволяют установить функции обратного вызова. Он будет вызывать их при событии превышения критического уровня температуры и недостаточном количестве памяти:
SetCallbackTemperature(...) — сохраняет функцию в поле класса callback_temperature_;
SetCallbackMemory(...) — записывает в поле callback_memory_.
В коде это выглядит так:
// Сохраним в поля класса выполняемые функции.
void Scanner::SetCallbackTemperature(TemperatureCallback callback) {
    callback_temperature_ = callback;
}

void Scanner::SetCallbackMemory(MemoryCallback callback) {
    callback_memory_ = callback;
}
Кроме того, в сканере будут два приватных метода, которые вызываются при изменении температуры и количества памяти:
Scanner::UpdateTemperature(int new_temp) {
    const int max_temperature = 100;
    
    int old_temp = temperature_;
    temperature_ = new_temp;
    
    if (temperature_ >= max_temperature) {
        // Вызываем функцию обратного вызова, передавая ей параметры:
        callback_temperature_(old_temp, new_temp);
    }
}

Scanner::UpdateMemory(double new_memory_consumption) {
    const double min_memory_percent = 5;
    memory_consumption_ = new_memory_consumption;
    
    if (100 - memory_consumption_ <= min_memory_percent) {
        // Вызываем функцию обратного вызова, передавая ей параметр:
        callback_memory_(memory_consumption_);
    }
}
Сканеру не надо знать, что будет сделано в случае возникновения события. Так как за поведение отвечает класс StateComputer, который должен иметь доступ к двум классам:
Scanner — для установки функций обратного вызова.
Logger — для записи информации о произошедшем событии в журнале.
Вызов метода write(), который является методом класса Logger, будет внутри лямбда-функции. Вот пример функции обратного вызова по отслеживанию температуры:
auto callback_temp = [&](double prev_temp, double new_temp){
    logger.write("Critical temperature: " + std::to_string(new_temp));
}; 

scanner.SetCallbackTemperature(callback_temp);
Таким образом, мы рассмотрели взаимодействие классов — детектора Scanner, который сканировал состояние, и основного класса StateComputer, который использовал детектор. В результате получилось связать работу нескольких независимых классов. Каждый из них отвечает за выполнение определённых задач. 
Скобок больше, скобок меньше!
Вы уже знаете, что тип результата лямбда-функций определяется автоматически, то есть нет необходимости указывать его при создании. Кроме этого, auto может быть использован вместо типа параметра. Такой вариант называют универсальной лямбда-функцией. Например, сложение двух объектов:
auto sum = [](auto a, auto b){ return a + b; };
Чтобы сложить два числа, напишем:
std::cout << sum(1, 2) << std::endl;
Всё отлично сработало и вывело ожидаемый результат — 3. Теперь передадим две строки:
std::cout << sum("Привет, ", "универсальная лямбда!") << std::endl;
Получим ошибку error: invalid operands of types 'const char*' and 'const char*' to binary 'operator+'. Так как тип auto, то компилятор по умолчанию привёл текстовую строку к типу const char*, у которого не определена операция сложения.
Скопировать код
CPP
// Подключение literals для использования s-литерала.
using namespace std::literals;
auto sum = [](auto a, auto b){ return a + b;};

// Использование литералов для приведения к std::string.
sum("Привет, "s, "универсальная лямбда!"s);

// Использование конструктора std::string.
sum(std::string{"Привет, "}, std::string{"универсальная лямбда!"});

// Создание переменных с типом std::string.
std::string hi{"Привет, "};
std::string lambda{"универсальная лямбда!"};
sum(hi, lambda);
Такое поведение похоже на шаблонные функции, но в коде нет угловых скобок. На самом деле они спрятаны в функторе, который генерирует компилятор для лямбда-функции, если встречает слово auto в параметре:
template<typename T, typename U>
auto operator()(T a, U b) const {
    return a + b;
}
Для каждой auto-переменной свой шаблонный тип. То есть можно передать два разных типа для сложения.
Если универсальных лямбда-функций недостаточно, можно использовать шаблонную лямбду. Для этого нужно добавить угловые скобки после квадратных. Так выглядит пустая шаблонная лямбда-функция:
auto template_lambda = []<>(){};
Угловые скобки позволяют явно указать, с какими шаблонными параметрами будет работать функция. Например, так можно задать одинаковый тип для двух аргументов:
auto template_lambda = []<typename T>(T a, T b){ return a + b;};
auto result = template_lambda(1, 2.1);
При таком вызове уже на этапе компиляции получим ошибку no match for call to '(main()::) (int, double)', которая говорит, что нет функции для сложения двух разных типов.
Но количество скобок можно сократить:
можно убирать угловые (<>) или круглые скобки (()), если они пустые;
нельзя убирать квадратные ([]) и фигурные скобки ({}).
Вот пример лямбда-функции без лишних скобок:
auto hello_lambda = []{
    std::cout << "Hello everyone! I'm mini lambda!" << std::endl;
};
hello_lambda();

