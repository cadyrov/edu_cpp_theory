# Ответы и ссылки на теорию

## Правильные ответы:

1. **B** - Объект, который можно вызвать с помощью оператора ()
2. **B** - `#include <functional>`
3. **A** - Функция, возвращающая int и принимающая OrderId
4. **B** - `auto lambda = [](int x) { return x * 2; };`
5. **C** - Захват переменных
6. **B** - Захват по ссылке
7. **B** - Выведет 20
8. **B** - `=`
9. **B** - Чистая функция, возвращающая bool
10. **B** - `std::count_if`
11. **A** - 2
12. **B** - `std::sort`
13. **B** - Предикат, сравнивающий два элемента и возвращающий bool
14. **B** - `std::less`
15. **B** - 5 4 3 1 1
16. **B** - `std::is_sorted`
17. **B** - Функция, передаваемая в другую функцию для вызова при определенном событии
18. **A** - Вариант A
19. **D** - Все перечисленное
20. **B** - `auto lambda = [](auto a, auto b) { return a + b; };`
21. **B** - Ошибка компиляции
22. **B** - `std::erase_if`
23. **B** - Функция, которая возвращает лямбда-функцию
24. **A** - Вариант A
25. **D** - Варианты A и B
26. **A** - 1 2 2
27. **B** - `std::tie(a, b)`
28. **B** - Сортировка по нескольким критериям с приоритетами
29. **A** - `auto lambda = []<typename T>(T a, T b) { return a + b; };`
30. **C** - apple cherry banana

## Ссылки на строки в теории:

**Вопрос 1** - строки 46-50: "Такое сохраненное действие называется функциональным объектом"

**Вопрос 2** - строки 102-103: "для работы с std::function надо подключить #include <functional>"

**Вопрос 3** - строки 59-61: "std::function<int (OrderId)>" - функция, принимающая OrderId и возвращающая int

**Вопрос 4** - строки 188-192: синтаксис лямбда-функции с квадратными скобками []

**Вопрос 5** - строки 202-206: "Пустые квадратные [] — основной признак лямбда-функции"

**Вопрос 6** - строки 294-296: "Амперсанд означает, что будет выполняться захват внешних переменных по ссылке"

**Вопрос 7** - строки 294-296: захват по ссылке позволяет изменять переменные

**Вопрос 8** - строки 361-363: "При таком захвате значение используемой переменной (voice) скопируется внутрь лямбды"

**Вопрос 9** - строки 414-416: "Если чистая функция возвращает bool, то её называют предикатом"

**Вопрос 10** - строки 553-556: "std::count_if из стандартных алгоритмов"

**Вопрос 11** - строки 553-556: count_if с предикатом для четных чисел

**Вопрос 12** - строки 725-727: "в C++ уже есть готовая функция — std::sort"

**Вопрос 13** - строки 756-758: "Такой предикат сравнивает два элемента и возвращает bool. Его называют компаратором"

**Вопрос 14** - строки 830-832: "по умолчанию будет использоваться std::less"

**Вопрос 15** - строки 815-822: std::greater сортирует по убыванию

**Вопрос 16** - строки 847-850: "функцию std::is_sorted, которая возвращает true, если элементы расположены в требуемом порядке"

**Вопрос 17** - строки 958-961: "функции обратного вызова (англ. callback). Их особенность в том, что они не вызываются прямо в коде, а передаются в другую вызываемую функцию"

**Вопрос 18** - строки 958-961: определение callback-функции

**Вопрос 19** - строки 654-657: "auto может быть использован вместо типа параметра. Такой вариант называют универсальной лямбда-функцией"

**Вопрос 20** - строки 654-657: универсальная лямбда с auto параметрами

**Вопрос 21** - строки 664-666: "Получим ошибку error: invalid operands of types 'const char*' and 'const char*' to binary 'operator+'"

**Вопрос 22** - строки 634-637: "Алгоритм std::erase_if работает только со стандарта C++20"

**Вопрос 23** - строки 383-386: "При использовании лямбды внутри функции для изменения переменных этой функции. Используя захват данных, можно менять не только переменные, но и само действие лямбды. При этом применяют фабрику функторов — функцию, которая возвращает лямбду"

**Вопрос 24** - строки 383-386: пример фабрики функторов

**Вопрос 25** - строки 401-407: "По ссылке ([&]): когда надо предоставить возможность вносить изменения; при использовании лямбды внутри функции для изменения переменных этой функции"

**Вопрос 26** - строки 294-296: захват по ссылке изменяет переменную

**Вопрос 27** - строки 922-924: "Эффективнее использовать std::tie"

**Вопрос 28** - строки 904-906: "Такая сортировка вам уже знакома, она называется лексикографической"

**Вопрос 29** - строки 708-710: "можно использовать шаблонную лямбду. Для этого нужно добавить угловые скобки после квадратных"

**Вопрос 30** - строки 770-774: сортировка по длине строки 