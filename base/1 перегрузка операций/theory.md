## Операция
### Операция — это значок, используемый в коде в выражениях, такой как +, *, =. 
При выполнении программы операция совершает некоторое действие над операндами (например, сложение) и возвращает результат. Из операций и их операндов конструируются выражения.
### Большинство операций бинарные, то есть имеют два операнда. 
Например, + в выражении 2 + 3. Но бывают и унарные, например минус в выражении -n или ++ в выражении ++i.
### Тернарная операция в С++20 одна — это условный оператор a ? b : c. 
Он подставляет значение второго операнда, если первый операнд истинный, иначе подставляет третий операнд.
### Помимо привычных операций, в C++ есть некоторые необычные. Например, [] и (). 
Квадратные скобки можно увидеть при обращении к элементу вектора: v[15]. В квадратных скобках раньше можно было записывать только одно выражение, но это требование отменено в свежем стандарте — C++23.
### Круглые скобки встречаются при вызове функции: SendBirthdayGreetings(name, surname, address). 
И сама функция, и все аргументы — это операнды, их может быть любое количество.
### Ещё среди всех операций особенно выделяются три: ., ::, ->. 
Отличаются они тем, что их операнды — не выражения. Например, у операции :: левый операнд — это класс или пространство имён, а правый — имя.
### Вот как выглядит таблица операций стандарта С++ 20:
#### Арифметические операции
- `+a` — унарный плюс
- `-a` — унарный минус
- `a + b` — сложение
- `a - b` — вычитание
- `a * b` — умножение
- `a / b` — деление
- `a % b` — остаток от деления
#### Побитовые операции
- `~a` — побитовое НЕ
- `a & b` — побитовое И
- `a | b` — побитовое ИЛИ
- `a ^ b` — побитовое исключающее ИЛИ
- `a << b` — сдвиг влево
- `a >> b` — сдвиг вправо

#### Операции инкремента и декремента
- `++a` — префиксный инкремент
- `--a` — префиксный декремент
- `a++` — постфиксный инкремент
- `a--` — постфиксный декремент

#### Операции сравнения
- `a == b` — равно
- `a != b` — не равно
- `a < b` — меньше
- `a > b` — больше
- `a <= b` — меньше или равно
- `a >= b` — больше или равно
- `a <=> b` — трёхстороннее сравнение (spaceship operator, C++20)

#### Логические операции
- `!a` — логическое НЕ
- `a && b` — логическое И
- `a || b` — логическое ИЛИ

#### Операции присваивания
- `a = b` — присваивание
- `a += b` — сложение с присваиванием
- `a -= b` — вычитание с присваиванием
- `a *= b` — умножение с присваиванием
- `a /= b` — деление с присваиванием
- `a %= b` — остаток с присваиванием
- `a &= b` — побитовое И с присваиванием
- `a |= b` — побитовое ИЛИ с присваиванием
- `a ^= b` — побитовое исключающее ИЛИ с присваиванием
- `a <<= b` — сдвиг влево с присваиванием
- `a >>= b` — сдвиг вправо с присваиванием

#### Операции доступа
- `a[...]` — индексирование
- `*a` — разыменование
- `&a` — взятие адреса
- `a->b` — доступ к члену через указатель
- `a.b` — доступ к члену объекта
- `a->*b` — доступ к члену через указатель на член
- `a.*b` — доступ к члену через указатель на член объекта

#### Другие операции
- `a(...)` — вызов функции (круглые скобки)
- `a, b` — оператор запятая
- `a ? b : c` — тернарный условный оператор

### Выполнять операции может не только программа, но и компилятор. 
Если все операнды можно однозначно установить на этапе компиляции, то компилятор вычислит выражение и подставит вместо него результат.
### Операции  — то же самое, что и функции.
Рассмотрим пример. Обозначим:

    + как Sum,
    * как Mul,
    / как Div,
    - как Sub,
    = как Set.
Тогда простое выражение x = a + b * (c - 1) можно переписать так:
```cpp
auto s = Sub(c, 1);
auto l = Mul(b, s);
auto k = Add(a, l);
Set(x, k);
```
Именно так компилятор поступает с выражениями. Просто вместо Sub, Mul, Add он вставляет инструкции процессора:

## PAIR
### В С++ операции могут применяться не только к примитивным типам, но и к объектам классов, в том числе пользовательских. 
Рассмотрим на примере шаблона std::pair.
Шаблон pair позволяет хранить два значения в одном объекте. Он похож на структуру с двумя полями, но позволяет не писать её объявление. Посмотрите на пример со структурой:
```cpp    
#include <iostream>
// Создадим структуру с двумя полями: first и second.
struct MyPair {
    std::string first;
    int second;
};

int main() {
    MyPair person1{"Ivan"s, 22};
        
    std::cout << person1.first << std::endl;
    std::cout << person1.second << std::endl;
}
```
#### А вот так можно переписать, используя pair:
```cpp     
// Подключим utility, чтобы использовать pair.
#include <utility>
#include <iostream>
int main() {
    std::pair<std::string, int> person2{"Alexey"s, 20};
    std::cout << person2.first << std::endl;
    std::cout << person2.second << std::endl;
}
```
### Основное отличие от структуры в том, что поля pair всегда называются first (англ. «первый») и second (англ. «второй»), а у структуры полям можно дать любые имена.
Контейнер pair — это простой контейнер, определённый в заголовке <utility> и состоящий из двух элементов: примитивных значений или объектов.
    
Однако использовать pair можно не только для хранения пары значений. Один из интересных сценариев использования — возможность возвращать из функции сразу два значения. Посмотрите на пример:
```cpp     
#include <iostream>
#include <utility>
using namespace std::literals;
// Функция находит первую гласную букву.
// Возвращает букву и её позицию в строке.
std::pair<char, size_t> FindVowel(std::string str) {
    size_t pos = str.find_first_of("aeoiuy"s);
    if (pos == str.npos) {
        // Ничего не нашли: возвращаем пару с 
        // нулевым символом.
        return {'\0', pos};
    }
        
    // Нашли гласную: возвращаем саму гласную и её позицию
    // в виде пары.
    return {str[pos], pos};
}

int main() {
    auto [first, second] = FindVowel("Here the first vowel is 'e'!"s);

    // Выведем элементы пары.
    std::cout << first << " "s
        << second << std::endl;
}
```
### Код, представленный выше, можно упростить при помощи автоматического выведения типов. При этом даже не нужно указывать параметры этого темплейта.
```cpp 
    #include <algorithm>
    #include <iostream>
    #include <utility>

    using namespace std::literals;

    // Определим пару.
    auto GetCount(char lookup_ch, std::string str) {
        return std::pair{lookup_ch, std::count(str.begin(), str.end(), lookup_ch)};
    }

    int main() {
        auto [first, second] = GetCount('c', "Here exactly 3 chars 'c'!"s);

        // Выведем элементы пары.
        std::cout << first << " "s
            << second << std::endl;
    }
```
### При помощи вложенности можно передать из функции и три параметра. Но развернуть их в отдельные переменные будет уже не так просто.
```cpp     
    #include <iostream>
    #include <utility>

    using namespace std::literals;

    std::pair<int, std::pair<char, int>> ReadBinOp(std::istream& stream) {
        int left_op;
        char op;
        int right_op;
        stream >> left_op;
        stream >> op;
        stream >> right_op;
        
        // Возвращаем пару из числа и пары.
        return std::pair{left_op, std::pair{op, right_op}};
    }

    int main() {
        auto [first, secondPair] = ReadBinOp(std::cin);
        auto [second, third] = secondPair;

        // Выведем элементы пары.
        std::cout << "first: "s << first << " "s;
        std::cout << "op: "s << second << " "s;
        std::cout << "second: "s << third << std::endl;
    }
    using IntPair = std::pair<int, int>;

    // Складывает покомпонентно две пары.
    IntPair Add(const IntPair& vec1, const IntPair& vec2) {
        return IntPair{vec1.first + vec2.first, vec1.second + vec2.second};
    }

    // Вычитает покомпонентно две пары.
    IntPair Sub(const IntPair& vec1, const IntPair& vec2) {
        return IntPair{vec1.first - vec2.first, vec1.second - vec2.second};
    }
```
### Лексикографическое сравнение и пары
Для пар определены операции сравнения. Например, pair("ann"s, 15) < pair("bob"s, 42). 
Сравнение ориентируется на первые элементы пары. Так, например, pair("ann"s, 100000) < pair("bob"s, 1), несмотря на то что 100000 > 1, а pair("bob"s, 1) > pair("ann"s, 100000). 
Вторые элементы принимаются во внимание, только если первые элементы равны: pair("ann"s, 100000) > pair("ann"s, 1), pair("ann"s, 15) < pair("ann"s, 10000).

### Поскольку для пар есть операции сравнения, есть смысл говорить о сортировке вектора пар. Например, так можно проверить отсортирован ли вектор:
```cpp 
    #include <iostream>
    #include <utility>
    #include <vector>

    // Функция принимает вектор пар по константной ссылке.
    bool IsSorted(const std::vector<std::pair<int,int>>& pairs) {
        for (auto i{1}; i < pairs.size(); i++) {
            if (pairs[i - 1] > pairs[i]) {
                return false;
            }
        }
        return true;
    }
```
### Пары могут содержать любые типы — не только примитивные. В предыдущем примере был вектор пар, но применяются также пары векторов:    
```cpp 
// Функция разделит числа на чётные и нечётные и вернёт два вектора 
    // в виде пары.
    pair<vector<int>, vector<int>> SplitIntoEvenAndOdd(vector<int> numbers) {
        vector<int> even, odd;
        for (int i : numbers) {
            if (i % 2 == 0) {
                even.push_back(i);
            } else {
                odd.push_back(i);
            }
        }
        return {even, odd};
    }
```

## Перегрузка операций
### Операции можно комбинировать, создавая выражения вида: Set(x, Add(a, Mul(b, Sub(c, 1)))).
Если вы работаете с числами, которые являются базовыми типами данных в языке C++, то для упрощения этой записи можно использовать арифметические знаки. Например, x = a + b * (c - 1). Такие выражения гораздо проще читать!
В С++ можно использовать такую же запись для пользовательских классов. Для этого нужно переопределить операции +, *, -. 
```cpp 
        int x;
        int y;

        // Переопределяем операции +, * и -.
        Vector2I operator+(const Vector2I &other) const {
            return {x + other.x, y + other.y};
        }

        Vector2I operator*(const Vector2I &other) const {
            return {x * other.x, y * other.y};
        }

        Vector2I operator-(const int value) const { 
            return {x - value, y - value};
        }
    };
    int main() {
        using namespace std;
        Vector2I a{1, 4};
        Vector2I b{2, 2};
        Vector2I c{3, 6};
        // Используем переопределённые операции.
        auto x = a + b * (c - 1);
    }
```   
### Так, операции можно применять к объектам ваших классов. 
При этом смысл выражения остаётся тем же и его поведение будет похоже на вызов метода класса.
Если вы посмотрите на программу, сгенерированную компилятором, то увидите: вместо знака - используется вызов c.operator-(const int value).    
Этот способ называется перегрузкой операторов.
Таким образом, операция — просто синтаксический сахар для вызова функции. Фактически, это метод, название которого состоит из слова operator и символа операции.
### Рассмотрим пример с перегруженной операцией +. 
Когда вы пишете x + y, происходит вызов x.operator+(y), если в классе, к которому относится x, есть метод operator+. При этом x и y могут иметь даже разные типы. Первым операндом такой операции всегда является объект класса, а второй операнд — аргумент, принимаемый методом.
### Все операции могут быть перегружены, за исключением четырёх:
- доступа к элементу области видимости (::),
- доступа к полю класса (.),
- тернарной (?:),
- доступа к полю класса через указатель (.*).
### Не рекомендуется перегружать операторы ,, &&, ||. 
Они работают по особым правилам, и их перегрузка может привести к проблемам.
### Перегрузка операции через свободные функции
```cpp 
    Перегрузка операции с использованием метода класса требует использования экземпляра класса в качестве первого аргумента:
    // Экземпляр класса.
    Vector2I c{3, 6};
    // Запись через использование операции.
    с - 1;
    // Запись через явный вызов метода.
    c.operator-(1);
    Иногда мы хотим использовать оператор для другого типа с использованием нашего класса в качестве второго операнда:
    // Экземпляр класса.
    Vector2I c{3, 6};
    // Запись через использование оператора.
    1 - с;
    // Запись через явный вызов функции.
    operator-(1, с);
```
### Свободная функция — это функция, находящаяся вне какого-либо класса.
Свободные функции удобнее использовать для бинарных операций, поскольку они могут быть симметричными. Это значит, что если операция x @ y работает (здесь @ обозначает любую операцию), то операция y @ x также должна работать для всех соответствующих типов.
```cpp 
    #include <iostream>
    using namespace std::literals;

    using Vector2I = std::pair<int, int>;

    std::string operator+(const std::string &str, const Vector2I &vec) {
        return {str + "{"s + std::to_string(vec.first) + ", "s +
                std::to_string(vec.second) + "}"s};
    }

    std::string operator+(const Vector2I &vec, const std::string &str) {
        return {"{"s + std::to_string(vec.first) + ", "s +
                std::to_string(vec.second) + "}"s + str};
    }

    int main() {
        using namespace std;

        string a{"String value of Vector2I: "s};
        auto x_left = a + Vector2I{1, 1};
        cout << x_left << endl;

        string b{" - String value of Vector2I"s};
        auto x_right = Vector2I{1, 1} + b;
        cout << x_right << endl;
    }
```
Этот пример также показывает, что свободные функции позволяют улучшить класс, добавив бинарные операции, не внося новые функции-члены.
Если бы потребовалось использовать функцию-член для перегрузки операции сложения string и Vector2I, пришлось бы добавлять метод в класс std::string, что сделать невозможно.
### Дружественные функции
У свободной функции есть особенность — она не имеет доступа к приватным членам класса.
```cpp 
    #include <iostream>
    using namespace std::literals;
    class Vector2I {
    public:
        Vector2I(int x, int y) : x_{x}, y_{y} {};
    private:
        int x_;
        int y_;
    };

    std::string operator+(const std::string &str, const Vector2I &value) {
        // Ошибка: нет доступа к приватным членам x_ и y_ класса Vector2I.
        return {str + "{"s + std::to_string(value.x_) + ", "s +
                std::to_string(value.y_) + "}"s};
    }

    std::string operator+(const Vector2I &value, const std::string &str) {
        // Ошибка: нет доступа к приватным членам x_ и y_ класса Vector2I.
        return {"{"s + std::to_string(value.x_) + ", "s + std::to_string(value.y_) +
                "}"s + str};
    }

    int main() {
        std::string a{"String value of Vector2I: "s};
        auto x_left = a + Vector2I{1, 1};
        std::cout << x_left << std::endl;
    
        std::string b{" - String value of Vector2I"s};
        auto x_right = Vector2I{1, 1} + b;
        std::cout << x_right << std::endl;
    }
```
Этот код не скомпилируется, поскольку value.x_ и value.y_ являются приватными полями класса Vector2I.
### Для решения этой проблемы в языке предусмотрено ключевое слово friend. 
Оно позволяет сообщить, что некоторая функция имеет доступ к приватным членам класса. Функция декларируется через friend внутри класса, но считается не членом класса, а свободной функцией. friend часто используют для перегрузки операций:
```cpp 
    #include <iostream>
    using namespace std::literals;
    class Vector2I {
        int x_;
        int y_;

        // Хотя мы объявляем operator внутри класса, из-за 
        // friend это свободная функция, а не метод.
        friend std::string operator+(const std::string &str, const Vector2I &value);
        friend std::string operator+(const Vector2I &value, const std::string &str);

    public:
        Vector2I(int x, int y) : x_{x}, y_{y} {};
    };

    std::string operator+(const std::string &str, const Vector2I &value) {
        // Эта функция — друг класса Vector2I, она 
        // может обращаться к приватным членам.
        return {str + "{"s + std::to_string(value.x_) + ", "s +
                std::to_string(value.y_) + "}"s};
    }

    std::string operator+(const Vector2I &value, const std::string &str) {
        // Эта функция также дружит с Vector2I.
        return {"{"s + std::to_string(value.x_) + ", "s + std::to_string(value.y_) +
                "}"s + str};
    }

    int main() {
        std::string a{"Строковое значение вектора: "s};
        auto x_left = a + Vector2I{1, 1};
        std::cout << x_left << std::endl;
    
        std::string b{" - строковое значение вектора."s};
        auto x_right = Vector2I{1, 1} + b;
        std::cout << x_right << std::endl;
    }
```
Через friend можно объявлять не только операции и функции, но и другие классы — они будут дружественными классами, изнутри которых можно получить доступ к приватным данным и методам другого класса.
### Перегрузка операций для перечислений
Операции можно перегружать и для перечислений. В этом случае используются перегрузки через свободные функции, так как у перечислений просто не может быть функций-членов.
    
Например, можно перегрузить операции | и &. Это позволит создать битовые поля — набор флагов, которые включаются и выключаются независимо. 
В этом случае:
- | используется для установки флага;
- & используется для проверки наличия флага.
```cpp
    Значения enum-типа нужно задать явно как степени двойки (1, 2, 4, 8, …).
    enum class FontFlags {
        EMPTY =     0b00000000, // Обычный.
        BOLD =      0b00000010, // Жирный.
        ITALIC =    0b00000100, // Курсивный.
        NARROW =    0b00001000, // Наклонный.
        SANS =      0b00010000, // Рубленый.
        MONOSPACE = 0b00100000  // Моноширинный.
    };

    FontFlags operator|(FontFlags l, FontFlags r) {
        // Используем операцию | для чисел int.
        return FontFlags{static_cast<int>(l) | static_cast<int>(r)};
    }

    FontFlags operator&(FontFlags l, FontFlags r) {
        // Используем операцию & для чисел int.
        return FontFlags{static_cast<int>(l) & static_cast<int>(r)};
    }

    int main() {
        // Жирный моноширинный шрифт.
        FontFlags my_font = FontFlags::BOLD | FontFlags::MONOSPACE;
    
        // ...
    
        if ((my_font & FontFlags::MONOSPACE) != FontFlags::EMPTY) {
            std::cout << "Моноширинный"s << std::endl;
        }
    }
```
В этом примере операции предоставляют выразительное средство для оперирования множеством флагов. 
## Расставляем приоритеты
Перед вами простое арифметическое выражение: a - b + c - d, при вычислении которого все действия выполняются слева направо. Но если заменить одну из операций на другую — a - b * c - d, — порядок вычисления изменится. Сначала выполняется умножение, и только потом вычитание.
    
Так происходит, потому что операции имеют разный приоритет (англ. precedence). Это понятие уже знакомо вам из первых уроков, посвящённых арифметическим операциям. Оно обозначает свойство, указывающее, какая из операций должна выполняться раньше, если они идут подряд и нет явного указания порядка в виде скобок.
    
Приоритет — важное свойство, поскольку от порядка выполнения операций нередко зависит конечный результат.
### Чтобы запомнить приоритет основных операций, можно использовать мнемоническое правило PUMA: 
- P = постфиксные и префиксные,
- U = унарные,
- M = мультипликативные,
- A = аддитивные.

### Приоритеты привязаны к знакам операций и не зависят от типов данных, с которыми работают. Даже у перегруженной операции приоритет остаётся тем же.
```cpp
    // В следующем примере сначала выполняется деление, а потом сложение.
    int value_int = 20;
    auto res = 3 + value_int / 10;

    // Это правило продолжает действовать для перегрузок.
    using Vector2I = std::pair<int, int>;

    Vector2I operator/(const Vector2I &vec, int val) {
        return {vec.first / val, vec.second / val};
    }

    Vector2I operator+(const Vector2I &vec, int val) {
        return {vec.first + val, vec.second + val};
    }
    ...
    // Деление по-прежнему выполняется первым.
    Vector2I value_vec {20, 70};
    auto res = 3 + value_vec / 10;  // {5, 10}
```
### Рассмотрим пример с проверкой корректности ввода.
```cpp
    int x;
    if (!(cin >> x)) {
        // Обработка ошибки.
    }
```
Здесь выражение cin >> x необходимо заключить в дополнительные скобки. В противном случае компилятор распознает его как (!cin)>>x, так как приоритет у отрицания выше, чем у операции ввода.
Аналогичная проблема может быть и с выводом. Вы уже знаете, что при использовании выражения в cout оно должно быть в скобках.
```cpp    
    int value = 1;
    cout << value += 3; // Ошибка.
    cout << (value += 3); // Ок.
```    
С точки зрения компилятора первая запись распознаётся как (cout << value) += 3, что приводит к ошибке.
Верно. Хотя порой программа не завершается ошибкой, а просто получает неверный ответ.
```cpp    
    bool a = true;
    int b = 10;
    int c = 20;

    std::cout << a ? b : c ; // Результат: 1 вместо 10.
```
В этом примере выражение std::cout << a ? b : c превращается в (std::cout << a) ? b : c. Вместо результата проверки в поток попадает значение переменной а.   

### Также важно помнить, что операции доступа по индексу [] и вызова функции () обладают одними из самых высоких приоритетов.
```cpp     
    // Перегрузка сложения вектора с числом.
    std::vector<int> operator+(std::vector<int> vec, int val) {
        for (auto& element: vec) {
            element += val;
        }
        return vec;
    }

    int main() {
        std::vector vec_1{1, 2, 3};
        std::vector vec_2{10, 20, 30};
        auto res = vec_1 + vec_2[1]; // vec_1 + (vec_2[1]) = {21, 22, 23}.
    }
// В этом примере сначала будет получен элемент вектора и только потом выполняется сложение.

// Таким же образом работает операция (): результат вызова функции рассчитывается раньше умножения.
    int Cube(int num) {
        return num * num * num;
    }
    int main() {
        int res = 5 * Cube(2); // 5 * (Cube(2)) = 40.
    }
```
### Предположим, мы определили операции сложения векторов и прибавления числа к вектору следующим образом. 
```cpp 
    std::vector<int> operator+ (std::vector<int> u, std::vector<int> v) {
        for (size_t i = 0; i < std::min(u.size(), v.size()); ++i) {
            u[i] += v[i];
        }
        return u;
    }

    std::vector<int> operator+ (std::vector<int> u, int n) {
        for (auto& elem: u) {
            elem += n;
        }
        return u;
    }
```
Особое внимание стоит обратить на операции инкремента и декремента. Как вы помните, они бывают четырёх видов:
- ++а — увеличивает a на 1, возвращает результат.
- --а — уменьшает a на 1, возвращает результат.
- а++ — сначала возвращает копию а, затем увеличивает a на 1.
- а-- — сначала возвращает копию а, затем уменьшает a на 1.

Приоритет инкремента и декремента выше, чем у арифметических операций. Кроме того, в зависимости от вида, они могут давать разные результаты. Префиксный инкремент меняет значение до того, как оно используется в выражении.
```cpp 
    int a = 2;
    int b = 3;
    
    // Порядок выполнения: // b += 1; а + (8 * b).
    int value =  a + 8 * ++b; // Результат: 34.

    А постфиксный — после.
    int a = 2;
    int b = 3;

    // Порядок выполнения: а + (8 * b); b += 1.
    int value =  a + 8 * b++; // Результат: 26.
```        
Чтобы не запутаться с приоритетами, вместо этих операций можно использовать выражение а += 1.
## Ассоциативность операций
Помимо приоритета, у операций есть свойство ассоциативности. Оно определяет, в каком порядке будут выполняться соседние операции с одинаковым приоритетом.
Большинство операций имеет левую ассоциативность, то есть они вычисляются слева направо.
```cpp 
    res = a / b * c / d;
    // Можно записать ((a / b) * c) / d.

    res = my_struct.value + 1;
    // Можно записать (my_struct.value) + 1.

    // Но существуют и такие операции, которые вычисляются справа налево. К ним относятся унарные и различные виды присваивания.
    
    res = a = b = c = 42;
    // Можно записать res = (a = (b = (c = 42))). В итоге res == 42.
```
## Операции ввода и вывода
### Прежде чем начать, давайте вспомним понятие потока. 
Это механизм для передачи данных, благодаря которому программа может получать информацию от пользователя или же выводить её (например, в консоль). В C++ есть два базовых типа для работы с потоками: ostream и istream.
    
istream отвечает за ввод данных — получает их из буфера и записывает в переменные. Для работы с этим потоком в стандартной библиотеке определён объект cin.

ostream осуществляет вывод, преобразуя значения из программы в последовательность символов. В зависимости от того, куда выводятся данные, различают несколько объектов этого типа: cout для вывода на консоль, cerr для вывода ошибок и clog для логирования.

Помимо базовых, в C++ существуют и более сложные типы потоков. 
Например, fstream определяет поток для чтения и записи в файл, а stringstream позволяет перенаправлять содержимое потока в строку.
### Ввод и вывод — это операции
Рассмотрим пользовательский тип VectorInt — вектор целых чисел. При работе с векторами временами возникает необходимость ввести элементы с клавиатуры или вывести их на экран. При этом стандартные операции ввода-вывода не сработают, поскольку они предназначены только для встроенных типов.
```cpp 
    using VectorInt = std::vector<int>;
    VectorInt vec{4, 8, 15, 16, 27, 42};

    std::cout << vec; // Ошибка.
    // Определим вывод элементов вручную.
    for (auto item : vec) {
        std::cout << item << " "s;
    }
```    
К счастью, operator >> и operator << — это такие же операции, как + и -, а значит, их можно перегружать для нестандартных типов. При этом в выражениях cin >> value; и cout << "Hello"s; объекты потоков cin и cout выступают в качестве левых операндов, а переменная value и строка "Hello"s — в качестве правых.
```cpp     
    operator+(600, 27); // Операцию сложения можно указать явно.
    // Ввод и вывод тоже можно.
    operator>>(std::cin, value); // Аналог std::cin >> value.
    operator<<(std::cout, "Hello"s); // Аналог std::cout << "Hello".
```    
### Перегружаем вывод
    Посмотрим, как выглядит определение функции для перегрузки вывода.
    using VectorInt = std::vector<int>;

    std::ostream& operator<<(std::ostream &os, const VectorInt &vector) { ... }

    Синтаксис схож с перегрузкой арифметических операций: в качестве параметров функция принимает левый и правый операнды и возвращает некоторое значение. Давайте разберёмся с ними по порядку.
    
    Первый параметр os — это левый операнд операции вывода, представляющий собой объект ostream (например, cout или cerr). Согласно правилам, в программе нельзя создавать копии объектов потоков — поэтому первый параметр может получать значение исключительно по ссылке: ostream &. Это позволяет функции использовать объект потока напрямую, без копирования. Кроме того, при записи значения в поток функция меняет его состояние, поэтому передаваемая ссылка должна быть неконстантной.

    Второй параметр vector соответствует правому операнду выражения. Это значение, которое нужно вывести. Оно тоже передаётся по ссылке, чтобы избежать лишнего копирования. Ключевое слово const указывает на то, что этот параметр не меняется внутри функции, мы просто помещаем его значение в поток.
    
    Функция возвращает ссылку на поток std::ostream&, то есть значение первого параметра.
    В теле функции можно реализовать логику вывода.
    using VectorInt = std::vector<int>;

    std::ostream& operator<<(std::ostream &os, const VectorInt &vector) {
        for (auto item : vector) {
            os << item << " "s; // Выводим элементы вектора.
        }
        return os; // Возвращаем исходную ссылку на поток.
    }

    int main() {
        VectorInt vec{4, 8, 15, 16, 27, 42};
        std::cout << vec; // Вывод: 4 8 15 16 27 42 .
    }

    Поскольку параметр os может быть любым потоком типа ostream, наша перегрузка << будет работать как с cout, так и с cerr и clog, а также с объектами классов ostringstream и ofstream.

### Каскадирование операций ввода-вывода
    Каскадированием (англ. chaining — «связывание») называется возможность выполнять сразу несколько операций в одном выражении. В случае ввода-вывода это значит, что можно читать или записывать сразу несколько значений.
    std::cin >> a >> b >> c; // Ввод сразу нескольких значений.

    std::cout << a << b << c << std::endl; // Вывод a, b, c и std::endl.
    Это возможно благодаря двум особенностям.
    Во-первых, ввод и вывод левоассоциативные, то есть выполняются слева направо.
    std::cout << a << b << c << std::endl;
    // Можно записать (((cout << a) << b) << c) << endl.
    Во-вторых, эти операции возвращают ссылку на поток. Что именно при этом происходит?
    В выражении std::cout << a << b << c << std::endl сначала выполняется самая левая операция: std::cout << a. Значение а выводится в поток, а возвращаемым результатом является сам объект std::cout. Таким образом, на следующем этапе мы имеем дело с выражением std::cout << b << c << std::endl.

    Если бы операция << ничего не возвращала, мы бы получили [void] << b << c << std::endl, и каскадирование было бы невозможным.

### Перегружаем ввод
    Рассмотрим объявление перегрузки для операции ввода.
    using PairInt = std::pair<int, int>;

    std::istream& operator>>(std::istream& is, PairInt& pair_int) { ... }
    Как и в случае с выводом, функция возвращает ссылку на поток — теперь вы знаете, что это нужно для реализации каскадирования. Первый параметр — объект типа istream, который и здесь передаётся в виде неконстантной ссылки. Второй параметр — переменная для записи. Она передаётся по ссылке, так как её значение будет меняться внутри функции, и эти изменения должны быть видны снаружи.
    Полная перегрузка ввода может выглядеть так.
    using PairInt = std::pair<int, int>;

    std::istream& operator>>(std::istream& is, PairInt& pair_int) {
        is >> pair_int.first >> pair_int.second; // Записываем значения.
        return is; // Возвращаем ссылку на поток.
    }

    int main() {
        PairInt p;

        // Создаём объект потока istringstream, содержащий значения 6 и 27.
        std::istringstream istring_stream("6 27"s);                        
        istring_stream >> p; // Записываем его в пару.

        std::cout << p.first << "_"s << p.second; // 6_27.
    }
    Здесь мы использовали тип istringstream для записи значений в пару. Это аналогично вызову std::cin >> p и введению в консоль строки «6 27».
    Бывает, что ввод и вывод нужно перегрузить для более сложных типов, например классов, имеющих приватные переменные. Чтобы у перегрузок операций был доступ к ним, их необходимо объявить как дружественные функции.
    class Date{
    public:
        Date() = default;
        Date(int y, int m, int d): y_(y), m_(m), d_(d) {};
        
        // Объявляем перегрузки как дружественные функции.
        friend std::istream& operator>>(std::istream& is, Date& date);
        friend std::ostream& operator<<(std::ostream& os, const Date& date);

    private:
        int y_, m_, d_;
    };

    // Перегрузка ввода для Date.
    std::istream& operator>>(std::istream& is, Date& date) {
        int y, m, d;
        is >> y >> m >> d;
        date.y_ = y; // Есть доступ к private-переменным.
        date.m_ = m;
        date.d_ = d;
        return is;
    }

    // Перегрузка вывода для Date.
    std::ostream& operator<<(std::ostream& os, const Date& date) {
        os << date.y_ << "."s << date.m_ << "."s << date.d_;
        return os;
    }
    Теперь перегруженные операции можно использовать, чтобы записывать и читать значения класса.
    Date date;
    std::istringstream istring_stream("25 12 2000"s);                 
    istring_stream >> date; // Считываем строку "25 12 2000" из потока в объект Date.
    std::cout << date; // Выводим дату: 25.12.2000.
### Обработка ошибок ввода
    Вам уже известно, что при вводе объект потока получает значения из буфера и пытается записать их в переменные. Это возможно не всегда — порой возникают ошибки ввода. Они могут быть связаны с преобразованием типа или же с внутренней логикой программы — например, если при записи даты было введено отрицательное число. Благодаря перегрузкам мы можем реализовать дополнительную логику для проверки вводимых значений.
    Следующий код записывает данные в структуру Date, только если все поля положительные.
    std::istream& operator>>(std::istream& is, Date& date) {
        int y, m, d;
        is >> y >> m >> d;
        
        if ( (y <= 0) || (m <= 0) || (d <= 0) ) {
            return is; // Если условие не выполнено, значения не записываются.
        }
        date.y_ = y;
        date.m_ = m;
        date.d_ = d;
        return is;
    }
    При вводе некорректных значений эта функция не станет менять объект date. Это хорошо, но было бы лучше, если бы вместе с тем она сообщала нам, что что-то пошло не так. Для этого перегрузка должна возвращать не просто поток, а поток с флагом ошибки, который можно проверить после её вызова.
    Чтобы перевести поток в состояние ошибки, можно воспользоваться методом setstate и флагом std::ios::failbit.
    if ( (y <= 0) || (m <= 0) || (d <= 0) ) {
        // Если условие не выполнено, не записываем значения 
        // и устанавливаем флаг ошибки.
        is.setstate(std::ios::failbit);
        return is; 
    }
    Убедиться в корректности ввода можно знакомым вам способом — с помощью конструкции if(!(std::cin)).
    Date d;
    if (!(std::cin >> d)) {
        std::cout << "Input error"s;
    }
### Обратите внимание, что перегрузка ввода не предпринимает попыток «починить» поток самостоятельно. 
    Её задача — вернуть результат операции, каким бы он ни был.
    Ошибки ввода могут возникать и по другим причинам, например из-за несоответствия вводимых значений типам переменных (если вместо целого числа ввести дробное или строку). Аналогичным образом мы можем предусмотреть это в перегрузке.
    std::istream& operator>>(std::istream& is, Date& date) {
        int y, m, d;
        is >> y >> m >> d;

        if (is.fail()) { // Используем флаг fail для проверки потока.
            return is;   // Если ошибка, ничего не делаем.
        }
        date.y_ = y;
        date.m_ = m;
        date.d_ = d;
        return is;
    }
    Здесь мы используем метод fail, который позволяет проверить успешность ввода так же, как if (!(std::cin)). Если что-то пошло не так, функция сразу возвращает поток. Он уже имеет флаг ошибки, поэтому устанавливать его вручную не нужно.
    При перегрузке операции ввода стоит всегда добавлять обработку потенциальных ошибок. Это сделает код более надёжным и упростит его дальнейшее использование.

## Унарные операции
    Мы уже говорили, что в C++ все операции можно разделить на три группы в зависимости от количества операндов: унарные, бинарные и тернарные. Унарными называют операции, выполняющиеся для одного значения. Среди них есть арифметические (унарные + и -, ++ и --), логические (~ и !), различные операции для приведения типов, а также особая группа операций для работы с памятью (* и &). Последние мы пройдём в скором будущем, а пока сосредоточимся на первой группе — арифметических операциях.
### Унарный + и унарный -
    Знакомство с этими операциями лучше начать с минуса, поскольку он интуитивно понятнее. Как и в математике, минус перед значением меняет его знак на противоположный.
    int a = -5;
    int b = -a;

    std::cout << a << std::endl;     // -5.
    std::cout << b << std::endl;     // 5.
    std::cout << -a << std::endl;    // 5.
    std::cout << -(-a) << std::endl; // -5.
    В отличие от минуса, унарный плюс не меняет знак операнда. Всё, что он делает, — это возвращает копию переданного значения.
    int a = -5;
    int b = +a; // Плюс возвращает копию значения.

    std::cout << a << std::endl;     // -5.
    std::cout << b << std::endl;     // -5.
    std::cout << +a << std::endl;    // -5.

    Унарный плюс можно использовать для придания ясности выражениям.
    Кроме этого, обе операции могут выполнять восходящее приведение целочисленных типов до int. Это свойство можно применять для переменных типа char, чтобы получать их коды в стандарте кодирования ASCII.
    char a = '*';

    std::cout << a << std::endl;  // *.
    std::cout << +a << std::endl; // 42 — код символа "*" в ASCII.
    std::cout << -a << std::endl; // -42.
### Как перегружать унарные операции
    Вам уже известно, что перегрузки операций можно объявлять двумя способами: в виде членов класса или в виде свободных функций. Как определить, какой подход лучше? Здесь можно воспользоваться простым правилом: если операция относится к конкретному объекту, лучше создать её внутри класса. Кроме того, такие перегрузки сразу имеют доступ к приватным полям, и их не нужно определять как дружественные функции.
    Если перегрузка реализована как функция-член, она работает с самим классом и не принимает дополнительные аргументы. Унарные плюс и минус не меняют исходный объект и поэтому объявляются константными.
    
    class Point {
        ...
        Point operator-() const { ... }
    };
    
    Если бы мы хотели создать перегрузку вне класса, у неё был бы один параметр, соответствующий единственному операнду и также являющийся константным.
    Point operator-(const Point& p) { ... }
    Далее приведён пример перегруженного унарного минуса для структуры Point. Он возвращает новый объект с противоположными знаками переменных.
    
    class Point {
    public:
        Point(int x, int y): x_(x), y_(y) {}
        Point operator-() const {
            return Point{-x_, -y_}; // Возвращаем новую Point.
        }
        int GetX() const { return x_; }
        int GetY() const { return y_; }   
        
    private:
        int x_, y_;
    };

    int main() {
        Point p1{4, -13};
        Point p2 = -p1;
        std::cout << p2.GetX() << ", "s << p2.GetY() << std::endl; // Выведет -4, 13.
    }
    
    Перегрузка унарного плюса также не меняет исходный класс, а просто возвращает его копию. Это можно сделать, используя ключевое слово this (указатель на текущий объект).
    
    class Point {
        Point operator+() const {
            return *this;
        }
    };

## Инкременты и декременты
### Операции инкремента и декремента тоже считаются унарными, поскольку работают с единственным операндом. 
    Напомним, что существует четыре такие операции:
    префиксный инкремент (++value);
    префиксный декремент (--value);
    постфиксный инкремент (value++);
    постфиксный декремент (value--).
### Префиксные операции меняют значение операнда и возвращают результат. Постфиксные, напротив, сначала возвращают текущее значение, а затем меняют его.
    double c = 2.99;
    // Выведет старое значение и увеличит c на 1.
    std::cout << c++ << std::endl; // 2.99. 
    // Увеличит c ещё на 1 и выведет её значение.
    std::cout << ++c << std::endl; // 3.99.
    
    Все инкременты и декременты работают только с изменяемыми значениями, такими как переменные или параметры. Применять их к литералам или результатам выражений нельзя.
    
    value++;    // Ок: value — это переменная.
    1++;        // Ошибка: применяем операцию к литералу.
    funcion()++; // Ошибка: применяем операцию к результату выражения.
    
    Особенности порядка работы этих операций могут приводить к проблемам в программе. Например, в следующем коде использование двух постфиксных инкрементов в одном выражении становится причиной неопределённого поведения. Компилятор не может однозначно решить, в каком порядке выполнять действия, и поэтому мы рискуем получить непредсказуемый результат.
    
    int value = 5;
    int res = value++ + value++; // Неопределённое поведение.
    
    Ниже приведено еще несколько примеров выражений, приводящих к этой проблеме.
    
    // Операция присваивания не может иметь два значения.
    value = value++ + 1 = value++ + 1; 
    // Нельзя одновременно увеличить переменную и присвоить её самой себе.
    value = ++value + 1; 
    // Использование двух инкрементов без скобок недопустимо.
    ++ ++value; 
    // Здесь не определены значения аргументов.
    function(++value, ++value);
    // Нельзя присвоить значение переменной в момент передачи в функцию.
    function(value = -1, value = -1); 
    // Операция вывода не может одновременно выполнять постфиксный инкремент.
    cout << value << value++; 
    Чтобы избежать неопределённого поведения, стоит внимательно относиться к применению инкрементов и декрементов. Лучше не использовать их в сложных конструкциях или несколько раз в одном выражении.

### Перегружаем инкременты и декременты
    Как и в случае с четырьмя арифметическими операциями, переопределяя инкременты и декременты, стоит создать перегрузки для всех четырех вариантов. Ведь кто бы ни пользовался нашим кодом, с его стороны будет логичным ожидать, что, если работает одна из операций, можно использовать и другие.
    Инкременты и декременты меняют непосредственно объекты классов или структур, поэтому их лучше реализовать как функции-члены.
    Несмотря на внешнее сходство, префиксные и постфиксные формы операций реализуются по-разному, что обусловлено особенностями их работы. Для начала давайте рассмотрим префиксный вариант.
    
    class Timer {
    public:
        Timer(int seconds): seconds_(seconds) { }
        int GetTime() const { return seconds_; }
        // Перегрузка префиксного инкремента.
        Timer& operator++() {
            seconds_ += 1; // Изменяем значение счётчика
            return *this; // и возвращаем ссылку на объект.
        }
        // Перегрузка префиксного декремента.
        Timer& operator--() {
            seconds_ -= 1;
            return *this;
        }
    private:
        int seconds_;
    };

    int main() {
        Timer timer_1{10};
        Timer timer_2 = ++timer_1;
        std::cout << timer_1.GetTime() << std::endl; // Выведет 11.
        std::cout << timer_2.GetTime() << std::endl; // Выведет 11.
    }

    Операции не принимают параметров, так как объявлены внутри класса. Первым шагом они уменьшают или увеличивают значение счётчика. Затем, используя this, они возвращают изменённую копию объекта.
    Чтобы отличать объявления постфиксных операций от префиксных, для них указывается дополнительный параметр типа int. Как правило, он не используется внутри функции, и его имя принято опускать.

    class Timer {
        ...
        // Перегрузка постфиксного инкремента.
        Timer operator++(int) {
            Timer old_timer = *this; // Сохраняем старое значение.
            ++(*this); // Меняем значение.
            return old_timer;
        }
        // Перегрузка постфиксного декремента.
        Timer operator--(int) {
            Timer old_timer = *this;
            --(*this);
            return old_timer;
        }
        ...
    };

    int main() {
        Timer timer_1{10};
        Timer timer_2 = timer_1++;
        std::cout << timer_1.GetTime() << std::endl; // Выведет 11.
        std::cout << timer_2.GetTime() << std::endl; // Выведет 10.
    }
### Эти операции должны возвращать исходную версию объекта
    поэтому мы сохраняем её в переменную old_timer и только потом меняем значение. В этом примере мы используем ранее реализованные префиксные формы — это допустимо, если во всех операциях действует одна и та же логика.
    Вам представлен класс Range с реализацией интервала, заданного двумя целыми числами. 
    
    class Range {
    public:
        Range(int start, int end): start_(start), end_(end) { }
        Range& operator++();
        Range& operator--();
        Range operator++(int);
        Range operator--(int);
    private:
        int start_, end_;
    };
    
    Работа инкрементов и декрементов для этого класса будет необычной. Префиксные операции должны менять нижнюю границу интервала, а постфиксные — верхнюю. 
    Range range{5, 20}; // Интервал [5, 20].
    range++; // Увеличиваем верхнюю границу на 1: [5, 21].
    ++range; // Увеличиваем нижнюю границу на 1: [6, 21].
    Полная реализация класса будет выглядеть так:
    
    class Range {
    public:
        Range(int start, int end): start_(start), end_(end) { }
        Range& operator++() {
            start_ += 1; return *this;
        }
        Range& operator--() {
            start_ -= 1; return *this;
        }
        Range operator++(int) {
            end_ += 1; return *this;
        }
        Range operator--(int) {
            end_ -= 1; return *this;
        }
    private:
        int start_, end_;
    };

## Перегрузить и присвоить
### Присваивание — одна из наиболее часто используемых операций в программировании. 
    С её помощью можно сохранять значения и результаты выражений в переменные, а также создавать и обновлять объекты. В этом уроке вы узнаете, как переопределять эти операции для работы со сложными типами данных.
    
    Главная операция присваивания в C++ — это =. Она бинарная, то есть работает с двумя операндами, копируя значение правого в левый. Правый операнд может быть сложным выражением или вызовом функции, а левый должен быть изменяемым объектом.
    
    a = 4;     // Ок.
    a + 2 = 5; // Ошибка: результату выражения нельзя присвоить значение.
    3 = a;     // Ошибка: нельзя записать значение в литерал.
    
    Присваивание поддерживает каскадирование и выполняется справа налево.
    
    value = a = b = 5; // Можно написать: value = (a = (b = 5)). 
    
    В этом примере число 5 сначала записывается в переменную b, затем в a и в value.
    При присваивании типы операндов не обязательно должны совпадать: если это возможно, тип правого значения будет автоматически приведен к типу левого.
    
    int value_int = true; // Логическое значение можно привести к int. Результат = 1.
    value_int = '*';      // При приведении к int получим код символа. Результат = 42.
    value_int = 4.222;    // Результат = 4.
    
    Злоупотреблять автоматическими преобразованиями не стоит, поскольку порой можно получить неожиданный результат. В этом примере значение слишком большое для типа переменной, из-за чего происходит переполнение.
    value_int = 3'000'000'000u; // -1294967296
    
    Помимо =, существуют и другие операции присваивания, сочетающие применение арифметического или логического преобразования и сохранение результата. Такие операции называются составными. Их можно разделить на несколько групп:
        арифметические (например, += и *=);
        логические (например, &=);
        операции побитового сдвига (например, >>=).
    Эти операции тоже принимают два операнда, но правый представляет собой значение для вычисления выражения. На втором шаге его результат становится правым операндом для присваивания.
    
    double value = 100;
    value += 100; // value = value + 100.
    value /= 15;  // value = value / 15..
### Перегрузка =
    Один из плюсов операции присваивания в том, что при работе с простыми классами и структурами перегрузка ей не нужна. Например, можно использовать = с объектами типа Point, и всё будет отлично работать.
    struct Point {
        int x, y;
    };

    int main() {
        Point point_1{10, 20};
        Point point_2;

        point_2 = point_1;      // Используем перегрузку по умолчанию.
        std::cout << point_2.x; // 10.
    }

    Это возможно, так как компилятор самостоятельно генерирует перегрузку присваивания. Она работает очень просто: копирует все нестатические поля одного объекта в другой того же типа. Во многих случаях этого достаточно.
    Явное использование присваивания по умолчанию можно задать с помощью слова default.
    struct Point {
        int x, y;
        Point& operator=(const Point& p2) = default;
    };

### Перегружать операцию присваивания вручную приходится в тех ситуациях, когда перенос значений между объектами требует более сложной логики и использовать реализацию по умолчанию нельзя. 
    Часто это связано с выделением памяти и указателями. Например, если один элемент класса указывает на другой, его копия в новом объекте должна указывать на копию другого элемента, а не на оригинал.
### Операцию = можно переопределить только в виде функции-члена класса или структуры. 
    Таким образом, в качестве параметра она получает только правый операнд — значение, которое нужно присвоить.
    Рассмотрим простой пример перегрузки: сделаем так, чтобы точке с тремя координатами (Point3D) можно было присваивать точки с двумя (Point2D).
    
    struct Point2D {
        int x, y;
    };

    struct Point3D {
        int x, y, z;
        
        Point3D& operator=(const Point2D& point_2d) {
            x = point_2d.x;
            y = point_2d.y;
            z = 0;
            return *this;
        }
    };
        
    int main() {
        Point2D point_2d{10, 20};
        Point3D point_3d{1, 1, 1};
        point_3d = point_2d;
        
        // Выведет: 10, 20, 0.
        std::cout << point_3d.x << ", "s << point_3d.y << ", "s << point_3d.z << std::endl;
    }
    
    Операция присваивания выполняет два действия. Во-первых, меняет текущий объект. Во-вторых, она должна вернуть его, чтобы работало каскадирование.
    
    При работе с точками наверняка понадобится и обратное действие: присваивание двумерным точкам значений трёхмерных.
### Операция присваивания и конструктор копирования
    Операция присваивания похожа на другой механизм: конструктор копирования. Конструктор копирования это особый вид конструктора класса, принимающий в качестве параметра уже существующий объект и создающий новый как его копию.
    
    Point point{1, 1};
    Point point_new(point); // Точка point_new создана на основе point. Это выражение вызовет конструктор Point(const Point&)
    
    В обоих случаях происходит перенос значений из одного объекта класса в другой. Однако следует различать эти процессы.
    Операция присваивания меняет объект, который уже был создан ранее. Он может быть пустым или содержать другие значения, которые заменяются на новые.
    Point point;
    point = Point(2, 2); // Присваиваем point новое значение.
    
    Конструктор копирования создаёт новый объект, идентичный существующему.
    Чтобы увидеть разницу, давайте рассмотрим пример с Point, преобразованной в класс. Определим для него конструктор копирования и перегрузку присваивания.
    
    class Point {
    public:
        Point (int x, int y): x(x), y(y) {} // Конструктор с параметрами.
        Point(const Point &point) { // Конструктор копирования.
            x = point.x;
            y = point.y;
        }
        
        // Перегрузка присваивания.
        Point& operator=(const Point& point) {
            x = point.x;
            y = point.y;
            return *this;
        }
        int x, y;
    };
    Используем конструкторы для создания новых объектов.
    
    Point point_1{0, 0}; // Используем конструктор с параметрами.
    Point point_2(point_1); // Создаём новую точку, вызывая конструктор копирования.

    // Здесь тоже вызовется конструктор, так как для компилятора 
    // эта запись аналогична Point point_3(point_1).
    Point point_3 = point_1; 
    
    Для их изменения вызывается присваивание.
    point_3 = point_1; // Выполнится присваивание — меняем существующую точку.
    point_3 = Point(1, 2); // Здесь тоже.
    
    Возможны и более сложные ситуации: например, если мы попытаемся присвоить существующей переменной точку, полученную с помощью конструктора копирования, будут использованы сразу оба механизма.
    // Сначала выражение Point(point_1) вызовет конструктор копирования,
    // который вернёт новую точку, созданную на основе point_1.
    // Затем она присвоится переменной point_3.
    point_3 = Point(point_1);

### Поток — уникальный ресурс, с которым может работать только один объект класса. 
    Другими такими ресурсами могут быть файлы или сетевые соединения. В подобных случаях копирование или присваивание объектов необходимо запретить. Для этого существует конструкция = delete.
    class File {
    public:
        File(const std::string& name) : filename(name) {
            // Открытие файла.
        }
        File(const File&) = delete; // Запрещаем конструктор копирования.
        File& operator=(const File&) = delete; // И операцию присваивания.

        ...
        
    private:
        std::string filename;
    };

    int main() {
        File file_1("Dead_Souls.txt"s);
        File file_2("Dead_Souls_2.txt"s);

        File file_new(file_1); // Ошибка: конструктор копирования недоступен.
        file_2 = file_1; // Ошибка: присваивание недоступно.
    }

### Перегрузка составных операций присваивания
    Составные операции похожи и на обычное присваивание, и на операции с арифметическими действиями. Они меняют значение левого операнда, присваивая ему результат выражения.
    
    Однако их выполнение более эффективно, поскольку им не нужно копировать левый операнд для расчёта. Так, при выполнении обычной арифметической операции (например, a = a * b) создаётся новый объект, содержащий результат умножения, который затем копируется в переменную а. Это требует дополнительных ресурсов на копирование данных и выделение памяти для нового объекта.
    
    При использовании синонимичной записи a *= b происходит непосредственное изменение переменной a, без каких-либо вспомогательных действий.
    
    В отличие от операции =, перегрузки составных присваиваний можно объявлять как внутри, так и вне класса. В первом случае операция принимает только один аргумент и возвращает измененный объект.
    
    struct Point {
        int x, y;
        // Перегрузка для сложения точек.
        Point& operator+=(const Point& p2) {
            x += p2.x;
            y += p2.y;
            return *this;
        }
    };

    int main() {
        Point point{0, 0};
        point += Point{10, 20}; // x = 10, y = 20.
    }
    
    Если же перегрузка объявлена как свободная функция, первым параметром она должна принимать левый операнд (в нашем случае — объект 
    структуры Point).
    
    struct Point {
        int x, y;
    };

    // Перегрузка для прибавления числа к точке.
    Point& operator+=(Point& p1, const int value) {
        p1.x += value;
        p1.y += value;
        return p1;
    }

    int main() {
        Point point{0, 2};
        point += 5; // x = 5, y = 7.
    }

## Неравенства из космолёта
    Операции сравнения (или отношения) в C++ часто требуют переопределения для нестандартных типов данных. В этом уроке вы научитесь это делать и узнаете, как операции сравнения помогают с сортировкой и что упростит логику перегрузок.
    К рассматриваемой группе относятся семь операций:
    
    >, <, >=, <= — операции сравнения.
    ==, != — операции определения равенства.
    <=> — операция эквивалентности (другое название — spaceship). Она появилась в языке со стандартом C++20, и в этом уроке вы познакомитесь с ней поближе.

    Как и большая часть операций, сравнения имеют левую ассоциативность (выполняются слева направо), а в качестве результата возвращают true или false. Для многих встроенных типов они определены по умолчанию. Например, можно сравнивать арифметические значения или элементы enum.
    enum class Seasons {
        WINTER, // Зима.
        SPRING, // Весна.
        SUMMER, // Лето.
        AUTUMN  // Осень.
    };
    ...
    if (Seasons::SPRING < Seasons::SUMMER) {
        std::cout << "Весна наступает раньше лета"s;
    } 
### Арифметические операторы не обязательно должны быть одного типа
    компилятор самостоятельно приведет их к одному типу перед тем, как выполнить сравнение. Конечно, это справедливо только для тех случаев, когда корректное приведение типов возможно (например, сравнить строку и число не получится).
    
    int a = 27;
    double b = 27.006;
    // Для сравнения значение из а приводится к типу double.
    std::cout << "b больше? - "s << (a < b ? "да"s : "нет"s) << std::endl; // Да.
    
    Кроме того, операции сравнения по умолчанию определены для таких типов, как строки, пары и векторы. В этом случае они действуют лексикографически, то есть поэлементно. Например, строки будут сравниваться посимвольно в соответствии с алфавитным порядком.

    auto line_1 = "Если ты счастливый котик, скажи мяу"s;
    auto line_2 = "Если ты любимый котик, скажи мяу"s;

    // Буква "л" (из слова "любимый") идёт раньше 
    // буквы "с" (из слова "счастливый").
    if (line_1 > line_2) {
        std::cout << "Вторая строка идёт раньше"s << std::endl;
    }
    
    В парах будут сравниваться соответствующие элементы.
    
    auto sportsman_1 = std::pair<int, int>{167, 52};
    auto sportsman_2 = std::pair<int, int>{167, 66};

    // Первые элементы равны, но 52 меньше 66.
    if (sportsman_1 < sportsman_2) {
        std::cout << "Первый спортсмен меньше"s << std::endl;
    }
### Операции сравнения задают отношение порядка элементов, которое используется для многих алгоритмов, в том числе для сортировки. 
    Чтобы эти алгоритмы работали правильно, необходимо, чтобы порядок удовлетворял ряду условий. Например, если a < b и b < с, то a < c. Если верно a < b, то утверждение b < a должно быть ложным.
    При перегрузке вы можете задавать любые правила сравнения, в том числе нарушающие эти условия. Но в этом случае алгоритмы, полагающиеся на отношение порядка, не будут работать корректно.

## Перегрузка сравнений
    Операции сравнения можно переопределять как внутри класса, так и в виде свободных функций. Как правило, второй способ предпочтительнее. Синтаксис перегрузки аналогичен тому, что вы изучили в прошлых уроках. В качестве примера перегрузим операцию < для класса VectorInt. По умолчанию векторы сравниваются по значениям элементов, но мы сделаем так, чтобы сравнивались размеры самих векторов.
    
    class VectorInt {
    public: 
        VectorInt(std::vector<int> data): data_(data) {}
        
        int GetLength() const {
            return data_.size();
        }
        ...
    private:
        std::vector<int> data_;
    };

    bool operator<(const VectorInt& lhs, const VectorInt& rhs) {
        return lhs.GetLength() < rhs.GetLength();
    }
   
    Пример работы операции:
   
    VectorInt vec_1({100, 3});
    VectorInt vec_2({1, 2, 3});
    if (vec_1 < vec_2) {
        std::cout << "Первый вектор короче"s;
    }
    
    Порой мы сталкиваемся с необходимостью сравнивать более сложные объекты, например структуры, имеющие несколько полей.
    
    struct Person {
        std::string first_name;  // Имя.
        std::string middle_name; // Среднее имя.
        std::string surname;     // Фамилия.
    };
    
    Нужно выполнять такое сравнение лексикографически, то есть сравнивать поля в определённом порядке: фамилия, имя, среднее имя. Чтобы реализовать эту логику, требуется довольно много кода.
    
    bool operator<(const Person& lhs, const Person& rhs) {
        // Если фамилии не равны, возвращаем результат их сравнения.
        if (lhs.surname != rhs.surname) {   
            return lhs.surname < rhs.surname;
        }
        // Если имена не равны, возвращаем результат их сравнения.
        if (lhs.first_name != rhs.first_name) { 
            return lhs.first_name < rhs.first_name; 
        }
        // Возвращаем результат сравнения средних имён. 
        return lhs.middle_name < rhs.middle_name;
    }
    
    Этого можно избежать, преобразовав нужные поля структуры в единый объект с помощью функции std::tie из библиотеки tuple. Такие объекты компилятор может сравнивать сам.
    
    // Подключаем библиотеку, чтобы использовать tie.
    #include <tuple> 
    struct Person {
        ...
        auto ListToCompare() const {
            // Возвращает {фамилия, имя, среднее имя}.
            return std::tie(surname, first_name, middle_name); 
        }
    };
    bool operator<(const Person& lhs, const Person& rhs) {
        // Сравниваем объекты.
        return lhs.ListToCompare() < rhs.ListToCompare();
    }
    ...
    Person person_1("Richard"s, "Phillips"s, "Feynman"s);
    Person person_2("John"s, "Archibald"s, "Wheeler"s);
    if (person_1 < person_2) {
        std::cout << "Первое имя идёт раньше"s;
    }
    
    Как видите, код операции стал гораздо компактнее. Теперь не нужно дублировать сложную логику, что упрощает работу и уменьшает вероятность ошибки.
    
    Когда мы переопределяем одну операцию сравнения, желательно переопределить и остальные. Ведь если кто-нибудь однажды воспользуется нашими перегрузками, с его стороны будет логично ожидать, что вместе с < можно использовать и >, и == вместе с !=. 
    Но программисты и здесь находят способ оптимизировать код: вместо того, чтобы с нуля писать все операции, можно описать логику только для < и выразить остальные через неё. 
### Перегрузка сравнений в стандарте C++20
    Хитрый подход с выражением всех операций через одну значительно упрощает разработку. Но с появлением стандарта C++20 хитрить больше не нужно: в этом стандарте появляется операция spaceship (<=>), избавляющая от необходимости перегружать операции вручную. Достаточно переопределить только её, и компилятор автоматически выведет все остальные (<, <=, >, >=).
    
    auto operator<=>(const VectorInt& lhs, const VectorInt& rhs) {
        return lhs.GetLength() <=> rhs.GetLength();
    }
    ...
    VectorInt v1({1, 2});
    VectorInt v2({0, 0, 0});
    std::cout << "v1 больше? - "s << (v1 > v2 ? "да"s : "нет"s) << std::endl; // Нет.
    std::cout << "v2 больше? - "s << (v1 < v2 ? "да"s : "нет"s) << std::endl; // Да.
    
    В качестве результата перегрузка <=> должна возвращать запись <левый операнд> <=> <правый операнд>.
    Операции равенства (== и !=) всё равно нужно определять отдельно, однако в C++20 достаточно написать только одну из них.
    auto operator==(const VectorInt& lhs, const VectorInt& rhs) {
        return lhs.GetLength() == rhs.GetLength();
    }
    ...
    // Операция == работает.
    std::cout << "v1 и v2 равны? - "s 
            << (v1 == v2 ? "да"s : "нет"s) << std::endl; // Нет.
    // И операция != тоже.
    std::cout << "v1 и v2 не равны? - " 
            << (v1 != v2 ? "да" : "нет") << std::endl; // Да.
    }
### Разные виды сравнения
    Логика сравнения объектов может быть разной. Например, строки можно сравнивать с учётом регистра или без. В первом случае слова meow и MeOw будут считаться разными (так работает сравнение строк по умолчанию), а во втором — одинаковыми.
    Для std::string переопределить сравнение нельзя. Одним из вариантов решения проблемы может быть создание собственного класса String.
    
    class String {
    public:
        String(std::string data = ""s): data_(data) {}
    
        // Переводит строку в нижний регистр.
        std::string ToLower() const { 
            std::string result = data_;
            for(char& ch : result) {
                ch = tolower(ch);
            }
            return result; 
        }
    private:
        std::string data_;
    };

    // Перегрузка сравнения для String.
    bool operator==(const String& lhs, const String& rhs) {
        return lhs.ToLower() == rhs.ToLower();
    }
    В таком формате для строк будет действовать данное правило сравнения без учета регистра.
    String line_1{"Mew"s};
    String line_2{"mew"s};

    if (line_1 == line_2) {
        std::cout << "Строки равны"s;
    }
    
    Для сортировки векторов существует функция sort, которая работает, если элементы поддерживают операцию <. При этом используются методы begin и end, означающие сортировку от начала и до конца. Вот как это делается.
    // Подключаем для сортировки.
    #include <algorithm> 
    ...
    // Перегрузка для Point.
    bool operator<(const Point& lhs, const Point& rhs) {
        if (lhs.x != rhs.x) { 
            return lhs.x < rhs.x; 
        }
        return lhs.y < rhs.y;
    }

    int main() {
        std::vector<Point> points{{4, 5}, {5, 7}, {4, 0}, {5, 0}};
        std::sort(points.begin(), points.end()); // Сортируем вектор.
    
        // Печатаем вектор. Результат: (4, 0) (4, 5) (5, 0) (5, 7).
        for (auto point : points) {
            std::cout << "("s << point.x << ", "s << point.y << ") "s;
        }
    }
    
    После сортировки элементы вектора выстраиваются в соответствии с указанным порядком (сначала сравниваются первые координаты, затем вторые): (4, 0) (4, 5) (5, 0) (5, 7).
    Как изменить перегрузку операции <, чтобы сортировать точки по удалённости от начала координат? Расстояние можно рассчитать по теореме Пифагора. 
    Пример сортировки: 
    
    std::vector<Point> points{{0, 4}, {5, -1}, {4, 0}, {5, 0}};
    std::sort(points.begin(), points.end()); // Сортируем вектор.
    // Результат: (0, 4) (4, 0) (5, 0) (5, -1).

## Явное и неявное преобразование типов
    C++ — строго типизированный язык. Каждое значение относится к конкретному типу данных (целое число, строка, класс), который должен быть определён на протяжении всего выполнения программы. В языке существуют механизмы, позволяющие приводить (преобразовывать) одни типы к другим. В этом уроке мы рассмотрим процесс преобразования типов при создании классов, а также перегрузки, позволяющие превращать объекты классов и структур в другие типы данных.
    
    В процессе написания кода порой происходят ситуации, когда нужно изменить тип значения. Это редко приходится делать специально, но иногда необходимость всё же возникает — например, при присваивании или сравнении. Для простых типов компилятор может сделать это самостоятельно.
    
    int value = false // value = 0.
    
    В этом примере приведение выполнено корректно: тип bool требует меньше байтов, чем int. Такое преобразование называется восходящим, и оно не приводит к потере информации (хотя на практике превращать bool в int таким образом всё же не стоит).
    
    Если мы попытаемся привести больший тип к меньшему, то есть выполнить нисходящее преобразование, существует риск получить переполнение или потерять разряды, что в итоге может привести к неверному результату.
    
    int64_t big_value = 10005000000;
    int value = big_value; // Переполнение: value = 1415065408.
    
    С такими преобразованиями следует быть особенно осторожными и не доверять их компилятору.
### На основе этого можно выделить ещё одну классификацию преобразований: явные и неявные. 
    Неявные (англ. implicit) приведения типов — это те, которые компилятор выполняет без нашего вмешательства (например, записывая значение одного типа в переменную другого).
    
    Явные (англ. explicit) преобразования мы реализуем в коде самостоятельно. Для этого в C++ существует операция static_cast.
    
    double value = static_cast<double>(true); // value = 1.
    
    Кроме того, можно воспользоваться приведением в стиле языка C (англ. C-style cast). В этом случае желаемый тип указывается перед значением в круглых скобках.
    
    double value_double = 6.27;
    
    int value_int = (int)value_double; // value_int = 6.
    
    C++ поддерживает такой синтаксис, однако static_cast считается более надежным способом приведения типов.
    
    Операция static_cast преобразует одни типы в другие на этапе компиляции. Она может выполнять как восходящие, так и нисходящие преобразования. В C++ существует еще несколько похожих операций. 
        const_cast позволяет менять тип значения на const и наоборот;
        dynamic_cast используется для динамического приведения типов во время выполнения программы;
    
    Эти способы предназначены для работы с простыми встроенными типами, для которых определены правила приведения. Для более сложных действий (например, преобразования строк в числа и наоборот) они не подойдут.
### В класс и обратно
    Объекты классов и структур тоже могут принимать участие в приведении типов. Для этого существует конструктор преобразования — особый вид конструктора, который создает объекты на основе переданных значений. Он может принимать один параметр (если принадлежит простому классу-обертке) или несколько (если речь идет о сложных классах и структурах).
    Рассмотрим пример такого конструктора, позволяющего создать объект Timer из значения int.
    
    class Timer {
    public:
        Timer() : seconds_(0) {}; // Обычный конструктор.
        Timer(int seconds) : seconds_(seconds) {}; // Конструктор преобразования.
        
        int GetTime() const { 
            return seconds_; 
        }
        ...
    private:
        int seconds_;
    };

    int main() {
        // Конструктор преобразования можно вызвать явно.
        Timer timer_1(10);
        
        // Или неявно — компилятор поймёт, что это Timer(10).
        Timer timer_2 = 10;
    }
    Запись Timer timer_2 = 10; позволяет выполнить неявное преобразование типов: из int в Timer. Это работает и в более сложных случаях: например, при передаче значения в функцию.
    void PrintTime(const Timer timer) {
        std::cout << "Оставшееся время: "s << timer.GetTime() 
                << " секунд"s << std::endl;
    }

    int main() {
        // В качестве параметра можно передать значение int —
        // оно автоматически преобразуется в Timer.
        PrintTime(15); 
    }
### Возможны и обратные преобразования — из объекта класса в другой тип. Для этого необходимо создать перегрузку операции приведения типа.
    operator OtherType() const;
    
    Немного изменим наш пример, добавив переопределение для преобразования объекта Timer в значение типа int. В качестве результата он будет возвращать оставшееся время в секундах.
    
    class Timer {
    public:
        Timer(int m, int s) : minutes_(m), seconds_(s) {};
        // Перегрузка приведения к int.
        operator int() const {
            return minutes_ * 60 + seconds_;
        }
    private:
        int minutes_, seconds_;
    };
    
    Перегруженная операция не принимает параметров. К тому же для неё не указывается тип возвращаемого значения, поскольку подразумевается, что он соответствует её названию.
    
    В итоге созданная перегрузка может участвовать как в явных, так и в неявных преобразованиях.
    
    Timer timer(10, 5);
    int total_time_1 = static_cast<int>(timer); // Явное преобразование.
    std::cout << total_time_1 << std::endl; // Напечатает количество секунд — 605.
    int total_time_2 = timer; // Неявное преобразование.
    std::cout << total_time_2 << std::endl; 
    
    Аналогичным образом можно создавать перегрузки для других типов: например, для bool.
    // Перегрузка приведения к bool.
    // Возвращает true, если остаётся время.
    operator bool() const {
        return (minutes_ > 0) || (seconds_ > 0);
    }
    Пример использования перегрузки.
    Timer timer{10, 5};   
    if (timer) {
        std::cout << "Время ещё есть!"s << std::endl;
    }
    
    Выражение if (timer) вызывает неявное приведение timer к bool, благодаря чему можно сразу проверить его значение.
    Неявные преобразования не всегда полезны, и порой их нужно избегать.
### Запрет неявных преобразований
    Несмотря на кажущееся удобство, неявное приведение типов делает программу более непредсказуемой и усложняет поиск ошибок.
    Например, следующее использование Timer будет считаться корректным.
    
    class Timer {
    public:
        Timer(int seconds) : seconds_(seconds) {}; // Конструктор преобразования.
        ...
    };

    int main() {
        Timer timer = -3.66363; // Этот код сработает.
    }
    
    Компилятор выполняет приведение типов и не сообщает об ошибке, несмотря на то, что переданное значение времени очевидно неверное.
    Эта же проблема может возникнуть с перегруженными операциями. Если для Timer определено приведение к bool, следующий код выполнится без ошибок, хотя в нём нет никакого смысла.
    
    Timer timer{0, 16};
    // Неопределённое поведение. Возможный вывод — 4.
    std::cout << (timer << 2) << std::endl;
    
    Чтобы избежать подобного поведения, используется ключевое слово explicit. Оно ставится рядом с конструктором или перегрузкой приведения, запрещая им участвовать в неявных преобразованиях.
    
    class Timer {
    public:
        explicit Timer(int seconds) : seconds_(seconds) {};
        ...
    };

    int main() {
        Timer timer_1(60);        // Ок: конструктор вызывается явно.
        Timer timer_2 = -3.66363; // Ошибка: неявные преобразования запрещены.
        Timer timer_3 = 60;       // Всё ещё ошибка.
    }
    
    Теперь создать объект Timer можно только с явным вызовом конструктора.
    Похожим образом можно запретить автоматическое приведение к другим типам. В случае с bool ошибка компиляции сразу позволит найти некорректный код.
    class Timer {
    public:
    explicit operator bool() const {
        return (minutes_ > 0) || (seconds_ > 0);
    ...
    }

    int main() {
        Timer timer{0, 16};
        std::cout << (timer << 2) << std::endl;   // Ошибка.
        
        bool has_time = static_cast<bool>(timer); // Явное приведение сработает.
    }

### Слово explicit стоит использовать в тех случаях, когда неявные преобразования потенциально могут привести к неожиданным результатам или ошибкам — то есть практически всегда, за исключением ситуаций, когда автоматическое приведение логически оправдано.
    Давайте вернёмся к классу Timer с перегруженной операцией приведения к целому числу. 
    class Timer {
    public:
        Timer(int m, int s) : minutes_(m), seconds_(s) {};
        
        operator int() const { // Перегрузка приведения к int.
            return minutes_ * 60 + seconds_;
        }
    private:
        int minutes_, seconds_;
    };

    int Cube(int value) {
        return value * value * value;
    }
    Существует множество ситуаций, приводящих к неявным преобразованиям, которые не всегда легко заметить. 

## Перегрузка логических и побитовых операций
### Логические операции
    Вы уже знаете, что логические операции работают с выражениями типа bool и позволяют их комбинировать. В C++ таких операций всего три:
    Логическое И (&&) — возвращает true, если оба условия истинны.
    Логическое ИЛИ (||) — возвращает true, если хотя бы одно условие истинно.
    Логическое отрицание (!) — инвертирует значение.
### Чаще всего логические операции используются для проверки нескольких условий.
    bool writes_with_left_hand = true;
    bool uses_scissors_with_left_hand = false;
    // Если человек пишет И держит ножницы левой рукой, он левша.
    if (writes_with_left_hand && uses_scissors_with_left_hand) {
        std::cout << "You're left-handed"s;
    // Если он ИЛИ пишет, ИЛИ держит ножницы левой рукой — у него смешанный тип.
    } else if (writes_with_left_hand || uses_scissors_with_left_hand) {
        std::cout << "You're mixed-handed"s;
    }
    
    Синтаксис перегрузки аналогичен перегрузкам других бинарных операций. Она получает два операнда и возвращает результат, который может быть либо типа bool, либо любого другого типа.
    В качестве примера рассмотрим уже знакомый вам класс Interval. Мы можем использовать логическое И (&&) для нахождения общей части двух диапазонов.
    
    class Interval {
        ...
        Interval operator&&(const Interval& other) {
            int new_start = std::max(start_, other.start_);
            int new_end = std::min(end_, other.end_);
            
            if (new_start <= new_end) {
                return Interval(new_start, new_end);
            }
            return Interval();
        }
    private:
        int start_, end_;
    };
    ...
    Interval inter = Interval(2, 6) && Interval(4, 19); // [4, 6].
    
    Напомним, что при выполнении логических операций в C++ используются ленивые вычисления: если посчитанная часть выражения позволяет предсказать результат, остальные части не вычисляются. Например, если функция IsLeftHanded возвращает true, условие будет выполнено независимо от значения IsRightHanded. Компилятор может сразу дать ответ, не вызывая IsRightHanded.
    
    if (IsLeftHanded() || IsRightHanded()) {
        std::cout << "You're mixed-handed"s;
    }

    Перегруженные логические операции работают без этой оптимизации: выражения всегда будут рассчитываться целиком.

## Поразрядные операции
    Поразрядные операции во многом похожи на логические. Главное отличие состоит в том, что они работают с отдельными битами (разрядами) значений.
    Чтобы это продемонстрировать, представим операнды a и b в двоичной системе счисления:
    
    а = 15 = 00001111,
    b = 19 = 00010011.
    
    Побитовое ИЛИ (|) будет выполнено для каждого разряда и вернёт 00011111. Побитовое И (&) аналогичным образом вернёт 00000011.
    
    #include <bitset> // Подключаем, чтобы вывести биты числа.
    int main() {
        int a = 0b00001111; // Число 15 в двоичной записи.
        int b = 0b00010011; // Число 19 в двоичной записи.

        // Выведем результат поразрядного ИЛИ в двоичном виде.
        // Получим 00011111.
        std::cout << std::bitset<8>(a | b)  << std::endl;
        
        // Результат поразрядного И: 00000011.
        std::cout << std::bitset<8>(a & b)  << std::endl;
    }
    
    Для работы с побитовыми операциями не обязательно использовать двоичное представление.
    
    int a = 15; 
    int b = 18; 

    std::cout << std::bitset<8>(a | b)  << std::endl; // Всё ещё 00011111.
    std::cout << (a | b)  << std::endl; // 31 (00011111 в десятичной системе).
### В C++ существует шесть побитовых операций:
    & — поразрядное И;
    | — поразрядное ИЛИ;
    ^ — поразрядное исключающее ИЛИ: возвращает 0, если операнды равны;
    ~ — поразрядное отрицание;
    << и >> — операции сдвига: сдвигают биты числа влево или вправо на указанное количество позиций.

### На практике поразрядные операции могут применяться для работы с флагами. 
    Флаг представляет собой значение, в котором все разряды, кроме одного, равны нулю.
   
    enum class UserRoles {
        Admin = 1,  // Равно 2 в степени 0 = 0001.
        Editor = 2, // Равно 2 в степени 1 = 0010.
        Viewer = 4  // Равно 2 в степени 2 = 0100.
    };
    
    Длина флага в битах может быть произвольной — главное, чтобы ее хватало для записи всех позиций единицы. В этом примере мы взяли длину в четыре бита.
    
    Чтобы элементы перечисления имели одну единицу в двоичном представлении, они должны равняться степеням двойки.
    Флаги используются для отражения каких-либо свойств объекта. В нашем примере пользователь может иметь роли Admin, Editor и Viewer или любую их комбинацию. Если у пользователя есть роли Admin и Viewer, комбинация его флагов будет 0001 | 0100 = 0101.
    
    enum class UserRoles {
        Admin = 1,  // 0001.
        Editor = 2, // 0010.
        Viewer = 4  // 0100.
    };
    // Перегрузка для работы с типом UserRoles.
    int operator|(unsigned int a, UserRoles b) {
        return a | static_cast<int>(b);
    }
    int main() {
        unsigned int user_role = 0; // Сначала у пользователя нет флагов (0000).
        
        // Добавляем флаг Admin: 0000 | 0001 = 0001.
        user_role = user_role | UserRoles::Admin;
        
        // Добавляем флаг Viewer: 0001 | 0100 = 0101.
        user_role = user_role | UserRoles::Viewer;
    }
    
    Чтобы проверить наличие определённого флага, можно использовать операцию &.
    // Перегрузка для работы с типом UserRoles.
    int operator&(unsigned int a, UserRoles b) {
        return a & static_cast<int>(b);
    }
    ...
    // 0101 & 0001 = 0001 = true
    if (user_role & UserRoles::Admin) {
        std::cout << "У вас есть права администратора"s << std::endl;
    }
    // 0101 & 0010 = 0000 = false
    if (!(user_role & UserRoles::Editor)) {
        std::cout << "У вас нет прав редактора"s << std::endl;
    }
    
    С помощью поразрядных операций можно выполнять и другие действия над флагами: снимать, инвертировать и так далее.

## Круглые и квадратные
### Перегрузка доступа по индексу
    Операция индекса (или взятия по индексу) — это знакомые вам квадратные скобки [], которые позволяют получить элемент последовательности по его порядковому номеру (в C++, как и во многих языках программирования, нумерация начинается с 0).

    По умолчанию доступ по индексу применим к встроенным типам, представляющим последовательность (например, векторы и строки). Мы можем перегрузить его, чтобы применять к классам и доставать из них нужные элементы. В этом случае класс можно рассматривать как вектор (или контейнер), хранящий упорядоченные данные.
    
    В качестве примера посмотрим на класс VectorUnion, который содержит два вектора (v1_ и v2_) и позволяет работать с ними как с одним (v1_ + v2_).
    class VectorUnion { 
    public:
        VectorUnion(const std::vector<int>& v1, 
                    const std::vector<int>& v2): 
                    v1_(v1), v2_(v2) { }
        
        int operator[](std::size_t index) const {
            if (index < v1_.size()) { 
                return v1_[index]; 
            } else { 
                return v2_[index - v1_.size()];
            }
        }
    private:
        std::vector<int> v1_, v2_; // Данные хранятся в двух векторах.
    };

    int main() {
        VectorUnion vec{{1, 2, 3}, {40, 50, 60}};
        
        // Можем работать с vec как с одним
        // большим вектором: {1, 2, 3, 40, 50, 60}.
        // Индексы:           0  1  2   3   4   5.
        std::cout << vec[5]; // Напечатает 60.
    }
    
    Поскольку операция [] работает непосредственно с объектами класса, она объявляется только как функция-член. В качестве параметра она принимает индекс — идентификатор элемента, который нужно вернуть. При этом индекс может быть любого типа: как числом, так и строкой.
    
    В приведённом примере перегрузка объявлена со словом const. Это значит, что операция допускает только чтение элементов, и мы не можем их менять. Если нужно обеспечить и чтение, и запись, принято определять два варианта перегрузки: константный и неконстантный.
    
    Неконстантный метод должен возвращать ссылку, чтобы обеспечить прямой доступ к элементу, благодаря чему его можно редактировать.
    Константный метод может возвращать либо копию объекта (как выше в примере с int), либо ссылку на него. Второй способ подходит для сложных объектов, так как избавляет от лишнего копирования.
    
    class VectorUnion { 
        int& operator[](std::size_t index) { ... } // Перегрузка для записи.
        const int& operator[](std::size_t index) const { ... } // И для чтения.
    };
    
    При перегрузке индекса мы берём на себя ответственность за корректную работу операции. Поэтому важно учитывать случаи, когда ей может быть передан некорректный параметр (например, индекс, выходящий за пределы последовательности). Обработать невалидный индекс можно так.
    
    int& operator[](std::size_t index) {
        if ((index < 0) || (index >= (v1_.size() + v2_.size()))) {
            std::abort(); // Если индекс неверный, завершаем программу.
        }
        if (index < v1_.size()) { 
            return v1_[index]; 
        } else { 
            return v2_[index - v1_.size()];
        }
    }

    Если в качестве индексов используются строки, мы получаем контейнер, в котором информация хранится в виде пар «строковый индекс — значение» или «ключ — значение». Такая структура данных называется словарём. Словари достаточно часто используются в программировании, в том числе в C++. 

### До этого мы рассматривали случаи, когда операция [] принимала один индекс. 
    Начиная со стандарта C++23, ей можно передавать сразу несколько индексов, записывая их через запятую. Это свойство удобно использовать при создании матриц — объектов, хранящих данные в виде таблицы.
    
    class Matrix{
    public: 
        Matrix(std::vector<int> data, int stride): 
            data_(data), stride_(stride) {}
        
        // Перегрузка с двумя индексами.
        int& operator[](int col, int row) {
            return data_[col + stride_ * row];
        }
    private:
        std::vector<int> data_; // Элементы хранятся в одном векторе.
        int stride_; // Ширина таблицы (количество столбцов).
    };
    
    Этот пример также хорошо иллюстрирует принятый подход к записи таблиц в память компьютера. Вместо того чтобы хранить столбцы и строки, таблицу «разворачивают» в единую последовательность элементов и сохраняют исходное значение ширины (stride_). Позже его используют, чтобы найти нужный элемент по номерам строки и столбца: data_[col + stride_ * row].
    Далее созданную матрицу можно использовать для записи, чтения и изменения элементов.
    
    // Матрица (таблица) чисел:
    // 11 12 13 14
    // 21 22 23 24
    // 31 32 33 34
    
    Matrix matrix({11, 12, 13, 14, 21, 22, 23, 24, 31, 32, 33, 34}, 4);

    // Берём второй элемент в первой строке (23).
    std::cout << matrix[2, 1] << std::endl;

    // Так как возвращается ссылка, можем
    // менять элемент матрицы:
    matrix[0, 0] = 100;
### Перегрузка операции вызова функции
    C++ позволяет перегружать и более необычные операции. Например, круглые скобки (), вызывающие объект как функцию.
    struct Linear {
        double a, b;
        
        // Перегрузка операции.
        double operator()(double x) const {
            return a * x + b;
        }
    };
    int main() {
        Linear func{2, 1};    // Представляет функцию 2x + 1.

        double f_0 = func(0); // Посчитает: 2 * 0 + 1 = 1.
        double f_5 = func(5); // Посчитает: 2 * 5 + 1 = 11.
    }

## Дополнительные возможности: пользовательские литералы
### Литерал — это константа, записанная в коде. Литералы бывают:
    целочисленные (например, -42, 55UL, 0x1f);
    с плавающей точкой (например, 3.14, -1.e-15);
    строковые (например, "Hello, Oleg");
    символьные (например, 'a', '\0').
### Ещё есть пользовательские литералы. 
    В этом случае к стандартному литералу добавляется суффикс. Например, так можно получить строку типа std::string: "Hello, Oleg"s (суффикс s). А так — 15 миллисекунд: 15ms (суффикс ms). Для использования этих литералов нужно написать using namespace std::literals.
    Можно создавать собственные пользовательские литералы, определяя новые суффиксы. Но есть одно требование — они должны начинаться с подчеркивания _.
    
    // Литерал для задания килобайтов.
    unsigned long long operator"" _Kb(unsigned long long x) { return x * 1024; }

    // Литерал для задания мегабайтов.
    unsigned long long operator"" _Mb(unsigned long long x) { return x * 1024 * 1024; }

    // Литерал, обращающий строку.
    std::string operator"" _Rev(const char* ptr, size_t size) {
        std::string str(ptr, size);
        std::reverse(str.begin(), str.end());
        return str;
    }

    int main() {
        // 10 килобайт.
        std::cout << 10_Kb << std::endl; // 10 * 1024 = 10240.

        // Сколько килобайт в 500 мегабайтах:
        std::cout << (500_Mb / 1_Kb) << std::endl; // 512000.
        
        std::cout << "telefon"_Rev << std::endl; // nofelet.
    }

### Правила и ограничения перегрузки операций

#### Операции, которые НЕЛЬЗЯ перегружать
Важно помнить, что не все операции можно перегружать в C++:
- `::` — разрешение области видимости
- `.` — доступ к члену объекта
- `.*` — доступ к члену через указатель на член объекта
- `?:` — тернарный условный оператор
- `sizeof` — получение размера типа
- `typeid` — получение информации о типе

#### Операции, которые можно перегружать только как методы класса
Некоторые операции могут быть перегружены только как функции-члены класса:
- `=` — присваивание
- `[]` — индексирование
- `()` — вызов функции
- `->` — доступ к члену через указатель

```cpp
class MyClass {
public:
    // Правильно - как метод класса
    MyClass& operator=(const MyClass& other);
    int& operator[](size_t index);
    int operator()(int x, int y);
    
    // Неправильно - нельзя как свободную функцию
    // friend MyClass& operator=(MyClass& lhs, const MyClass& rhs); // Ошибка!
};
```

### Идиомы перегрузки операций

#### Идиома Copy-and-Swap для оператора присваивания
Безопасный способ реализации оператора присваивания:

```cpp
class MyClass {
private:
    int* data;
    size_t size;
    
public:
    // Конструктор копирования
    MyClass(const MyClass& other) : data(new int[other.size]), size(other.size) {
        std::copy(other.data, other.data + size, data);
    }
    
    // Функция swap
    void swap(MyClass& other) noexcept {
        std::swap(data, other.data);
        std::swap(size, other.size);
    }
    
    // Оператор присваивания через copy-and-swap
    MyClass& operator=(MyClass other) {  // Передача по значению!
        swap(other);
        return *this;
    }
    
    ~MyClass() { delete[] data; }
};
```

#### Каноническая форма класса (Rule of Three/Five)
При перегрузке оператора присваивания часто нужно также определить:

```cpp
class Resource {
private:
    int* ptr;
    
public:
    // Конструктор
    Resource(int value) : ptr(new int(value)) {}
    
    // 1. Деструктор
    ~Resource() { delete ptr; }
    
    // 2. Конструктор копирования
    Resource(const Resource& other) : ptr(new int(*other.ptr)) {}
    
    // 3. Оператор присваивания
    Resource& operator=(const Resource& other) {
        if (this != &other) {
            delete ptr;
            ptr = new int(*other.ptr);
        }
        return *this;
    }
    
    Resource(Resource&& other) noexcept : ptr(other.ptr) {
        other.ptr = nullptr;
    }
    
    Resource& operator=(Resource&& other) noexcept {
        if (this != &other) {
            delete ptr;
            ptr = other.ptr;
            other.ptr = nullptr;
        }
        return *this;
    }
};
```

### Перегрузка операций для работы с умными указателями

```cpp
template<typename T>
class SmartPtr {
private:
    T* ptr;
    
public:
    explicit SmartPtr(T* p = nullptr) : ptr(p) {}
    ~SmartPtr() { delete ptr; }
    
    // Запрещаем копирование
    SmartPtr(const SmartPtr&) = delete;
    SmartPtr& operator=(const SmartPtr&) = delete;
    
    // Разрешаем перемещение
    SmartPtr(SmartPtr&& other) noexcept : ptr(other.ptr) {
        other.ptr = nullptr;
    }
    
    SmartPtr& operator=(SmartPtr&& other) noexcept {
        if (this != &other) {
            delete ptr;
            ptr = other.ptr;
            other.ptr = nullptr;
        }
        return *this;
    }
    
    // Операторы доступа
    T& operator*() const { return *ptr; }
    T* operator->() const { return ptr; }
    
    // Проверка на null
    explicit operator bool() const { return ptr != nullptr; }
    
    // Освобождение ресурса
    T* release() {
        T* temp = ptr;
        ptr = nullptr;
        return temp;
    }
};
```

### Перегрузка операций для контейнеров

#### Пример класса-обёртки для std::vector с дополнительной функциональностью

```cpp
template<typename T>
class SafeVector {
private:
    std::vector<T> data;
    
public:
    // Конструкторы
    SafeVector() = default;
    SafeVector(std::initializer_list<T> init) : data(init) {}
    SafeVector(size_t size, const T& value = T{}) : data(size, value) {}
    
    // Безопасный доступ по индексу
    T& operator[](size_t index) {
        if (index >= data.size()) {
            throw std::out_of_range("Index out of range");
        }
        return data[index];
    }
    
    const T& operator[](size_t index) const {
        if (index >= data.size()) {
            throw std::out_of_range("Index out of range");
        }
        return data[index];
    }
    
    // Арифметические операции для векторов
    SafeVector& operator+=(const SafeVector& other) {
        if (data.size() != other.data.size()) {
            throw std::invalid_argument("Vector sizes must match");
        }
        for (size_t i = 0; i < data.size(); ++i) {
            data[i] += other.data[i];
        }
        return *this;
    }
    
    SafeVector operator+(const SafeVector& other) const {
        SafeVector result = *this;
        result += other;
        return result;
    }
    
    // Скалярное произведение
    T operator*(const SafeVector& other) const {
        if (data.size() != other.data.size()) {
            throw std::invalid_argument("Vector sizes must match");
        }
        T result = T{};
        for (size_t i = 0; i < data.size(); ++i) {
            result += data[i] * other.data[i];
        }
        return result;
    }
    
    // Умножение на скаляр
    SafeVector& operator*=(const T& scalar) {
        for (auto& element : data) {
            element *= scalar;
        }
        return *this;
    }
    
    // Операции сравнения
    bool operator==(const SafeVector& other) const {
        return data == other.data;
    }
    
    bool operator!=(const SafeVector& other) const {
        return !(*this == other);
    }
    
    // Вывод в поток
    friend std::ostream& operator<<(std::ostream& os, const SafeVector& vec) {
        os << "[";
        for (size_t i = 0; i < vec.data.size(); ++i) {
            if (i > 0) os << ", ";
            os << vec.data[i];
        }
        os << "]";
        return os;
    }
    
    // Полезные методы
    size_t size() const { return data.size(); }
    bool empty() const { return data.empty(); }
    void push_back(const T& value) { data.push_back(value); }
};

// Умножение на скаляр (скаляр слева)
template<typename T>
SafeVector<T> operator*(const T& scalar, const SafeVector<T>& vec) {
    SafeVector<T> result = vec;
    result *= scalar;
    return result;
}
```

### Практические советы

#### 1. Симметричность операций
Если перегружаете бинарную операцию, подумайте о симметричности:

```cpp
class Number {
    int value;
public:
    Number(int v) : value(v) {}
    
    // Метод класса - работает только для Number + Number
    Number operator+(const Number& other) const {
        return Number(value + other.value);
    }
};

// Свободная функция - работает для Number + int и int + Number
Number operator+(const Number& lhs, int rhs) {
    return Number(lhs.value + rhs);
}

Number operator+(int lhs, const Number& rhs) {
    return Number(lhs + rhs.value);
}
```

#### 2. Последовательность реализации операций
Реализуйте операции в логическом порядке:

```cpp
class MyClass {
public:
    // Сначала основные операции
    MyClass& operator+=(const MyClass& other);
    MyClass& operator-=(const MyClass& other);
    
    // Потом производные через основные
    MyClass operator+(const MyClass& other) const {
        MyClass result = *this;
        result += other;
        return result;
    }
    
    MyClass operator-(const MyClass& other) const {
        MyClass result = *this;
        result -= other;
        return result;
    }
};
```

#### 3. Производительность
Помните о производительности при перегрузке операций:

```cpp
// Неэффективно - создаёт временные объекты
Matrix result = a + b + c + d;

// Эффективнее - используйте составные операции
Matrix result = a;
result += b;
result += c;
result += d;

// Или предоставьте специальные методы
Matrix result = Matrix::sum({a, b, c, d});
```
