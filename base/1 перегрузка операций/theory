





Поразрядные операции
Поразрядные операции во многом похожи на логические. Главное отличие состоит в том, что они работают с отдельными битами (разрядами) значений.
Чтобы это продемонстрировать, представим операнды a и b в двоичной системе счисления:
а = 15 = 00001111,
b = 19 = 00010011.
Побитовое ИЛИ (|) будет выполнено для каждого разряда и вернёт 00011111. Побитовое И (&) аналогичным образом вернёт 00000011.
#include <bitset> // Подключаем, чтобы вывести биты числа.
int main() {
    int a = 0b00001111; // Число 15 в двоичной записи.
    int b = 0b00010011; // Число 19 в двоичной записи.

    // Выведем результат поразрядного ИЛИ в двоичном виде.
    // Получим 00011111.
    std::cout << std::bitset<8>(a | b)  << std::endl;
    
    // Результат поразрядного И: 00000011.
    std::cout << std::bitset<8>(a & b)  << std::endl;
}
Для работы с побитовыми операциями не обязательно использовать двоичное представление.
int a = 15; 
int b = 18; 

std::cout << std::bitset<8>(a | b)  << std::endl; // Всё ещё 00011111.
std::cout << (a | b)  << std::endl; // 31 (00011111 в десятичной системе).
В C++ существует шесть побитовых операций:
& — поразрядное И;
| — поразрядное ИЛИ;
^ — поразрядное исключающее ИЛИ: возвращает 0, если операнды равны;
~ — поразрядное отрицание;
<< и >> — операции сдвига: сдвигают биты числа влево или вправо на указанное количество позиций.
На практике поразрядные операции могут применяться для работы с флагами. Флаг представляет собой значение, в котором все разряды, кроме одного, равны нулю.
enum class UserRoles {
    Admin = 1,  // Равно 2 в степени 0 = 0001.
    Editor = 2, // Равно 2 в степени 1 = 0010.
    Viewer = 4  // Равно 2 в степени 2 = 0100.
};
Длина флага в битах может быть произвольной — главное, чтобы ее хватало для записи всех позиций единицы. В этом примере мы взяли длину в четыре бита.
Чтобы элементы перечисления имели одну единицу в двоичном представлении, они должны равняться степеням двойки.
Флаги используются для отражения каких-либо свойств объекта. В нашем примере пользователь может иметь роли Admin, Editor и Viewer или любую их комбинацию. Если у пользователя есть роли Admin и Viewer, комбинация его флагов будет 0001 | 0100 = 0101.
enum class UserRoles {
    Admin = 1,  // 0001.
    Editor = 2, // 0010.
    Viewer = 4  // 0100.
};
// Перегрузка для работы с типом UserRoles.
int operator|(unsigned int a, UserRoles b) {
    return a | static_cast<int>(b);
}
int main() {
    unsigned int user_role = 0; // Сначала у пользователя нет флагов (0000).
    
    // Добавляем флаг Admin: 0000 | 0001 = 0001.
    user_role = user_role | UserRoles::Admin;
    
    // Добавляем флаг Viewer: 0001 | 0100 = 0101.
    user_role = user_role | UserRoles::Viewer;
}
Чтобы проверить наличие определённого флага, можно использовать операцию &.
// Перегрузка для работы с типом UserRoles.
int operator&(unsigned int a, UserRoles b) {
    return a & static_cast<int>(b);
}
...
// 0101 & 0001 = 0001 = true
if (user_role & UserRoles::Admin) {
    std::cout << "У вас есть права администратора"s << std::endl;
}
// 0101 & 0010 = 0000 = false
if (!(user_role & UserRoles::Editor)) {
    std::cout << "У вас нет прав редактора"s << std::endl;
}
С помощью поразрядных операций можно выполнять и другие действия над флагами: снимать, инвертировать и так далее.
В этом уроке вы узнали об особенностях логических и поразрядных операций. И те и другие выполняют вычисления, основанные на алгебре логики, однако первые работают с выражениями типа bool, а вторые — с отдельными битами значений. Благодаря этой особенности побитовые операции удобно использовать для работы с флагами.
Далее вас ждёт заключительный урок темы, в котором вы узнаете о перегрузке операций-скобок: [] и ().
Круглые и квадратные
Вы успешно изучили основные виды операций, которые можно перегружать: арифметические, ввода-вывода, сравнения, присваивания и приведения типов. Этот урок завершает тему о перегрузках, и в нём мы рассмотрим несколько менее популярных операций, которые в определённых ситуациях могут быть очень полезны. Вы узнаете, как перегружать операцию [] (взятие по индексу) и операцию (), которая очень похожа на вызов функции. Также попробуете создать свой вид литералов.
Перегрузка доступа по индексу
Операция индекса (или взятия по индексу) — это знакомые вам квадратные скобки [], которые позволяют получить элемент последовательности по его порядковому номеру (в C++, как и во многих языках программирования, нумерация начинается с 0).
Давайте вспомним, в каких случаях работает доступ по индексу.
По умолчанию доступ по индексу применим к встроенным типам, представляющим последовательность (например, векторы и строки). Мы можем перегрузить его, чтобы применять к классам и доставать из них нужные элементы. В этом случае класс можно рассматривать как вектор (или контейнер), хранящий упорядоченные данные.
В качестве примера посмотрим на класс VectorUnion, который содержит два вектора (v1_ и v2_) и позволяет работать с ними как с одним (v1_ + v2_).
class VectorUnion { 
public:
    VectorUnion(const std::vector<int>& v1, 
                const std::vector<int>& v2): 
                v1_(v1), v2_(v2) { }
    
    int operator[](std::size_t index) const {
        if (index < v1_.size()) { 
            return v1_[index]; 
        } else { 
            return v2_[index - v1_.size()];
        }
    }
private:
    std::vector<int> v1_, v2_; // Данные хранятся в двух векторах.
};

int main() {
    VectorUnion vec{{1, 2, 3}, {40, 50, 60}};
    
    // Можем работать с vec как с одним
    // большим вектором: {1, 2, 3, 40, 50, 60}.
    // Индексы:           0  1  2   3   4   5.
    std::cout << vec[5]; // Напечатает 60.
}
Поскольку операция [] работает непосредственно с объектами класса, она объявляется только как функция-член. В качестве параметра она принимает индекс — идентификатор элемента, который нужно вернуть. При этом индекс может быть любого типа: как числом, так и строкой.
В приведённом примере перегрузка объявлена со словом const. Это значит, что операция допускает только чтение элементов, и мы не можем их менять. Если нужно обеспечить и чтение, и запись, принято определять два варианта перегрузки: константный и неконстантный.
Неконстантный метод должен возвращать ссылку, чтобы обеспечить прямой доступ к элементу, благодаря чему его можно редактировать.
Константный метод может возвращать либо копию объекта (как выше в примере с int), либо ссылку на него. Второй способ подходит для сложных объектов, так как избавляет от лишнего копирования.
class VectorUnion { 
    int& operator[](std::size_t index) { ... } // Перегрузка для записи.
    const int& operator[](std::size_t index) const { ... } // И для чтения.
};
При перегрузке индекса мы берём на себя ответственность за корректную работу операции. Поэтому важно учитывать случаи, когда ей может быть передан некорректный параметр (например, индекс, выходящий за пределы последовательности). Обработать невалидный индекс можно так.
int& operator[](std::size_t index) {
    if ((index < 0) || (index >= (v1_.size() + v2_.size()))) {
        std::abort(); // Если индекс неверный, завершаем программу.
    }
    if (index < v1_.size()) { 
        return v1_[index]; 
    } else { 
        return v2_[index - v1_.size()];
    }
}
Если в качестве индексов используются строки, мы получаем контейнер, в котором информация хранится в виде пар «строковый индекс — значение» или «ключ — значение». Такая структура данных называется словарём. Словари достаточно часто используются в программировании, в том числе в C++. Подробнее о них — в следующем спринте.
До этого мы рассматривали случаи, когда операция [] принимала один индекс. Начиная со стандарта C++23, ей можно передавать сразу несколько индексов, записывая их через запятую. Это свойство удобно использовать при создании матриц — объектов, хранящих данные в виде таблицы.
class Matrix{
public: 
    Matrix(std::vector<int> data, int stride): 
           data_(data), stride_(stride) {}
    
    // Перегрузка с двумя индексами.
    int& operator[](int col, int row) {
        return data_[col + stride_ * row];
    }
private:
    std::vector<int> data_; // Элементы хранятся в одном векторе.
    int stride_; // Ширина таблицы (количество столбцов).
};
Этот пример также хорошо иллюстрирует принятый подход к записи таблиц в память компьютера. Вместо того чтобы хранить столбцы и строки, таблицу «разворачивают» в единую последовательность элементов и сохраняют исходное значение ширины (stride_). Позже его используют, чтобы найти нужный элемент по номерам строки и столбца: data_[col + stride_ * row].
Далее созданную матрицу можно использовать для записи, чтения и изменения элементов.
// Матрица (таблица) чисел:
// 11 12 13 14
// 21 22 23 24
// 31 32 33 34
Matrix matrix({11, 12, 13, 14, 21, 22, 23, 24, 31, 32, 33, 34}, 4);

// Берём второй элемент в первой строке (23).
std::cout << matrix[2, 1] << std::endl;

// Так как возвращается ссылка, можем
// менять элемент матрицы:
matrix[0, 0] = 100;
Перегрузка операции вызова функции
C++ позволяет перегружать и более необычные операции. Например, круглые скобки (), вызывающие объект как функцию.
struct Linear {
    double a, b;
    
    // Перегрузка операции.
    double operator()(double x) const {
        return a * x + b;
    }
};
 int main() {
    Linear func{2, 1};    // Представляет функцию 2x + 1.

    double f_0 = func(0); // Посчитает: 2 * 0 + 1 = 1.
    double f_5 = func(5); // Посчитает: 2 * 5 + 1 = 11.
}
В этом примере перегрузка позволяет использовать объект func аналогично функциям. Подобные объекты в C++ называются функторами (хотя в других языках этот термин имеет другое значение). Мы расскажем о функторах более подробно в теме про лямбда-функции.
Дополнительные возможности: пользовательские литералы
Литерал — это константа, записанная в коде. Литералы бывают:
целочисленные (например, -42, 55UL, 0x1f);
с плавающей точкой (например, 3.14, -1.e-15);
строковые (например, "Hello, Oleg");
символьные (например, 'a', '\0').
Ещё есть пользовательские литералы. В этом случае к стандартному литералу добавляется суффикс. Например, так можно получить строку типа std::string: "Hello, Oleg"s (суффикс s). А так — 15 миллисекунд: 15ms (суффикс ms). Для использования этих литералов нужно написать using namespace std::literals.
Можно создавать собственные пользовательские литералы, определяя новые суффиксы. Но есть одно требование — они должны начинаться с подчеркивания _.
// Литерал для задания килобайтов.
unsigned long long operator"" _Kb(unsigned long long x) { return x * 1024; }

// Литерал для задания мегабайтов.
unsigned long long operator"" _Mb(unsigned long long x) { return x * 1024 * 1024; }

// Литерал, обращающий строку.
std::string operator"" _Rev(const char* ptr, size_t size) {
    std::string str(ptr, size);
    std::reverse(str.begin(), str.end());
    return str;
}

int main() {
    // 10 килобайт.
    std::cout << 10_Kb << std::endl; // 10 * 1024 = 10240.

    // Сколько килобайт в 500 мегабайтах:
    std::cout << (500_Mb / 1_Kb) << std::endl; // 512000.
    
    std::cout << "telefon"_Rev << std::endl; // nofelet.
}
C++ позволяет создавать пользовательские литералы для целых значений, значений с плавающей точкой и строк. Например, вы можете создать литерал для удобного получения QString. Но в реальных программах эта возможность используется нечасто, поэтому не будем на ней останавливаться.

## Дополнительные концепции перегрузки операций

### Правила и ограничения перегрузки операций

#### Операции, которые НЕЛЬЗЯ перегружать
Важно помнить, что не все операции можно перегружать в C++:
- `::` — разрешение области видимости
- `.` — доступ к члену объекта
- `.*` — доступ к члену через указатель на член объекта
- `?:` — тернарный условный оператор
- `sizeof` — получение размера типа
- `typeid` — получение информации о типе

#### Операции, которые можно перегружать только как методы класса
Некоторые операции могут быть перегружены только как функции-члены класса:
- `=` — присваивание
- `[]` — индексирование
- `()` — вызов функции
- `->` — доступ к члену через указатель

```cpp
class MyClass {
public:
    // Правильно - как метод класса
    MyClass& operator=(const MyClass& other);
    int& operator[](size_t index);
    int operator()(int x, int y);
    
    // Неправильно - нельзя как свободную функцию
    // friend MyClass& operator=(MyClass& lhs, const MyClass& rhs); // Ошибка!
};
```

### Идиомы перегрузки операций

#### Идиома Copy-and-Swap для оператора присваивания
Безопасный способ реализации оператора присваивания:

```cpp
class MyClass {
private:
    int* data;
    size_t size;
    
public:
    // Конструктор копирования
    MyClass(const MyClass& other) : data(new int[other.size]), size(other.size) {
        std::copy(other.data, other.data + size, data);
    }
    
    // Функция swap
    void swap(MyClass& other) noexcept {
        std::swap(data, other.data);
        std::swap(size, other.size);
    }
    
    // Оператор присваивания через copy-and-swap
    MyClass& operator=(MyClass other) {  // Передача по значению!
        swap(other);
        return *this;
    }
    
    ~MyClass() { delete[] data; }
};
```

#### Каноническая форма класса (Rule of Three/Five)
При перегрузке оператора присваивания часто нужно также определить:

```cpp
class Resource {
private:
    int* ptr;
    
public:
    // Конструктор
    Resource(int value) : ptr(new int(value)) {}
    
    // 1. Деструктор
    ~Resource() { delete ptr; }
    
    // 2. Конструктор копирования
    Resource(const Resource& other) : ptr(new int(*other.ptr)) {}
    
    // 3. Оператор присваивания
    Resource& operator=(const Resource& other) {
        if (this != &other) {
            delete ptr;
            ptr = new int(*other.ptr);
        }
        return *this;
    }
    
    // C++11: 4. Конструктор перемещения
    Resource(Resource&& other) noexcept : ptr(other.ptr) {
        other.ptr = nullptr;
    }
    
    // C++11: 5. Оператор присваивания перемещения
    Resource& operator=(Resource&& other) noexcept {
        if (this != &other) {
            delete ptr;
            ptr = other.ptr;
            other.ptr = nullptr;
        }
        return *this;
    }
};
```

### Перегрузка операций для работы с умными указателями

```cpp
template<typename T>
class SmartPtr {
private:
    T* ptr;
    
public:
    explicit SmartPtr(T* p = nullptr) : ptr(p) {}
    ~SmartPtr() { delete ptr; }
    
    // Запрещаем копирование
    SmartPtr(const SmartPtr&) = delete;
    SmartPtr& operator=(const SmartPtr&) = delete;
    
    // Разрешаем перемещение
    SmartPtr(SmartPtr&& other) noexcept : ptr(other.ptr) {
        other.ptr = nullptr;
    }
    
    SmartPtr& operator=(SmartPtr&& other) noexcept {
        if (this != &other) {
            delete ptr;
            ptr = other.ptr;
            other.ptr = nullptr;
        }
        return *this;
    }
    
    // Операторы доступа
    T& operator*() const { return *ptr; }
    T* operator->() const { return ptr; }
    
    // Проверка на null
    explicit operator bool() const { return ptr != nullptr; }
    
    // Освобождение ресурса
    T* release() {
        T* temp = ptr;
        ptr = nullptr;
        return temp;
    }
};
```

### Перегрузка операций для контейнеров

#### Пример класса-обёртки для std::vector с дополнительной функциональностью

```cpp
template<typename T>
class SafeVector {
private:
    std::vector<T> data;
    
public:
    // Конструкторы
    SafeVector() = default;
    SafeVector(std::initializer_list<T> init) : data(init) {}
    SafeVector(size_t size, const T& value = T{}) : data(size, value) {}
    
    // Безопасный доступ по индексу
    T& operator[](size_t index) {
        if (index >= data.size()) {
            throw std::out_of_range("Index out of range");
        }
        return data[index];
    }
    
    const T& operator[](size_t index) const {
        if (index >= data.size()) {
            throw std::out_of_range("Index out of range");
        }
        return data[index];
    }
    
    // Арифметические операции для векторов
    SafeVector& operator+=(const SafeVector& other) {
        if (data.size() != other.data.size()) {
            throw std::invalid_argument("Vector sizes must match");
        }
        for (size_t i = 0; i < data.size(); ++i) {
            data[i] += other.data[i];
        }
        return *this;
    }
    
    SafeVector operator+(const SafeVector& other) const {
        SafeVector result = *this;
        result += other;
        return result;
    }
    
    // Скалярное произведение
    T operator*(const SafeVector& other) const {
        if (data.size() != other.data.size()) {
            throw std::invalid_argument("Vector sizes must match");
        }
        T result = T{};
        for (size_t i = 0; i < data.size(); ++i) {
            result += data[i] * other.data[i];
        }
        return result;
    }
    
    // Умножение на скаляр
    SafeVector& operator*=(const T& scalar) {
        for (auto& element : data) {
            element *= scalar;
        }
        return *this;
    }
    
    // Операции сравнения
    bool operator==(const SafeVector& other) const {
        return data == other.data;
    }
    
    bool operator!=(const SafeVector& other) const {
        return !(*this == other);
    }
    
    // Вывод в поток
    friend std::ostream& operator<<(std::ostream& os, const SafeVector& vec) {
        os << "[";
        for (size_t i = 0; i < vec.data.size(); ++i) {
            if (i > 0) os << ", ";
            os << vec.data[i];
        }
        os << "]";
        return os;
    }
    
    // Полезные методы
    size_t size() const { return data.size(); }
    bool empty() const { return data.empty(); }
    void push_back(const T& value) { data.push_back(value); }
};

// Умножение на скаляр (скаляр слева)
template<typename T>
SafeVector<T> operator*(const T& scalar, const SafeVector<T>& vec) {
    SafeVector<T> result = vec;
    result *= scalar;
    return result;
}
```

### Практические советы

#### 1. Симметричность операций
Если перегружаете бинарную операцию, подумайте о симметричности:

```cpp
class Number {
    int value;
public:
    Number(int v) : value(v) {}
    
    // Метод класса - работает только для Number + Number
    Number operator+(const Number& other) const {
        return Number(value + other.value);
    }
};

// Свободная функция - работает для Number + int и int + Number
Number operator+(const Number& lhs, int rhs) {
    return Number(lhs.value + rhs);
}

Number operator+(int lhs, const Number& rhs) {
    return Number(lhs + rhs.value);
}
```

#### 2. Последовательность реализации операций
Реализуйте операции в логическом порядке:

```cpp
class MyClass {
public:
    // Сначала основные операции
    MyClass& operator+=(const MyClass& other);
    MyClass& operator-=(const MyClass& other);
    
    // Потом производные через основные
    MyClass operator+(const MyClass& other) const {
        MyClass result = *this;
        result += other;
        return result;
    }
    
    MyClass operator-(const MyClass& other) const {
        MyClass result = *this;
        result -= other;
        return result;
    }
};
```

#### 3. Производительность
Помните о производительности при перегрузке операций:

```cpp
// Неэффективно - создаёт временные объекты
Matrix result = a + b + c + d;

// Эффективнее - используйте составные операции
Matrix result = a;
result += b;
result += c;
result += d;

// Или предоставьте специальные методы
Matrix result = Matrix::sum({a, b, c, d});
```

Эти дополнения помогут лучше понять принципы и лучшие практики перегрузки операций в C++.

