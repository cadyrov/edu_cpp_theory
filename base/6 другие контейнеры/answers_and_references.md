# Ответы на тест "Другие контейнеры в C++" с указанием номеров строк в теории

## Вопрос 1: **B** - LIFO (Last In, First Out)
**Ссылка на теорию:** строки 28-30
*Объяснение:* Стек реализует принцип LIFO - последний добавленный элемент удаляется первым.

## Вопрос 2: **C** - 30
**Ссылка на теорию:** строки 15-25
*Объяснение:* Метод top() возвращает последний добавленный элемент (вершину стека), это 30.

## Вопрос 3: **C** - std::deque
**Ссылка на теорию:** строки 155-160
*Объяснение:* По умолчанию std::stack использует std::deque как базовый контейнер.

## Вопрос 4: **C** - Неопределенное поведение
**Ссылка на теорию:** строки 15-25
*Объяснение:* Вызов pop() на пустом стеке приводит к неопределенному поведению.

## Вопрос 5: **B** - FIFO (First In, First Out)
**Ссылка на теорию:** строки 55-58
*Объяснение:* Очередь реализует принцип FIFO - первый добавленный элемент удаляется первым.

## Вопрос 6: **A** - 1 3
**Ссылка на теорию:** строки 62-70
*Объяснение:* front() возвращает первый элемент (1), back() возвращает последний (3).

## Вопрос 7: **C** - std::vector
**Ссылка на теорию:** строки 165-170
*Объяснение:* std::vector не подходит для queue, так как удаление первого элемента неэффективно.

## Вопрос 8: **A** - Double-ended queue
**Ссылка на теорию:** строки 90-92
*Объяснение:* deque означает "double-ended queue" - двусторонняя очередь.

## Вопрос 9: **B** - 2 3
**Ссылка на теорию:** строки 92-100
*Объяснение:* После операций: push_front(2) делает 2 первым, push_back(3) делает 3 последним.

## Вопрос 10: **C** - Вставка в начало и конец
**Ссылка на теорию:** строки 92-100
*Объяснение:* std::deque эффективно поддерживает операции в начале и конце контейнера.

## Вопрос 11: **B** - Ищет элемент в отсортированном массиве
**Ссылка на теорию:** строки 175-180
*Объяснение:* Бинарный поиск работает только с отсортированными данными.

## Вопрос 12: **C** - O(log n)
**Ссылка на теорию:** строки 220-225
*Объяснение:* Бинарный поиск имеет логарифмическую временную сложность.

## Вопрос 13: **B** - false
**Ссылка на теорию:** строки 300-310
*Объяснение:* Элемента 4 нет в массиве, поэтому binary_search вернет false.

## Вопрос 14: **B** - Находит первый элемент не меньше заданного
**Ссылка на теорию:** строки 260-270
*Объяснение:* lower_bound ищет первый элемент >= заданного значения.

## Вопрос 15: **B** - 1
**Ссылка на теорию:** строки 270-280
*Объяснение:* Первая двойка находится на позиции 1 (индекс начинается с 0).

## Вопрос 16: **B** - lower_bound ищет >=, upper_bound ищет >
**Ссылка на теорию:** строки 310-320
*Объяснение:* lower_bound ищет >=, upper_bound ищет строго больше.

## Вопрос 17: **B** - Возвращает диапазон равных элементов
**Ссылка на теорию:** строки 330-340
*Объяснение:* equal_range возвращает пару итераторов, ограничивающих диапазон равных элементов.

## Вопрос 18: **B** - Функция, вызывающая сама себя
**Ссылка на теорию:** строки 380-385
*Объяснение:* Рекурсия - это когда функция вызывает сама себя.

## Вопрос 19: **B** - Базовый случай (корнер-кейс)
**Ссылка на теорию:** строки 415-420
*Объяснение:* Базовый случай необходим для завершения рекурсии.

## Вопрос 20: **C** - 24
**Ссылка на теорию:** строки 390-405
*Объяснение:* factorial(4) = 4 * 3 * 2 * 1 = 24.

## Вопрос 21: **A** - Разделяй и властвуй
**Ссылка на теорию:** строки 440-445
*Объяснение:* Сортировка слиянием использует принцип "разделяй и властвуй".

## Вопрос 22: **C** - O(n log n)
**Ссылка на теорию:** строки 450-455
*Объяснение:* Сортировка слиянием имеет временную сложность O(n log n).

## Вопрос 23: **B** - Сортировка, сохраняющая порядок равных элементов
**Ссылка на теорию:** строки 455-457
*Объяснение:* Стабильная сортировка не меняет относительный порядок равных элементов.

## Вопрос 24: **C** - 5
**Ссылка на теорию:** строки 580-590
*Объяснение:* priority_queue по умолчанию реализует max-heap, поэтому top() вернет максимальный элемент.

## Вопрос 25: **B** - `std::priority_queue<int, std::vector<int>, std::greater<int>>`
**Ссылка на теорию:** строки 590-600
*Объяснение:* Для min-heap нужно использовать компаратор std::greater.

## Вопрос 26: **B** - Конструирует элемент на месте
**Ссылка на теорию:** строки 550-560
*Объяснение:* emplace конструирует объект непосредственно в контейнере.

## Вопрос 27: **B** - 3
**Ссылка на теорию:** строки 270-280
*Объяснение:* lower_bound для значения 3 вернет итератор на первую тройку.

## Вопрос 28: **B** - Бинарный поиск
**Ссылка на теорию:** строки 220-230
*Объяснение:* Для больших отсортированных массивов бинарный поиск значительно эффективнее.

## Вопрос 29: **B** - Количество вложенных вызовов
**Ссылка на теорию:** строки 430-435
*Объяснение:* Глубина рекурсии - это количество вложенных вызовов функции.

## Вопрос 30: **C** - 3
**Ссылка на теорию:** строки 330-340
*Объяснение:* В массиве три элемента равных 3, distance между границами равен 3.

## Вопрос 31: **B** - std::stack
**Ссылка на теорию:** строки 35-50
*Объяснение:* Обратная польская запись требует стека для хранения операндов.

## Вопрос 32: **B** - Создастся stack<int>
**Ссылка на теорию:** строки 470-480
*Объяснение:* В C++17 автоматический вывод типов (CTAD) создаст stack<int>.

## Вопрос 33: **B** - Быстрее вставка/удаление в начале
**Ссылка на теорию:** строки 110-120
*Объяснение:* deque оптимизирован для операций в начале и конце, в отличие от vector.

## Вопрос 34: **B** - Находит k наименьших элементов
**Ссылка на теорию:** строки 720-730
*Объяснение:* partial_sort частично сортирует массив, помещая k наименьших элементов в начало.

## Вопрос 35: **B** - std::stable_sort
**Ссылка на теорию:** строки 710-720
*Объяснение:* std::stable_sort гарантированно является стабильной сортировкой.

## Вопрос 36: **B** - 5
**Ссылка на теорию:** строки 730-740
*Объяснение:* nth_element помещает n-й элемент в правильную позицию, это будет 5.

## Вопрос 37: **B** - Рекурсивный вызов как последняя операция
**Ссылка на теорию:** строки 650-660
*Объяснение:* Хвостовая рекурсия - когда рекурсивный вызов является последней операцией.

## Вопрос 38: **A** - `#include <algorithm>`
**Ссылка на теорию:** строки 500-510
*Объяснение:* std::clamp находится в заголовочном файле <algorithm>.

## Вопрос 39: **B** - Берет случайную выборку элементов
**Ссылка на теорию:** строки 510-520
*Объяснение:* std::sample создает случайную выборку заданного размера из диапазона.

## Вопрос 40: **B** - 10
**Ссылка на теорию:** строки 500-510
*Объяснение:* clamp(15, 5, 10) ограничивает 15 диапазоном [5, 10], результат 10.

---

## Статистика теста:
- **Общее количество вопросов:** 40
- **Вопросы с примерами кода:** 24 (60%)
- **Вопросы по основам контейнеров:** 17 (42.5%)
- **Вопросы по алгоритмам:** 12 (30%)
- **Вопросы по рекурсии:** 6 (15%)
- **Вопросы по C++17:** 5 (12.5%)

## Покрытие тем:
1. **Контейнеры-адаптеры (stack, queue)** - вопросы 1-7
2. **Deque и его особенности** - вопросы 8-10
3. **Алгоритмы поиска** - вопросы 11-17
4. **Рекурсия и принципы** - вопросы 18-23
5. **Priority queue и продвинутые техники** - вопросы 24-27
6. **Оптимизация и производительность** - вопросы 28-34
7. **Современные алгоритмы сортировки** - вопросы 35-37
8. **C++17 возможности** - вопросы 32, 38-40
9. **Практические применения** - вопросы 31, 33

## Рекомендации по изучению:
- Особое внимание уделить принципам LIFO/FIFO
- Изучить различия между контейнерами-адаптерами
- Понять алгоритмы бинарного поиска и их применение
- Освоить основы рекурсии и оптимизации
- Изучить новые возможности C++17 для контейнеров 