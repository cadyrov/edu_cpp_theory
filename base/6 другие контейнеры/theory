Стек, очередь, дек
Вы уже познакомились с контейнерами vector, map, set. В этом уроке вы изучите новые. Эти контейнеры не менее важные, хоть и с более простым интерфейсом.
В своих принципах работы с данными они отражают процессы реального мира и часто используются для решения разных задач. Например, в реализации операционных систем и систем обработки данных.
Стек
Стек — это еще один шаблонный контейнер. В C++ он представлен классом std::stack. В этом контейнере изменять можно только последний элемент:
push — добавление элемента;
pop — удаление последнего элемента;
top — чтение или изменение последнего элемента.
Последний элемент называется вершиной стека. Можно представить стек как башню из кубиков, в которой можно что-то делать только с верхним.
// Создание пустого стека с элементами типа int.
std::stack<int> my_stack;
// Можно добавлять элементы на вершину стека.
my_stack.push(100);
my_stack.push(200);

// Или посмотреть, какой элемент сейчас сверху. Это не удаляет его из стека.
std::cout << my_stack.top() << std::endl; // 200.

// И удалить последний элемент.
my_stack.pop();

// Теперь остался только один элемент — 100.
std::cout << my_stack.size() << " "s << my_stack.top() << std::endl; // 1 100

// Так можно поменять вершину.
my_stack.top() = 42;
Этот принцип хранения называется LIFO. Элементы, добавленные на вершину стека, оказываются первыми на очереди к удалению. Такой подход работы с данными часто встречается и в алгоритмах, и в жизни.

Не всегда очевидно, что для решения той или иной задачи подходит стек. Вот представьте, что на проводе сидят птицы разных цветов. Если две одинаковые по цвету птицы оказываются соседними, то они улетают. Процесс повторяется, пока есть пара одинаковых рядом. В итоге останутся только птицы без соседей такого же цвета. Сколько их останется?

Стек подходит для этой задачи, так как в любой момент важен только цвет последней, неудаленной птицы. Обрабатывать данные можно последовательно, а одинаковые цвета сразу удалять из стека.
// В этом стеке будут храниться цвета неудалённых птиц.
std::stack<int> birds;

int color;
while (std::cin >> color) {
    // Для текущей птицы цвета color.
    // Если её цвет совпадает с предыдущим цветом, 
    // нужно удалить предыдущий цвет и не добавлять текущий.
    if (!birds.empty() && birds.top() == color) {
        birds.pop();
    } else {
        // Если предыдущий не совпадает (или его нет), нужно добавить текущий.
        birds.push(color);
    }
}
// В стеке хранятся неудалённые птицы (цвета). Их количество и есть ответ.
std::cout << birds.size() << std::endl;
Такой алгоритм будет эффективно решать задачу: он пробегает по входным данным один раз и сразу удаляет всех птиц, которые должны быть удалены.
Очередь
Кроме LIFO, используется принцип FIFO. Элементы, добавленные первыми, первыми же и будут удалены. Этот принцип можно проиллюстрировать на примере очереди покупателей в магазине.

Неслучайно контейнер, реализующий принцип FIFO, называется queue (англ. «очередь»).
В очереди доступны операции вставки элементов в конец (push) и их удаления из начала (pop).
// Создание пустой очереди с элементами типа int.
std::queue<int> queue;
// Можно добавлять элементы в конец очереди.
queue.push(100);
queue.push(200);
// Или посмотреть в начале. Это не удаляет элемент из очереди.
std::cout << queue.front() << std::endl; // 100.
// И удалить первый элемент.
queue.pop();
// Теперь остался только один элемент.
std::cout << queue.size() << " "s << queue.front() << std::endl; // 1 200
Важное применение такого контейнера — очередь задач. Это может быть что угодно: копирование файла, загрузка фотографии, вычисление, открытие программы. Допустим, что у задачи есть метод bool Finished(), чтобы проверять, закончена она или нет. И есть метод void DoSomeWork(), чтобы сделать очередную часть работы. Можно сделать класс — планировщик задач и добавлять в него задачи, а он будет последовательно выполнять их, справедливо распределяя между ними время.
template <class Task>
class Scheduler {
public:
    void PushTask(const Task& task) {
        // При добавлении новой задачи добавляем её в конец очереди.
        queue_.push(task);
    }
    
    bool DoWork() {
        if (queue_.empty()) {
            // Если задач нет, сообщаем, что вся работа выполнена.
            return false;
        }
        
        // Берём первую задачу в очереди и делаем её часть.
        auto task = queue_.front();
        queue.pop();
        task.DoSomeWork();
        
        // Если задача не выполнена, добавляем её в конец очереди.
        if (!task.Finished()) {
            queue_.push(task);
        }
        
        return true;
    }
  
private:
    std::queue<Task> queue_;
};
Такой алгоритм планирования называется round-robin. Все задачи выполняются по очереди. Например, этот алгоритм можно было бы использовать в операционной системе для распределения вычислительных ресурсов между процессами.

Двусторонняя очередь, или дек
Двусторонняя очередь — это очередь, в которой добавлять и удалять элементы можно с обоих концов. В C++ контейнер std::deque (от англ. double-ended queue — «дек», «двусторонняя очередь») реализует этот интерфейс.
std::deque<int> deque;
// Такой же интерфейс, как у вектора для работы с последними элементами.
deque.push_back(2);
// Но ещё есть эффективные методы для добавления и удаления первых элементов.
deque.push_front(1);
std::cout << deque.front() << " "s << deque.back() << std::endl; // 1 2

// Удалим последний элемент. Останется всего один: начало и конец одинаковые.
deque.pop_back();
std::cout << deque.front() << " "s << deque.back() << std::endl; // 1 1

std::deque позволяет изменять элементы как в начале, так и в конце, значит, можно использовать std::deque вместо стека или очереди. Например, если использовать только методы push_back и pop_front, то так мы работаем с деком как с обычной очередью.
Ещё один контейнер в C++, подходящий под интерфейс двухсторонней очереди, — std::list. Это двусвязный список, который состоит из последовательности элементов, связанных друг с другом указателями.

Двусвязный список можно использовать и как очередь, и как стек, и как двустороннюю очередь — он позволяет эффективно работать с первым и последним элементом. Но на практике это не лучший выбор: std::deque часто оказывается производительнее.
Как реализован std::deque и почему он быстрее, чем std::list? std::deque можно представить как список, где в каждой части хранится не один (как в обычном std::list), а несколько элементов. За счет более плотного расположения элементов он оказывается быстрее. В отличие от std::list, элементы дека добавляются и удаляются только в начале и конце. А значит, максимум только две части дека будут не заполнены — первая и последняя. В некотором смысле std::deque — это гибрид std::list и std::vector.
Подробнее о std::stack и std::queue
Стек поддерживает три операции — добавление, удаление вершины и её просмотр. Вместо std::stack подошёл бы std::vector.
std::stack можно заменить на std::vector — там тоже есть методы для добавления и удаления элементов с конца (push_back и pop_back). Получается, stack — это урезанная версия vector? На самом деле std::stack может быть вектором «под капотом».
В стандартной библиотеке C++ не существует контейнеров std::stack и std::queue. Это адаптеры, которые используют подходящие контейнеры, а нам предоставляют интерфейс, соответствующий стеку или очереди.
std::vector — подходящий контейнер для std::stack, так как он эффективно реализует нужные для стека методы: вставку и удаление элементов с конца. Другие подходящие и стандартные контейнеры — std::list и std::deque.
// Создание стека с разными контейнерами «под капотом».
std::stack<int, std::vector<int>> stack1; // Это вектор с интерфейсом стека.
stack1.push(1); // «Под капотом» вызывается метод вектора push_back.

std::stack<int, std::deque<int>> stack2; // deque используется по умолчанию.
std::stack<int, std::list<int>> stack3;
Для std::queue подходящими контейнерами являются std::list и std::deque. Обратите внимание: std::vector не подходит для очереди, так как удаление первого элемента вектора неэффективно.
// Создание очереди с разными контейнерами «под капотом».
std::queue<int, std::deque<int>> queue1; // deque используется по умолчанию.
std::queue<int, std::list<int>> queue2;
std::list тоже можно использовать как двустороннюю очередь — в двусвязном списке можно эффективно манипулировать элементами в начале или в конце. Но на практике std::deque используется как очередь (или двусторонняя очередь) чаще, чем std::list, по причине лучшей производительности. Поэтому же std::deque используется по умолчанию для адаптеров std::queue и std::stack.
Бинарный поиск
Вы уже знакомы с контейнерами std::map и std::set, в которых можно эффективно искать элементы. При некоторых условиях можно быстрее и эффективнее делать это в std::vector. Условия простые: элементы вектора должны быть отсортированы. В этом уроке вы познакомитесь с алгоритмом бинарного поиска, с помощью которого осуществляется поиск в отсортированных данных, и реализуете его на практике.
Линейный поиск элемента в векторе
Прежде чем перейти к алгоритму бинарного поиска, давайте вспомним, как устроен обычный алгоритм, с которым вы уже знакомы.

Предположим, что есть std::vector с целыми числами. Нужно понять, есть ли в этом векторе число x. Если нет никаких ограничений на расположение элементов, то можно лишь пройтись по всем числам и сравнить с искомым. Это называется линейным поиском.
bool LinearSearch(const std::vector<int>& arr, const int x) {
    // Проходим по всему массиву.
    for (const int num : arr) {
        // Если находим элемент, равный x, возвращаем true.
        if (num == x) {
            return true;
        }
    }
    // Если в векторе нет такого элемента, возвращаем false.
    return false;
}
Для упрощения функция LinearSearch возвращает bool — проверяет, есть нужный элемент или нет. Можно модифицировать эту функцию и возвращать итератор на найденный элемент, равный x. Также можно добавить в эту функцию поддержку произвольного компаратора: получатся алгоритмы std::find и std::find_if.
Если данных немного или поиск выполняется редко, алгоритм линейного поиска будет подходящим решением. В ситуации, когда важна эффективность поиска, необходимо использовать что-то другое (например, контейнер std::set).
Линейный поиск проходит по контейнеру. Если повезёт, он быстро найдет искомый элемент. В худшем случае придется проверить все элементы вектора.
Идея поиска в отсортированном векторе
Линейный поиск делает проверки, проходя по вектору. С каждой проверкой он исключает из рассмотрения только один элемент, пока не найдёт нужный. А что, если данные в векторе отсортированы как главы в книге?

Рассмотрим элемент отсортированного вектора arr с индексом i. Выполним проверку: x < arr[i].
std::vector<int> arr;

if (x < arr[i]) {
    // Ищем x среди индексов 0, ..., i-1.
} else {
    // Ищем x среди индексов i, ..., arr.size() - 1.
}
У проверки два исхода:
true — x меньше arr[i]. А значит, он меньше всех элементов с большими индексами. Можем исключить из рассмотрения все элементы с индексами i, i + 1, … до конца вектора. Теперь x нужно искать среди элементов с индексами от 0 до i - 1.
false — x больше arr[i] либо равен arr[i]. Исключим те индексы, которые рассматривали в первом случае.
Принцип алгоритма бинарного поиска — отсекать максимальное количество элементов за каждую проверку. Но какой элемент проверять в первую очередь? Хорошая идея — проверять середину текущего набора элементов. Тогда в любом случае будет отсечена примерно половина.
Давайте посмотрим, как это будет работать для вектора arr из 6 элементов с индексами от 0 до 5. Середина для вектора из 6 элементов — это элемент с индексом 2, он делит массив на две группы: 0, 1 и 2, 3, 4, 5. Выполним проверку x < arr[2], чтобы узнать, в какой группе находится нужный элемент.
На первом шаге мы исключили 2 индекса и оставили другие 4. Предположим, что остались 2, 3, 4, 5. Поделим их ещё раз пополам. Выберем элемент 3, который поделит элементы на две группы: первая будет состоять всего из одного элемента с индексом 2, вторая из трёх — с индексами 3, 4, 5. Проверка позволит понять, в какой из этих групп будет искомый элемент.
Если победила первая группа (та, что с двойкой), то ответ найден. Если нет, будет нужна ещё одна проверка. Итак, наш поиск сделал три шага. Это в два раза лучше, чем если бы мы использовали алгоритм линейного поиска. Но такой выигрыш — далеко не предел.
Обратите внимание: чем больше количество элементов, тем очевиднее эффективность бинарного поиска в сравнении с линейным.
Например, возьмём типичный файл с подкастом в контейнере .mp4, который хранит аудиоданные кусочками (сэмплами). Для девяносто минутного файла их может быть порядка 250 тысяч. Для перемотки к нужному моменту времени нужно найти соответствующий семпл. Бинарному поиску потребуется около 18 шагов для поиска в 250 тысячах семплов.
Алгоритм бинарного поиска
С написанием кода алгоритма помогут два понятия: инвариант и полуинтервал.
Понятие инварианта вам уже знакомо. Это некоторое утверждение, которое верно в определённый момент выполнения программы.
Полуинтервал [a, b) — это промежуток от a (включительно) до b (не включительно). Например, полуинтервал [10, 15) — это числа 10, 11, 12, 13, 14. Можно охарактеризовать эти числа следующим неравенством: где числа x такие, что a <= x && x < b. Слева нестрогое неравенство, справа — строгое. Полуинтервалы могут формироваться не только числами, но и, например, итераторами: элементы вектора — это полуинтервал от begin() до end().
Для описания алгоритма удобно пользоваться полуинтервалами индексов вида [a, b).
Давайте представим, что алгоритм бинарного поиска ищет в векторе arr элемент x. Нам нужен индекс элемента, который может быть числом от 0 до arr.size() - 1. Иными словами, индекс находится в полуинтервале [0, arr.size()).
Обозначим полуинтервал [a, b). Изначально a = 0, b = arr.size(). На каждом шаге алгоритма будем сокращать интервал поиска, меняя либо a, либо b. Для этого возьмём середину между a и b. Программно её можно вычислить так: mid = (a + b) / 2. Как вы знаете, деление целых чисел всегда даёт целое число. Пример: для полуинтервала [4, 9) серединой будет 6 = (4 + 9) / 2.
mid разделяет полуинтервал на две половины: [a, mid), [mid, b). Чтобы понять, в какой находится элемент x, сравним его с arr[mid]. В зависимости от результата сравнения поменяем либо a, либо b и перейдём к следующему шагу алгоритма.
При таком подходе будет выполняться инвариант: если x есть в векторе, то он находится на полуинтервале [a, b).
Когда остался только один вариант, необходимо убедиться, тот ли это индекс, который мы искали, и возвратить ответ. Получается такой алгоритм:
// Возвратим индекс элемента в векторе или nullopt, если не нашли его.
std::optional<size_t> BinarySearch(const std::vector<int>& arr, const int x) {
    size_t a = 0;
    size_t b = arr.size();
    
    // Пока полуинтервал содержит два числа или больше.
    while (b - a >= 2) {
        // Инвариант: если x есть в векторе arr,
        // то он лежит между arr[a] и arr[b - 1].
    
        // Считаем середину полуинтервала.
        const size_t mid = (a + b) / 2;
        
        // Иначе — нужно понять, в какой половине может быть x.
        if (x < arr[mid]) {
            // x в левой половине. Меняем b. 
            // Получим полуинтервал [a, mid).
            b = mid; 
        } else {
            // x в правой половине. Меняем a. 
            // Получим полуинтервал [mid, b).
            a = mid;
        }
    }
    
    // На полуинтервале осталось одно число.
    // Проверим: то ли это, что мы искали.
    if (a == b || arr[a] != x) {
        // Не нашли :(
        return std::nullopt;
    }
    
    return arr[a];
}
Важная идея алгоритма бинарного поиска — использование информации о данных для максимально эффективной работы. В разобранном нами случае для быстрого уменьшения полуинтервала поиска используются отсортированные данные. Иначе алгоритм может работать неправильно и возвращать результат, которому нельзя доверять.
На самом деле алгоритм бинарного поиска не требует, чтобы данные были полностью отсортированы. В процессе работы элементы вектора сравниваются не друг с другом, а только с искомым элементом x. Достаточно, чтобы они были отсортированы относительно элемента x. То есть сначала в векторе идут элементы меньше x, потом равные x, а потом те, что больше x. Такие данные называются разделенными относительно x. И для разделенного относительно x вектора бинарный поиск элемента x будет работать верно.
Бинарный поиск в контейнерах
В предыдущем уроке вы познакомились с алгоритмом бинарного поиска. Он использует знание о том, что данные отсортированы, для быстрого поиска элемента в массиве.
Этот урок расширит ваш инструментарий для работы с отсортированными данными. Вы научитесь эффективно искать интервалы в отсортированных массивах, а также в контейнерах std::map и std::set.
Бинарный поиск в стандартной библиотеке
В стандартной библиотеке C++ бинарный поиск реализован функцией std::binary_search. Она принимает на вход итераторы на начало и конец диапазона поиска, а ещё искомый элемент и возвращает true, если элемент есть в заданном интервале.
std::vector<int> arr = {1, 3, 3, 5, 6, 7};
std::cout << std::binary_search(arr.begin(), arr.end(), 2) << std::endl; // 0
std::cout << std::binary_search(arr.begin(), arr.end(), 3) << std::endl; // 1
std::cout << std::binary_search(arr.begin(), arr.end(), 5) << std::endl; // 1
Не обязательно всегда искать во всём массиве. Если диапазон с искомым числом известен заранее, то запускать поиск нужно в нём. Так поиск может завершиться за меньшее количество шагов. Например, если в arr уже известно положение числа 3 (pos_first_3) и требуется найти число 4, то можно искать в диапазоне от pos_first_3 до arr.end().
auto pos_first_3 = arr.begin() + 1;
// pos_first_3 указывает на 3 с индексом 1.
// ----------↴
// arr = {1, 3, 3, 5, 6, 7}
std::cout << std::binary_search(pos_first_3, arr.end(), 4) << std::endl; // 0

// А число 1 можно искать от начала массива до pos_first_3.
std::cout << std::binary_search(arr.begin(), pos_first_3, 1) << std::endl; // 1
// Обратите внимание: правая граница не включается в диапазон поиска.
// В диапазоне от arr.begin() до pos_first_3 только элемент 1.
std::cout << std::binary_search(arr.begin(), pos_first_3, 3) << std::endl; // 0
Поиск границы в отсортированном векторе
Бинарный поиск — эффективный алгоритм. Но часто требуется не только определить, имеется ли нужный элемент в массиве, но и найти его позицию. А в случае наличия нескольких одинаковых элементов — найти первый из них.
Представьте, что у вас есть папка с фотографиями, упорядоченными по дате, и вам нужно найти первую фотографию, сделанную 3 сентября 2020 года или позже.

Задачу можно сформулировать так: дан массив, в котором сначала идут фотографии, удовлетворяющие условию < 3 сентября, затем — не удовлетворяющие. Требуется найти первую фотографию, не удовлетворяющую условию < 3 сентября.
Пусть фотографии имеют даты: 3 июня, 5 августа, 28 августа, 4 сентября, 16 сентября. Проверим для этих фотографий условие < 3 сентября:
3 июня — true;
5 августа — true;
28 августа — true;
4 сентября — false;
16 сентября — false.

Мы ищем в этом списке первую фотографию, для которой условие < 3 сентября — false. Другими словами — границу между удовлетворяющими и не удовлетворяющими условию элементами массива. В данном случае это будет фотография, сделанная 4 сентября.
Нижняя граница
Алгоритм нижняя граница (англ. lower bound) ищет первый элемент, не удовлетворяющий неравенству < (другими словами — первый элемент в массиве, больший искомого либо равный ему). Реализация поиска нижней границы похожа на реализацию бинарного поиска из прошлого урока.
В C++ есть соответствующая функция std::lower_bound. На вход она принимает диапазон итераторов и возвращает итератор на искомый элемент. std::lower_bound находит первый элемент, который больше искомого или равен ему.
Так как числа 2 нет в векторе, то результат поиска — первая тройка:
std::vector<int> arr = {0, 0, 1, 3, 3, 5, 7};
// Итератор на первый элемент не меньше 2.
const auto it1 = std::lower_bound(arr.begin(), arr.end(), 2);
// it1 указывает на 3 с индексом 3.
// it1 ------------↴
// arr = {0, 0, 1, 3, 3, 5, 7}
Если в массиве есть искомый элемент, то будет возвращен итератор на него:
// Итератор на первый элемент не меньше 5.
const auto it2 = std::lower_bound(arr.begin(), arr.end(), 5);
// В массиве есть 5. it2 указывает на 5 с индексом 5.
// it2 ------------------↴
// arr = {0, 0, 1, 3, 3, 5, 7}
Попытка найти в arr первый элемент не меньше 9 увенчается arr.end(), потому что такого элемента в массиве нет. Все элементы заданного диапазона меньше 9.
// Итератор на первый элемент не меньше 9.
const auto it3 = std::lower_bound(arr.begin(), arr.end(), 9);
// В arr нет элемента не меньше 9, поэтому it3 указывает на arr.end().
// it3 -----------------------↴
// arr = {0, 0, 1, 3, 3, 5, 7}
Неравенства бывают строгими (<, >) и нестрогими (<=, >=). std::lower_bound ищет первый элемент, который не меньше заданного. Но можно сказать и по-другому: больше либо равен заданному. Похожим образом можно выразить отрицание к любому сравнению. В некоторых случаях удобно говорить в терминах не (с отрицанием), в некоторых — в терминах нестрогих неравенств.
Алгоритм std::lower_bound можно использовать с произвольным компаратором (функцией сравнения). Элемент сравнения передается третьим параметром, компаратор — четвёртым. Функция-компаратор принимает объект перебора и элемент сравнения. Его тип может быть любым.
struct Person {
    std::string name;
    int age;
};

// Вектор, отсортированный по возрасту.
std::vector<Person> persons = ...;

// Вызов lower_bound с произвольным компаратором.
// В данном случае сравнение возраста всегда будет происходить с числом 5.
const auto it = std::lower_bound(
    persons.begin(), persons.end(), 5,
    [](const Person& person, const int age) {
        return person.age < age;
    });

// it — это итератор на первого человека не младше 5 лет.
// Теперь можно, например, узнать, сколько в persons людей младше 5.
std::cout << std::distance(persons.begin(), it) << " людей младше 5 лет"s << std::endl;
В этом примере в массиве persons хранятся структуры Person, отсортированные по полю age. В таком случае можно использовать std::lower_bound для поиска по возрасту. В данном случае используется произвольный компаратор, который сравнивает возраст элементов массива person.age с искомым возрастом age, равным 5.
Верхняя граница
std::lower_bound позволяет найти первый элемент, больший искомого либо равный ему. Если нужно найти строго больший элемент, нужно использовать алгоритм верхняя граница (англ. upper bound). В стандартной библиотеке есть соответствующий алгоритм — std::upper_bound. Работает он так же, как поиск нижней границы, только вместо сравнения < использует <=. Первый элемент, не удовлетворяющий этому условию, будет строго больше искомого.

Вот примеры применения std::upper_bound к тому же массиву arr. При поиске отсутствующей 2 результат будет такой же, как и при вызове std::lower_bound:
std::vector<int> arr = {0, 0, 1, 3, 3, 5, 7};

// Итератор на первый элемент больше 2.
const auto it1 = std::upper_bound(arr.begin(), arr.end(), 2);
// it1 указывает на первую тройку в массиве arr с индексом 3.
// it1 ------------↴
// arr = {0, 0, 1, 3, 3, 5, 7}
Но при поиске существующего в массиве числа upper_bound вернёт другой результат. Этот алгоритм ищет строго большее число:
// Итератор на первый элемент больше 5.
const auto it2 = std::upper_bound(arr.begin(), arr.end(), 5);
// В массиве есть 5, но it2 указывает на 7.
// it2 ---------------------↴
// arr = {0, 0, 1, 3, 3, 5, 7}
Если требуется найти, сколько в массиве arr элементов, равных x, можно использовать комбинацию std::lower_bound и std::upper_bound с этим числом. Также для такой задачи есть специальная функция — std::equal_range(arr.begin(), arr.end(), x). Она возвращает два итератора — нижнюю и верхнюю границы: 
std::vector<int> arr = {1, 2, 3, 3, 4};
auto range3 = std::equal_range(arr.begin(), arr.end(), 3);
// Количество элементов, равных 3.
std::cout << std::distance(range3.first, range3.second) << std::endl; // 2
Нижняя и верхняя границы в контейнерах std::map и std::set
Функциям std::lower_bound и std::upper_bound для эффективной работы требуются итераторы с произвольным доступом (как в векторе). Итераторы std::map и std::set такими не являются, но данные в этих контейнерах отсортированы, поэтому у них есть собственные методы поиска lower_bound и upper_bound.
Поиск нижней и верхней границы у std::set:
std::set<int> s = {0, 1, 3, 5, 7};
std::count << *(s.lower_bound(1)) << ::std::endl; // 1
std::count << *(s.upper_bound(1)) << ::std::endl; // 3
std::count << *(s.lower_bound(4)) << ::std::endl; // 5
std::count << *(s.upper_bound(4)) << ::std::endl; // 5
У std::map методы те же, но ищут они нижнюю и верхнюю границы среди ключей:
std::map<int, int> m = {{0, 0}, {1, 0}, {3, 8}, {5, 0}, {7, 9}};
const auto it = m.upper_bound(1);
std::cout << it->first << ": "s << it->second << std::endl; // 3: 8
std::cout << m.lower_bound(7)->second << std::endl; // 9
std::cout << (m.upper_bound(7) == m.end()) << std::endl; // 1
В методах lower_bound и upper_bound контейнеров std::map и std::set задавать свой компаратор нельзя. Используется компаратор, заданный при создании контейнера.
Эффективный поиск и вставка в std::map и std::set
Вы уже использовали словари для организации счетчиков для подсчета количества вхождений. Например, для определения анаграмм нужно было подсчитать количество букв в двух словах и затем сравнить два словаря с этими данными между собой. Функция, реализующая подсчёт букв в слове, могла выглядеть так:
std::map<char, int> CountChars(const std::string& word) {
    std::map<char, int> counter;
    for (char c : word) {
        auto it = counter.find(c);
        if (it == counter.end()) {
            counter.insert({c, 1});
        } else {
            it->second++;
        }
    }
    return counter;
}
Это верная реализация. Но у неё есть недостаток: если ключа нет в counter, она делает поиск два раза. Первый раз в методе find и второй раз в методе insert, когда std::map ищет место, куда вставить новое значение.
У метода insert контейнеров std::set и std::map есть перегрузка insert(iterator, value), которая принимает на вход итератор. Этот итератор должен указывать на позицию сразу после места, куда должен вставляться key. Можно использовать lower_bound и делать поиск только один раз. Он вернёт или итератор на искомый элемент, или итератор на следующий элемент. Следующий элемент — это как раз то, что ожидается как итератор в insert. В таком случае insert будет знать, куда добавлять новый элемент, и не будет делать поиск.

Такая реализация будет делать поиск в std::map только один раз — в методе lower_bound:
std::map<char, int> CountChars(const std::string& word) {
    std::map<char, int> counter;
    for (char c : word) {
        auto it = counter.lower_bound(c);
        // Если c нет в counter, 
        // то it будет указывать на counter.end() или на следующий элемент.
        if (it == counter.end() || it->first != c) {
            // it используется как подсказка для вставки нового элемента.
            counter.insert(it, {c, 1});
        } else {
            it->second++;
        }
    }
    return counter;
}
Рекурсия: теория и практика
В предыдущих уроках на примере бинарного поиска вы узнали, как можно применять информацию о данных для эффективной работы алгоритма. В этом уроке вы познакомитесь с ещё одной важной техникой построения алгоритмов — рекурсией.
В программировании рекурсия часто используется, когда задачу естественным образом можно разбить на аналогичные подзадачи. Например, это работает с сортировкой слиянием, которую вам предстоит реализовать в практическом задании.
Что такое рекурсия

Рекурсия — это описание объекта или явления внутри самого себя. Пример лингвистической рекурсии: чтобы понять рекурсию, нужно понять рекурсию. Пример физической рекурсии: матрёшка внутри матрёшки.
Рекурсия есть и в программировании. Так, в разработке используются рекурсивные функции. Их так называют потому, что в своей реализации функции используют сами себя.
Рассмотрим работу рекурсивной функции на примере факториала. Функция считает факториал числа n. Факториал числа n (обозначается как n!) — это произведение всех чисел от 1 до n. Например, 5! = 1 * 2 * 3 * 4 * 5 = 120. Можно считать факториал рекурсивно, определяя факториал числа n через факториал n - 1. Например, факториал числа 5 можно выразить через факториал числа 4 следующим образом: 5! = 4! * 5.
int Factorial(int n) {
    // Для n, равного единице, функция сразу возвращает результат.
    if (n == 1) {
        return 1;
    }
    // В остальных случаях факториал n можно 
    // выразить через факториал числа n - 1.
    const int prev_factorial = Factorial(n - 1);
    return n * prev_factorial ;
}
Работать с рекурсивными функциями удобно, но не всегда их использование — это лучший способ реализации алгоритма. Если в рекурсивной функции будет слишком много рекурсивных вызовов, она будет работать медленно.
Реализация функции Factorial не требует сложных вычислений, но в ней содержится множество рекурсивных вызовов. Можно переписать функцию в виде цикла, что позволит избежать рекурсии. Такой вариант будет работать значительно быстрее: 
int Factorial(int n) {
        int result = 1;
        for (int i = 2; i < n; ++i) {
                result = result * i;
        }
        return result;
}
Алгоритм бинарного поиска тоже можно реализовать с помощью рекурсивных функций, потому что на каждом шаге задача сводится к поиску в меньшем массиве (в половине исходного). Однако реализация в виде цикла будет более производительной.
Рекурсивная функция может быть явной (когда она вызывает саму себя напрямую) или неявной (когда вызов происходит из другой функции). Пример неявной рекурсивной функции:
int PrevFactorial(int n) {
    return Factorial(n - 1);
}

int Factorial(int n) {
    if (n == 1) {
        return 1;
    }
    return n * PrevFactorial(n);
}
Функция Factorial в процессе работы вызовет функцию PrevFactorial, которая, в свою очередь, вновь вызовет Factorial. И цепочка повторится.
Помимо рекурсивных функций, в программировании есть рекурсивные структуры данных. Они в своей реализации повторяют сами себя. Одна из популярных структур данных — дерево. В дереве хранится значение и некоторое количество поддеревьев. Пример дерева — структура файловой системы, где внутри папки хранятся другие папки, а в них, в свою очередь, могут быть ещё папки. Для работы с рекурсивными структурами данных применяют рекурсивные функции. Вам предстоит поработать с ними в практической части урока.
Основные принципы рекурсивных алгоритмов
В рекурсивных функциях можно выделить некоторые общие черты. Они построены по схожим принципам:
Корнер-кейс, или базовый случай, — это условие для завершения рекурсии. В какой-то момент цепочка вызовов рекурсивной функции должна закончиться. Это и будет корнер-кейс. Например, в рекурсивной функции Factorial цепочка вызовов прерывается, когда алгоритм достигает значения n == 1.
Рекурсивный вызов — это явный или неявный вызов из функции самой себя. Для функции Factorial рекурсивным вызовом будет Factorial(n - 1).
Действие — это всё, что требуется для перехода от задачи к подзадачам и обратно. В случае Factorial для вычисления Factorial(n) требуется посчитать факториал n - 1 и умножить результат на n. Действием здесь является и переход от меньшей задачи к большей (* n), и переход от большей к меньшей (n - 1).

Ещё один важный принцип при написании рекурсивных функций — принцип убывания рекурсивного параметра. Его смысл в том, что параметры рекурсивной функции должны приближаться к корнер-кейсу. Если этого не делать — цепочка рекурсивных вызовов не сможет закончиться. В примере с функцией Factorial параметр n всегда уменьшается и приближается к корнер-кейсу n == 1.
Несмотря на название «принцип убывания рекурсивного параметра», речь не всегда идет об уменьшении значений параметров. Главное, чтобы они «приближались» к корнер-кейсу.
Сортировка слиянием
В C++ можно использовать рекурсию для сортировки массива. Более того, многие алгоритмы сортировки её используют. Один из таких алгоритмов — сортировка слиянием (англ. merge sort).
Чтобы реализовать этот алгоритм как рекурсивную функцию для сортировки массива, можно разбить исходный массив на две половины и отсортировать каждую из них, а затем объединить две отсортированные половины в один отсортированный массив.
Сортировка половин — это рекурсивные вызовы. Объединение отсортированных массивов в один — действие. Это объединение, центральная часть алгоритма, называется слиянием. Корнер-кейсом в данном алгоритме сортировки будет пустой массив или массив из одного числа. Такие массивы всегда «отсортированы».
В алгоритме сортировки слиянием используется принцип разделяй и властвуй. Это еще одна популярная техника построения алгоритмов. Главная идея этого принципа — сведение задачи к меньшим по размеру подзадачам для их простого решения. Важно, чтобы сведение получалось сделать эффективно. Алгоритмы, использующие принцип «разделяй и властвуй», часто реализуют, используя рекурсию.
Алгоритм сортировки слиянием выглядит так: исходный массив делится пополам и сортируется рекурсивными вызовами.
std::vector<int> MergeSort(const std::vector<int>& arr) {
    // Корнер-кейс. Массивы размером 0 или 1 уже отсортированы.
    if (arr.size() <= 1) {
        return arr;
    }
    // Исходный массив делится пополам.
    // Для каждой половины повторно вызывается алгоритм сортировки.
    const size_t mid = arr.size() / 2;
    const std::vector<int> left_sorted = MergeSort({arr.begin(), arr.begin() + mid});
    const std::vector<int> right_sorted = MergeSort({arr.begin() + mid, arr.end()});
    
    // left_sorted и right_sorted – отсортированные векторы.
    // Сливаем их и получаем из двух отсортированных векторов один.
  return Merge(left_sorted, right_sorted);
}
Еще одно важное понятие в этом уроке  — глубина рекурсии. Это общее количество вложенных вызовов функции. Например, для вызова Factorial(3) глубина рекурсии будет равна трём: Factorial(3) → Factorial(2) → Factorial(1).
Если глубина рекурсии равна размеру исходного массива, значит, с рекурсией что-то не так.
Рекурсия не обязательно должна доходить до последнего элемента, то есть корнер-кейс можно определять по-разному. Например, если для сортировки массивов от 1 до 8 элементов есть более простая и эффективная функция InsertionSort (сортировка вставками), то лучше использовать её. 
// Другой корнер-кейс.
if (arr.size() <= 8) {
        return InsertionSort(arr);
}
Алгоритм слияния
Осталось разобраться с алгоритмом слияния: как из двух отсортированных массивов получить один. Функция Merge принимает на вход два отсортированных массива и сливает их вместе:
std::vector<int> Merge(const std::vector<int>& arr1, const std::vector<int>& arr2);
Массивы arr1 и arr2 отсортированы. Значит, они содержат элементы в порядке от самого маленького до самого большого. Результирующий алгоритм, который выполняет слияние массивов, должен содержать элементы из обоих входных массивов в порядке от самого маленького до самого большого.
Алгоритм формирует новый массив элемент за элементом из двух входных массивов. Каждый раз в него нужно добавить минимальный из оставшихся элементов входных массивов. Можно представить, что входные массивы — это две очереди, а алгоритм слияния на каждом шаге берёт меньший из двух возможных элементов. Когда один из входных массивов закончится, оставшиеся элементы второго можно просто скопировать в результирующий массив.

Посмотрите на пример выше. Исходные массивы — arr1 = {3, 7, 9, 12} и arr2 = {6, 8, 15, 18, 27}. Вот как алгоритм слияния будет формировать результирующий массив res:
Первым элементом res должен быть минимальный элемент из массивов arr1 и arr2. Минимальный элемент в них будет первым. Это будет 3 для arr1 и 6 для arr2. Нужно в res забрать меньший — 3.
Следующим элементом res должен быть минимальный из оставшихся элементов. В массиве arr1 такой элемент — это 7, а в arr2 — 6. Нужно в res забрать меньший — 6.
Дальше — из 7 и 8 нужно забрать 7.
Эти шаги повторяются, пока в обоих входных массивах остаются элементы. Следующими будут 8, 9 и 12. После чего arr1 закончится.
В данном примере первым закончится arr1. После чего в arr2 останутся элементы 15, 18 и 27. Их нужно скопировать в результирующий массив.
Сортировка слиянием — один из эффективных алгоритмов. К его преимуществам относятся предсказуемость времени работы алгоритма и стабильность. Сортировку называют стабильной, если она не меняет относительный порядок равных (согласно выбранной операции сравнения) элементов. Можно написать слияние так, что при равенстве элементов алгоритм возьмёт элемент из левого массива arr1 в первую очередь. Тогда сортировка слиянием будет стабильной.
