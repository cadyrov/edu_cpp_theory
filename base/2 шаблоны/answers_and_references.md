# Ответы на тест "Шаблоны в C++" и ссылки на теорию

## Вопрос 1 - Ответ: B
**Строки теории:** 1-8
Невозможность изменить тип данных во время выполнения, все типы определяются при компиляции.

## Вопрос 2 - Ответ: B
**Строки теории:** 70-72
Ключевое слово `template` используется для создания шаблона.

## Вопрос 3 - Ответ: B
**Строки теории:** 89-96
Генерация кода по шаблону называется настройкой или инстанцированием (instantiation) шаблона на тип.

## Вопрос 4 - Ответ: B
**Строки теории:** 74-80
Можно использовать `typename` и `class` - оба варианта считаются равноправными и взаимозаменяемыми.

## Вопрос 5 - Ответ: C
**Строки теории:** 265-275
Код скомпилируется успешно из-за "ленивости" шаблона - компилятор игнорирует требования к типу, пока они не задействованы напрямую.

## Вопрос 6 - Ответ: B
**Строки теории:** 149-152
В шаблонных классах определение не выносят в .cpp-файл, а пишут в том же .h-файле.

## Вопрос 7 - Ответ: B
**Строки теории:** 190-194
Выведение типа (type deduction) - компилятор самостоятельно определяет тип, проанализировав аргументы.

## Вопрос 8 - Ответ: B
**Строки теории:** 182-190
Функция Sum сложит два числа: 10 + 20 = 30.

## Вопрос 9 - Ответ: C
**Строки теории:** 243-253
Ошибка компиляции из-за неоднозначности типов - компилятор не может определить, какой тип использовать.

## Вопрос 10 - Ответ: B
**Строки теории:** 260-264
Ключевое слово `auto` позволяет избежать явного указания типа.

## Вопрос 11 - Ответ: B
**Строки теории:** 441-448
Tuple (кортеж) - шаблонный класс для хранения списка значений различных типов.

## Вопрос 12 - Ответ: C
**Строки теории:** 468-473
Для получения k-го элемента кортежа используется функция `std::get<номер_элемента>(кортеж)`.

## Вопрос 13 - Ответ: B
**Строки теории:** 485-490
Распаковка кортежа - извлечение сразу нескольких значений в отдельные переменные.

## Вопрос 14 - Ответ: B
**Строки теории:** 516-520
std::optional - тип, который может либо иметь значение, либо быть пустым.

## Вопрос 15 - Ответ: B
**Строки теории:** 608-612
Метод `has_value()` проверяет, есть ли значение в optional.

## Вопрос 16 - Ответ: C
**Строки теории:** 616-623
Неопределенное поведение - может привести к некорректному значению, падению программы или иному эффекту.

## Вопрос 17 - Ответ: B
**Строки теории:** 649-655
Нетиповые параметры - параметры-значения, которые должны быть известны при компиляции.

## Вопрос 18 - Ответ: B
**Строки теории:** 651-655
Целочисленные, логические значения или указатели. С C++20 также числа с плавающей точкой.

## Вопрос 19 - Ответ: B
**Строки теории:** 657-670
Создает статический массив фиксированного размера, известного на этапе компиляции.

## Вопрос 20 - Ответ: B
**Строки теории:** 723-728
if constexpr - условный оператор, проверяющий условие на этапе компиляции.

## Вопрос 21 - Ответ: A
**Строки теории:** 723-728
Выведет "true", так как шаблон инстанцируется с параметром true.

## Вопрос 22 - Ответ: B
**Строки теории:** 825-830
Специализация - механизм, позволяющий определить шаблон по-разному для разных типов данных.

## Вопрос 23 - Ответ: B
**Строки теории:** 850-855
Полная специализация объявляется как `template<> struct Triangle<Side>`.

## Вопрос 24 - Ответ: A
**Строки теории:** 950-970
Выведет "hello", так как специализация сравнивает строки по длине, а "hello" длиннее "world".

## Вопрос 25 - Ответ: B
**Строки теории:** 870-880
Частичная специализация - версия шаблона для группы типов, а не конкретного типа.

## Вопрос 26 - Ответ: A
**Строки теории:** 870-885
Вариант A показывает частичную специализацию (U = std::string, T остается шаблонным), вариант B - полную специализацию.

## Вопрос 27 - Ответ: A
**Строки теории:** 56-58
DRY - "Don't Repeat Yourself" (не повторяйся) - базовое правило программирования.

## Вопрос 28 - Ответ: B
**Строки теории:** 108-115
Шаблоны обрабатываются компилятором с учетом содержимого, в отличие от макросов, которые просто заменяют текст.

## Вопрос 29 - Ответ: A
**Строки теории:** 1100-1115
Выведет 120 - факториал числа 5, вычисленный рекурсивно на этапе компиляции.

## Вопрос 30 - Ответ: B
**Строки теории:** 657-665
Размер статических массивов фиксирован на этапе компиляции и не может меняться, в отличие от векторов. 