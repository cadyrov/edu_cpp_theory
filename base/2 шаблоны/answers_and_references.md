# Ответы на тест: Шаблоны C++

## Правильные ответы

1. **b)** Ошибка компиляции - не указан тип шаблона
   - Шаблонные классы требуют явного указания типа при создании объекта

2. **b)** Никакой разницы, это синонимы
   - `typename` и `class` в контексте шаблонных параметров полностью взаимозаменяемы

3. **b)** В .h файле или inline в классе
   - Определения шаблонных методов должны быть доступны во время компиляции

4. **b)** Генерация конкретного кода из шаблона компилятором
   - Инстанцирование - это процесс создания конкретной версии шаблона для определенного типа

5. **c)** 3
   - Для `int`, `double` и `const char*` будут созданы отдельные версии функции

6. **b)** Ошибка - baseMethod не найден
   - Проблема двухфазного поиска имен в зависимых базовых классах

7. **b)** `template<> class MyClass<int> {};`
   - Корректный синтаксис полной специализации шаблона

8. **b)** Для всех арифметических типов
   - `std::is_arithmetic` включает все числовые типы (int, float, double и т.д.)

9. **b)** Поиск независимых имен при определении шаблона, зависимых при инстанцировании
   - Двухфазный поиск разделяет имена на зависимые и независимые от шаблонных параметров

10. **b)** Universal reference (forwarding reference)
    - `T&&` в шаблонной функции может привязываться к любому типу ссылки

11. **a)** `template<> class Vector<bool> { std::vector<bool> data; };`
    - Правильный синтаксис полной специализации класса

12. **b)** Выведет 120, вычисленное во время компиляции
    - `constexpr` функция с compile-time аргументом вычисляется на этапе компиляции

13. **c)** Нужна рекурсивная функция
    - До C++17 fold expressions не были доступны, нужна рекурсия

14. **b)** Предполагается что T всегда имеет iterator
    - Без ограничений тип T может не иметь вложенного типа iterator

15. **a)** Да, частичная специализация для классов допустима
    - Классы поддерживают частичную специализацию, функции - нет

16. **b)** "Specific"
    - Обычная функция имеет приоритет над шаблонной при точном совпадении типов

17. **b)** Тип результата зависит от типов параметров
    - Trailing return type позволяет использовать параметры в выражении типа возврата

18. **b)** Substitution Failure Is Not An Error
    - SFINAE - принцип, при котором неудачная подстановка не вызывает ошибку

19. **b)** Частичную специализацию
    - Специализация шаблона для указателей любого типа

20. **b)** `typename std::enable_if<std::is_integral<T>::value, T>::type`
    - Правильный синтаксис с `typename` для зависимого типа

21. **b)** Для сохранения категории значения
    - `std::forward` сохраняет lvalue/rvalue природу аргумента

22. **c)** Глубокое копирование массива поэлементно
    - Компилятор генерирует конструктор копирования, который копирует все элементы

23. **b)** Упрощает синтаксис и повышает читаемость
    - Template aliases делают код более читаемым и удобным

24. **b)** Частичная специализация функций не поддерживается
    - В C++ можно специализировать функции только полностью

25. **c)** При инстанцировании шаблона
    - `static_assert` проверяется при создании конкретной версии шаблона

26. **c)** "Base" "Specialized"
    - Общий шаблон для `double`, специализация для `int`

27. **d)** b) и c) правильные
    - Можно использовать `this->` или полное имя `Base<T>::`

28. **b)** Вычисления на этапе компиляции с помощью шаблонов
    - Template metaprogramming позволяет выполнять сложные вычисления во время компиляции

29. **b)** Вернет 10
    - Fold expression корректно суммирует все аргументы

30. **b)** `int&`
    - Universal reference с lvalue сохраняет lvalue reference

31. **b)** `typename T::iterator it;`
    - `typename` необходим для зависимых типов

32. **d)** Все перечисленное
    - Код демонстрирует специализацию, SFINAE и type traits одновременно

33. **a)** Выведет "1 2 3"
    - Рекурсивный вызов выведет числа через пробел, последнее с переводом строки

34. **b)** Можно использовать типы, значения и шаблоны
    - Шаблонные параметры могут быть type, non-type и template template parameters

35. **b)** Template template parameter
    - Параметр, который сам является шаблоном

36. **c)** Код скомпилируется без ошибок
    - Ошибка возникнет только при попытке инстанцирования шаблона

37. **c)** `char[6]`
    - Строковый литерал "hello" имеет тип массива символов

38. **b)** Поиск функций в namespace аргументов
    - ADL ищет функции в пространствах имен типов аргументов

39. **b)** Определения шаблонов должны быть в заголовочных файлах
    - Компилятору нужен полный код шаблона для инстанцирования

40. **b)** SFINAE с `std::enable_if`
    - Наиболее гибкий и мощный подход для ограничения типов

## Дополнительные объяснения

### Важные концепции:

**Двухфазный поиск имен (Two-phase name lookup):**
- Независимые имена ищутся при определении шаблона
- Зависимые имена ищутся при инстанцировании
- Для зависимых имен типов нужно `typename`

**SFINAE (Substitution Failure Is Not An Error):**
- Позволяет создавать условные шаблоны
- Неудачная подстановка типа не вызывает ошибку компиляции
- Основа для `std::enable_if` и других type traits

**Universal References (T&&):**
- В шаблонных функциях `T&&` может быть как lvalue, так и rvalue reference
- Работает только с выводом типа
- Основа для perfect forwarding

**Template Metaprogramming:**
- Вычисления на этапе компиляции
- Использует специализации и рекурсию
- Современная альтернива - `constexpr` функции

**Специализация шаблонов:**
- Полная специализация: `template<> class MyClass<int>`
- Частичная специализация: только для классов
- Для функций используйте перегрузку

### Распространенные ошибки:

1. **Забыть `typename` для зависимых типов**
2. **Попытка частичной специализации функций**
3. **Определение шаблонных методов в .cpp файлах**
4. **Неправильная работа с зависимыми именами в наследовании**
5. **Путаница между rvalue references и universal references** 