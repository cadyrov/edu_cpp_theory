Проблема строгой типизации
Вы уже знаете, что все данные, используемые в программе, можно отнести к определенному типу (например, целое число, строка или ваш собственный класс). Без указания типа не обходится ни одно выражение: если мы сохраняем результат выражения в переменной, то сразу определяем её тип. Создавая функцию, указываем, что именно она возвращает.
Всё это позволяет компилятору заранее определить, какие типы данных будут фигурировать на каждом этапе выполнения кода. Изменить тип данных во время выполнения уже невозможно. Если попытаться записать строку в переменную с типом int, это приведёт к ошибке. Такой подход называется строгой типизацией, а языки, которые её используют, — строго типизированными.
Это свойство делает программу быстрее и помогает избежать ошибок, которые могут привести к непредвиденным результатам. Однако это также может привести к некоторым неудобствам при написании кода. Каким именно — вы узнаете в этом уроке.
Работа с разными типами
Давайте начнём с простого примера. Создадим структуру Point для хранения координат точки на плоскости. Такая структура может быть полезна для решения геометрических задач или рисования графики. В ней хранятся две переменные: x и y.
struct Point {
    Point() = default;
    Point(int x0, int y0) : x(x0), y(y0) {}

    int x = 0;
    int y = 0;
};
Для удобного отображения координат воспользуемся уже знакомой конструкцией, позволяющей перегрузить оператор вывода.
std::ostream& operator << (std::ostream &os, const Point &point) {
    return os << "("s << point.x << "; "s << point.y << ")"s;
}

int main() {
    Point p{3, 2};
    std::cout << p << std::endl;
}
Эта структура отлично подходит для хранения целочисленных координат. К сожалению, нет гарантии, что положение точки будет задаваться только целыми числами. С тем же успехом может использоваться другой тип (например, double).
Поскольку в C++ необходимо явно указывать типы данных, не остаётся ничего другого, как написать свою Point для int и double.
struct PointInt {
    PointInt() = default;
    PointInt(int x0, int y0) : x(x0), y(y0) {}
    int x = 0;
    int y = 0;
};

struct PointDouble {
    PointDouble() = default;
    PointDouble(double x0, double y0): x(x0), y(y0) {}
    double x = 0;
    double y = 0;
};
Кроме того, каждой из них потребуется собственная перегрузка вывода.
// Вывод координат для PointInt.
std::ostream& operator << (std::ostream &os, const PointInt &point) {
    return os << "("s << point.x << "; "s << point.y << ")"s;
}

// Вывод координат для PointDouble.
std::ostream& operator << (std::ostream &os, const PointDouble &point) {
    return os << "("s << point.x << "; "s << point.y << ")"s;
}
Мы ожидаем, что координаты будут обрабатываться одинаково, независимо от того, какими числами они заданы — дробными или целыми. Поэтому код структур и вывода будет отличаться только типом переменных.
Можно пойти ещё дальше. Создадим класс для хранения отрезка (вектора), заданного двумя точками. Также добавим метод GetLengthSq, который возвращает квадрат длины, рассчитанный по координатам.
class Vector2DInt { // Класс для PointInt.
public:
    Vector2DInt(PointInt p_start, PointInt p_end) {
        this->start_= p_start;
        this->end_ = p_end;
    }
    
    int GetLengthSq() const { // Считает квадрат длины.
        int dx = start_.x - end_.x,
            dy = start_.y - end_.y;
        return dx * dx + dy * dy;
    }
    
private:
    PointInt start_; // Начало отрезка.
    PointInt end_; // Конец отрезка.
};

class Vector2DDouble { // Класс для PointDouble.
public:
    Vector2DDouble(PointDouble p_start, PointDouble p_end) {
        this->start_= p_start;
        this->end_ = p_end;
    }
    
    double GetLengthSq() const {
        double dx = start_.x - end_.x,
               dy = start_.y - end_.y;
        return dx * dx + dy * dy;
    }
private:
    PointDouble start_;
    PointDouble end_;
};
Чтобы код мог работать и с int, и с double, пришлось создать одинаковые структуры и классы. Наше решение работает, но вместе с тем нарушает принцип DRY — «Не повторяйся» (англ . don't repeat yourself). Это одно из базовых правил программирования, рекомендующее избегать дублирования кода, чтобы не столкнуться с проблемами, которые мы перечислили выше.
Шаблонные классы и структуры
В прошлом уроке мы рассмотрели случай, когда необходимость указывать тип данных может привести к дублированию кода и усложнить работу. К счастью, шаблоны могут решить эту проблему!
Вернёмся к реализации структуры Point для хранения координат типов int и double. Чем больше типов мы используем, тем больше копий Point придётся написать.
struct PointInt {
  int x;
  int y;
};

struct PointDouble {
  double x;
  double y;
};
Шаблоны позволяют избежать этого описанием всего одной структуры — универсальной для всех типов.
template <typename T> // Создаём шаблон с параметром Т.
struct Point {
  T x; // На место Т будет подставлен конкретный тип.
  T y;
};

int main() {
  Point<int> p_int{3, 2}; // Создаём Point с типом int.
  Point<double> p_double{1.5, 2.999}; // Создаём Point с типом double.
}
Перед объявлением Point появилась конструкция template <typename T>. Она указывает на то, что далее будет объявлен шаблон (англ. template) с параметрами, перечисленными в угловых скобках <>. В этом случае параметр всего один — typename T.
Ключевое слово typename значит, что этот параметр является заполнителем типа — на его место можно подставить int, double или ваш класс. Т — это имя параметра. Параметрам можно давать и другие имена, однако существует соглашение, в соответствии с которым принято использовать заглавные буквы английского алфавита. При создании структуры каждый экземпляр T будет заменён на конкретный тип (например, int).
Использование шаблона похоже на вызов функции: и там и там мы передаем параметры. Однако есть два отличия:
При вызове функции мы передаем значение или объект (например, число 5 или точку), а при использовании шаблона — тип.
При вызове функции параметр передается во время работы программы, а при использовании шаблона — во время компиляции.
Иногда в коде можно встретить другую запись объявления шаблона, в котором вместо typename используется слово class: template <class T>. Оба варианта считаются равноправными и взаимозаменяемыми — вы можете выбрать любой и придерживаться его.
В результате мы создали шаблон структуры. Теперь его можно использовать как обычную структуру, передав в угловых скобках значение шаблонного аргумента для параметра Т. В этом случае в качестве значения передаётся тип — int или double.
С точки зрения компилятора всё работает немного сложнее. Шаблон — всего лишь обобщенное описание, в которое можно подставить аргументы, чтобы сгенерировать реальный код. На этапе компиляции из выражений Point<int> и Point<double> будут созданы следующие шаблонные структуры:
// Так компилятор видит Point<int>.
struct Point {
  int x;
  int y;
};

// Так компилятор видит Point<double>.
struct Point {
  double x;
  double y;
};
Генерация кода по шаблону называется настройкой или инстанцированием (англ. instantiation) шаблона на тип.
Структуры struct PointInt и struct PointDouble, объявленные выше, задавали конкретный тип данных. Структура template<typename T> struct Point задаёт всего лишь шаблон типа — это значит, что мы не можем объявить переменную с типом Point. Однако с помощью шаблона можно создать множество различных типов: Point<int>, Point<double> и даже Point<std::string> — и объявить соответствующие им переменные.
Таким образом, проблема строгой типизации решается всё тем же способом: для каждого типа создается собственная копия структуры. Однако теперь компилятор делает это за нас!
Похожего результата можно достичь, используя наследие языка C — макросы. Они позволяют заменить фрагмент кода на псевдоним, который можно использовать в программе. Перед компиляцией все макросы автоматически заменяются на нужный код. Для их создания используется директива #define: сначала указывается имя макроса, а затем выражение, которое ему соответствует. 
Решение проблемы с Point будет выглядеть следующим образом. 
// Создание макроса.
#define MAKE_POINT(STRUCT_NAME, TYPE) struct STRUCT_NAME { TYPE x; TYPE y;};

MAKE_POINT(PointInt, int); // Заменится на struct PointInt { int x; int y;};.
MAKE_POINT(PointDouble, double); // Заменится на struct PointDouble{ double x; double y;};.

int main() {
    PointInt pInt{1, 2};
    PointDouble pDouble{1.0, 2.6};
}
Здесь MAKE_POINT(STRUCT_NAME, TYPE) — макрос с двумя параметрами, а STRUCT_NAME { TYPE x; TYPE y;}; — код, который будет подставлен на его место. Так можно обойтись без явного дублирования кода.
Макросы поддерживаются в современном C++, но считаются устаревшим инструментом. Они позволяют всего лишь заменить одну последовательность символов на другую — такой подход приводит к ошибкам, которые сложно отследить. В отличие от макросов, шаблоны не изменяют код и обрабатываются компилятором с учётом своего содержимого.
Шаблоны классов
Вернемся к примеру с вектором, заданным двумя точками. Внутри него используется структура Point. Сделаем и сам класс шаблоном, чтобы можно было использовать точки разных типов.
template<typename T>
class Vector2D { 
public:
    Vector2D(Point<T> p_start, Point<T> p_end) 
        : start_(p_start), end_(p_end) {} 
    
private:
    Point<T> start_; // Точки заданного типа.
    Point<T> end_; 
};
Методы и конструкторы шаблонов принято реализовывать внутри класса. Но если всё-таки потребуется вынести реализацию, нужно будет заново указать конструкцию template<...>.
template<typename T>
class Vector2D { 
public:
    Vector2D(Point<T> p_start, Point<T> p_end);
private:
    Point<T> start_; // Точки заданного типа.
    Point<T> end_; 
};

// Определение конструктора вне класса.
template<typename T>
Vector2D<T>::Vector2D(Point<T> p_start, Point<T> p_end) {
    this->start_= p_start;
    this->end_ = p_end;
}
В шаблонных классах и структурах определение не выносят в .cpp-файл, а пишут в том же .h-файле. Это необходимо, так как при использовании шаблонного метода компилятору должен быть доступен его полный код, чтобы было возможно выполнить настройку на заданные шаблонные аргументы.
Если вынести шаблонный метод или конструктор шаблона в .cpp-файл, то вы получите ошибку линкера.
Методы всё-таки можно выносить в .cpp-файл, но тогда придётся явно указать, на какие типы требуется настройка каждого метода шаблонного класса.
Шаблоны с несколькими параметрами
Мы рассмотрели шаблоны, имеющие один типовой параметр. Но параметров в шаблоне может быть и больше. Уже знакомый вам пример — std::pair<T1, T2>: значения в паре могут быть двух любых типов.
В качестве более интересного примера рассмотрим вектор пар, с помощью которого реализуем структуру данных под названием «словарь». Элементы словаря представлены в виде пар «ключ-значение». В нашем случае первый элемент pair будет ключом, а второй — значением.
template<typename K, typename V> // Шаблон с типовыми параметрами K и V.
class VectorOfPairs {
public:
    // Добавляет пару в конец вектора.
    void PushBack(const K& key, const V& value) { 
        content_.push_back({key, value});
    }
    // Позволяет получить пару по индексу.
    std::pair<K, V>& operator[](size_t i) const { 
        return content_[i];
    }
    // Устанавливает значение по ключу.
    void SetValueByKey(const K& key, const V& value);
    
private:
    std::vector<std::pair<K, V>> content_;
};
Данный шаблон зависит от двух типовых параметров — K и V. Для создания объекта VectorOfPairs нужно передать в шаблон два значения типа.
int main() {
    VectorOfPairs<std::string, int> vec;
}
При необходимости можно создавать шаблоны и с большим числом параметров.
Валидация шаблонных параметров
В качестве аргумента шаблону можно передать любой тип, будь то число или структура. Однако не все типы одинаковы. Одни поддерживают определённые операции, а другие нет. Сложные типы могут иметь специфические методы и свойства, которые есть только у них. По этой причине шаблон может работать с одними типами и не работать с другими.
Рассмотрим это на примере. Класс, основанный на шаблоне Square, хранит стороны квадрата и может рассчитать его площадь — для этого передаваемый тип должен поддерживать операцию умножения. Попытка использовать шаблон с типом std::string вызовет ошибку компиляции:
template<typename T>
class Square { 
public:
    Square(T a, T b) : a_(a), b_(b) { }
    
    T CountArea() {
        return a_ * b_;
    }
private:
  T a_, b_;
};

int main() {
    Square<int> sq_int{5, 4}; 
    sq_int.CountArea(); // Стороны типа int можно перемножить.
    
    Square<float> sq_float{5.5, 4.4};
    sq_float.CountArea(); // Стороны типа float тоже.
    
    Square<std::string> sq_str{"five"s, "four"s};
    sq_str.CountArea(); // Ошибка: у std::string нет операции умножения.
}
Порой избежать ошибок можно благодаря ещё одной особенности C++ — «ленивости» шаблона. Компилятор будет игнорировать требования к шаблонному типу, пока они не будут задействованы напрямую. В нашем примере к ошибке приведёт не настройка шаблона на тип std::string, а попытка вызвать метод CountArea, в котором задействована операция умножения.
Square<std::string> sq_str{"five"s, "four"s}; // На этом шаге ошибки нет.
sq_str.CountArea(); // Ошибка компиляции.
Если бы мы имели дело с обычным типом, ошибка возникла бы сразу — еще на этапе определения метода. Посмотрим на ещё один пример:
struct Color {
    int r, g, b;
};

template<typename T>
class Gradient { 
public:
    Gradient(Color c1, Color c2) : c1_(c1), c2_(c2) {}
    
    void PrintColor() const {
        // Ошибка при компиляции шаблона: нет operator << для
        // std::ostream и Color.
       std::cout << "From "s << c1_ << " to "s << c2_ << std::endl; // Ошибка!
    }
private:
    Color c1_, c2_;
};
Если возможность ошибки зависит от шаблонного аргумента, то компилятор не будет жаловаться на код, пока вы не попытаетесь вызвать метод с ошибкой:
template <typename T>
struct Point {
    T x, y;
};

template<typename T>
class Segment { 
public:
    Segment(Point<T> a, Point<T> b) 
            : a_(a), b_(b) {}
    
    // Печать координат концов отрезка.
    void PrintEdges() const {
        // Нет ошибки при компиляции шаблона:
        // может быть, для какого-то T есть
        // operator << (ostream&, Point<T>).
        std::cout << "A "s << a_ << ", "s;
        std::cout << "B "s << b_ << std::endl;
    }
private:
    Point<T> a_, b_;
};
Несмотря на то, что вызов метода PrintEdges приводит к ошибке, это не мешает создавать объекты типа Segment<…>.
Чтобы совсем избежать возможных ошибок, у переданного типа должны быть определены нужные операции. В следующем примере мы определили операцию вывода — и теперь можно вызывать метод:
std::ostream& operator << (std::ostream& o, Point<int> p) {
    return o << "("s << p.x << ";"s << p.y << ")"s;
}

int main() {
    Segment<int> int_seg({0,0}, {1,1});
    // Ок! Этот метод работает для типа int.
    int_seg.PrintEdges();

    // Тоже ок, но до тех пор, пока не вызовем d_seg.PrintEdges().
    Segment<double> d_seg({0.,.0}, {1.,.1});
}
В стандарте C++20 появились концепты — дополнение, позволяющее описывать требования к шаблонному аргументу. Они позволяют выбирать нужный шаблон и получать понятные сообщения об ошибках. Но главное — глядя на код, можно понять, что должно быть у типа, чтобы его корректно можно было подставлять в шаблон.
Дан шаблон класса с двумя параметрами для хранения информации о прямоугольнике. 
template<typename A, typename B>
class Rectangle { 
public:
    Rectangle(A a, B b) : a_(a), b_(b) {}
    
    // Проверяет, является ли прямоугольник квадратом.
    bool CheckIsSquare() const { 
        return a_ == b_;
    }   
private:
  A a_; 
  B b_; 
};

int main() {
    ... // Создание объекта класса. 
    std::cout << rect.CheckIsSquare() << std::endl; // Проверка на квадрат.
}
Стороны можно задать переменными типа int или объектами класса Vector2D<int>. В обоих случаях CheckIsSquare будет работать правильно, поскольку операция сравнения определена для обоих типов. 
В этом уроке вы познакомились с шаблонами — конструкциями, позволяющими создавать универсальные классы и структуры, которые можно использовать с различными типами данных. При передаче конкретных параметров компилятор генерирует из шаблона код, предназначенный для указанных типов, избавляя нас от необходимости дублировать его вручную. Этот процесс называется инстанцированием. Для корректной работы шаблона нужно следить за тем, чтобы тип поддерживал нужные операции.
В следующем уроке вы узнаете, как использовать шаблоны при работе с функциями и операторами.
Шаблонные функции
В прошлом уроке вы узнали, как работают шаблоны, на примере классов и структур. С их помощью можно писать конструкции, не привязанные к одному-единственному типу данных. Вместо этого они способны работать с любым типом, переданным в качестве параметра.
Это довольно удобно: не нужно каждый раз создавать новую копию кода. К счастью, магия шаблонов работает не только с классами и структурами, но и с функциями! В этом уроке вы научитесь создавать шаблоны как для функций, так и для операций.
Рассмотрим простой пример с функцией, суммирующей два значения. Поскольку это шаблон, его можно использовать для сложения целых или дробных чисел и даже строк — любых типов, поддерживающих операцию +.
template<typename T> // Шаблон функции сложения.
T Sum(T a, T b) {
    return a + b;
}

int main() {
    std::cout << Sum<int>(1, 1) << std::endl; 
    std::cout << Sum<double>(42., -42.) << std::endl;
    std::cout << Sum<std::string>("hello "s, "world"s) << std::endl;
}
Как и в случае с шаблонами классов, при использовании Sum в угловых скобках указан тип данных, с которым она будет работать. Однако для функций явно передавать тип не обязательно: во многих случаях компилятор может самостоятельно определить его, проанализировав аргументы. В нашем примере можно вызвать шаблонную функцию, используя более короткую запись.
std::cout << Sum(1, 1) << std::endl; // Подразумевается int: Sum<int>(int a, int b).
std::cout << Sum(42., -42.) << std::endl; // Sum<double>.
std::cout << Sum("hello "s, "world"s) << std::endl; // Sum<std::string>.
Зная типы переданных значений ((1, 1), (42.0, -42.0) или ("hello "s, "world"s)), компилятор выполнит выведение типа (англ. type deduction), который нужно подставить на место T. Несмотря на удобство, возлагать эту обязанность на компилятор можно не всегда: бывают случаи, когда автоматически определить тип не получится. О них мы расскажем чуть дальше в этом уроке.
💡 Несмотря на то что вывод типов характерен в первую очередь для функций, в некоторых ситуациях он применим и к классам. Для этого шаблонные аргументы класса должны быть явно связаны с типами параметров конструктора или же должны быть описаны правила, как их вывести. Эти правила называются deduction guides. Подробнее о них можно узнать из документации стандарта C++17.
Шаблоны функций можно использовать и с более сложными конструкциями (например, для сложения объектов шаблонного класса Vector2D). Напомним, что при сложении векторов необходимо просуммировать соответствующие координаты.
В обычном случае мы могли бы воспользоваться перегрузкой функций, создав свою Sum с сигнатурой для каждого типа.
// Функция Sum для типа Vector2D<int>.
Vector2D<int> Sum(Vector2D<int> v1, Vector2D<int> v2) {
    return Vector2D<int> {
        { v1.GetStart() + v2.GetStart() }, 
        { v1.GetEnd() + v2.GetEnd() }
    };
}

// Функция Sum для типа Vector2D<double>.
Vector2D<double> Sum(Vector2D<double> v1, Vector2D<double> v2) {
    return Vector2D<double> {
        { v1.GetStart() + v2.GetStart() }, 
        { v1.GetEnd() + v2.GetEnd() }
    };
}
К счастью, в нашем распоряжении есть шаблоны, которые позволяют сократить этот код, написав одну общую функцию.
template<typename T>
Vector2D<T> Sum(Vector2D<T> v1, Vector2D<T> v2) {
  ...
}
С классом Vector2D вывод типов тоже будет работать.
Vector2D<int> v1{{1, 2}, {3, 4}};
Vector2D<int> v2{{10, 20}, {30, 40}};

std::cout << Sum<int>(v1, v2) << std::endl; // Можно указать тип явно.
std::cout << Sum(v1, v2) << std::endl; // Или не указывать.


Компилятор проанализирует аргументы v1 и v2, имеющие тип Vector2D<int>, сопоставит их с типом параметров функции Vector2D<T> и поймёт, что Т равен int.
С чем ещё можно использовать шаблоны? 
В C++ существует четыре вида шаблонов: для классов, функций, переменных и псевдонимов. Первые два вам уже знакомы. 
Шаблоны переменных (англ. variable template) позволяют создавать переменные, значения которых зависят от типа. 
template <typename T> // Шаблон переменной.
constexpr T cal_coef = T(4.1868);
constexpr int i_cal_coef = cal_coef<int>; // int(4.1868) = 4.
constexpr double d_cal_coef = cal_coef<double>; // double(4.1868) = 4.1868.
Шаблоны псевдонимов (англ. alias template) позволяют давать шаблонам сокращенные имена. Таким образом можно сделать код более лаконичным и читаемым. 
template <typename T> // Псевдоним шаблона.
using Matrix = vector<vector<T>>;

int main() {
    // Подразумевается vector<vector<int>> m.
    Matrix<int> m{{1, 11}, {2, 22}, {3, 33}};
}
Шаблоны для перегрузки операций
Помимо функций, шаблоны успешно работают и с перегрузками операций. Давайте вспомним код для удобного вывода точки (например, типа PointInt).
// Выводит координаты точки.
std::ostream& operator << (std::ostream &os, const PointInt &point) {
    return os << "("s << point.x << "; "s << point.y << ")"s;
};
Теперь можно превратить эту перегрузку в шаблон.
template <typename T>
std::ostream& operator << (std::ostream &os, const Point<T> &point) {
    return os << "("s << point.x << "; "s << point.y << ")"s;
};
Это позволит печатать координаты, имеющие любой тип, для которого определена операция вывода.
Аналогичным образом можно написать функцию вывода для объектов шаблонного класса Vector2D. При этом можно задействовать перегрузку для Point или — как в примере ниже — обойтись без неё.
template<typename T>
class Vector2D { 
public:
    Vector2D(Point<T> p_start, Point<T> p_end) 
        : start_(p_start), end_(p_end) {} 
        
    template<typename D> // Объявление перегрузки как дружественной функции.
    friend std::ostream& operator<<(std::ostream &, const Vector2D<D> &);
        
private:
  Point<T> start_;
  Point<T> end_; 
};

template<typename T> // Определение перегрузки.
std::ostream& operator<<(std::ostream &os, const Vector2D<T> &vec) {
        return os << "[("s << vec.start_.x << ", "s << vec.start_.y 
                  << "), ("s << vec.end_.x << ", "s << vec.end_.y << ")]"s;
}

int main() {
    Vector2D<int> vec{{5, 42}, {627, 616}};
    std::cout << vec << std::endl; // Вывод вектора: [(5, 42), (627, 616)].
}
Чтобы перегруженная операция имела доступ к приватным полям класса, необходимо объявить её как дружественную функцию с помощью ключевого слова friend. Обратите внимание, что при этом она не является членом класса и не использует его шаблонный аргумент: это самостоятельный шаблон с собственным аргументом D.
Рассмотрим ещё один пример — функцию ToString, превращающую переданную переменную в строку. Это может быть полезно для вывода или в работе с текстами. В функции используется класс потока вывода std::ostringstream. Сначала мы записываем в него значение переменной, а затем получаем содержимое потока и превращаем в std::string. Такой способ сработает для любого типа с определенной операцией вывода.
#include <iostream>
#include <sstream>

template<typename T> // Преобразует в строку.
std::string ToString(const T& x) {
   std::ostringstream s;
   s << x;
   return s.str();
}

// Вывод для pair.
template <typename F, typename S>
std::ostream& operator << (std::ostream &os, const std::pair<F, S> &pair) {
    using namespace std::literals;
    return os << "("s << pair.first << "; "s << pair.second << ")"s;
}

int main() {
    std::string str_double = "Double value = "s + ToString(3.14);
    std::cout << str_double << std::endl; // Double value = 3.14.
    
    std::pair p{"pi"s, 3.14};
    std::string str_pair = "Pair value = "s + ToString(p);
    std::cout << str_pair << std::endl; // Pair value = (pi; 3.14).
}
В этом примере ToString работает как с типом double, так и с pair, для которого мы определили операцию <<.
С помощью перегрузок можно модернизировать пример со сложением векторов: сделаем так, чтобы вместо функции Sum можно было использовать операцию +.
template <typename T> // Шаблон перегрузки сложения.
Vector2D<T> operator+(Vector2D<T> v1, Vector2D<T> v2) {
    return Vector2D<T> {
        { v1.GetStart() + v2.GetStart() }, 
        { v1.GetEnd() + v2.GetEnd() }
    };
}

int main() {
    Vector2D<int> vec_1{{0, 0}, {10, 10}};
    Vector2D<int> vec_2{{-2, 2}, {-6, 6}};
    
    Vector2D<int> vec_sum = vec_1 + vec_2; // Складываем векторы.
    
    // Координаты начала: (-2, 2).
    std::cout << vec_sum.GetStart().x << ", "s << vec_sum.GetStart().y << std::endl;
    
    // Координаты конца: (4, 16).
    std::cout << vec_sum.GetEnd().x << ", "s << vec_sum.GetEnd().y << std::endl;
}
Как работает вывод типов
В начале урока мы говорили, что при вызове шаблонных функций можно опустить явную передачу типа. Однако это возможно только в тех случаях, когда у компилятора достаточно данных, чтобы вывести его самостоятельно. 
Когда вывод типов не сработает?
Прежде всего, если типы параметров нельзя однозначно определить по переданным значениям. Вернёмся к нашему примеру. Функция Sum принимает два аргумента одного типа. В первых двух случаях переданные значения имеют одинаковый тип, и проблемы с выводом не возникнет. В третьем примере (Sum(10.1, 10);) типы аргументов не совпадают, из-за чего компилятор не может однозначно определить, какой из них нужно передать шаблону. Это вызовет ошибку компиляции.
В четвертом примере тип задан явно, и все аргументы будут приведены к нему.
template<typename T>
T Sum(T a, T b) {
    return a + b;
}

int main() {
    Sum(10, 10); // Ок. Оба аргумента типа int.
    Sum(10.1, 11.1); // Ок. Оба аргумента типа double.
    Sum(10.1, 10); // Ошибка: выбрать int или double?
    Sum<int>(10.1, 10); // Oк: аргументы будут приведены к int.
}
Вторая проблема связана с определением типа возвращаемого значения. Он может быть задан явно, как в приведённом примере (сумма двух переменных типа T, скорее всего, тоже будет иметь тип Т). Однако суммирование может работать и с разными типами, например T и S. В этом случае сказать что-то про возвращаемый тип уже сложнее.
template<typename T, typename S>
??? Sum(T a, S b) {
    return a + b;
}
Решить эту проблему можно с помощью ключевого слова auto. Оно позволяет избежать явного указания типа: компилятор сделает это сам, проанализировав присваиваемое значение.
template<typename T, typename S>
auto Sum(T a, S b) {
    return a + b;
}
С релизом стандарта C++20 появилась возможность объявлять шаблоны функций без ключевого слова template. Для этого в параметрах вместо типа достаточно указать auto. Здесь оно играет роль синтаксического сахара, делая код еще более лаконичным. 
auto Sum(auto a, auto b) {
  return a + b;
}
Вывод типа с помощью auto работает и с более сложными конструкциями. В следующем примере приведена функция, которая суммирует все элементы из вектора пар (отдельно first и second) и возвращает две суммы в виде новой пары. Информации о переданных параметрах будет достаточно, чтобы компилятор определяет тип переменной, которой присваивается результат.
# include <iostream>
# include <vector>

// Суммирует элементы из вектора пар.
template<typename F, typename S>
std::pair<F, S> Sum(const std::vector<std::pair<F, S>>& vec) {
    F sum_first{};
    S sum_second{};
    for(const auto& item: vec) {
        sum_first += item.first;
        sum_second += item.second;
    }
    return {sum_first, sum_second};
}

int main() {
    std::vector<std::pair<int, std::string>> my_vec = {
        {10, "Hello"s},
        {0, " "s},
        {5, "World"s},
    };
  
    // Сопоставляя 
    // std::vector<std::pair< F, S >> и
    // std::vector<std::pair<int, std::string>>,
    // компилятор определяет, что F = int, S = std::string.
    auto result = Sum(my_vec);
    assert(result.first == 15);
    assert(result.second == "Hello World"s);
}
При всём этом возможности auto не безграничны: автоматический вывод будет работать, только если тип возвращаемого значения можно определить однозначно. В следующем примере функция с равным успехом возвращает тип T или S. Использование auto здесь приведёт к ошибке.
template<typename T, typename S>
auto Max(T x, S y) {
    if (x > y) {
        return x;
    } else {
        return y;
    }
}

int main() {
  // Ошибка! Что возвращает функция: int или double?
  auto x = Max(10, 42.1);
}
Перегрузка шаблонных функций
Вы уже сделали первые шаги в изучении шаблонных функций. Самое время продолжить знакомство и рассмотреть их дополнительные возможности.
В этом уроке мы поговорим о перегрузках. Вы уже сталкивались с этим понятием в теме, посвящённой обычным функциям в C++. Оно означает объявление нескольких функций с общим именем, но разными типами параметров. Похожим образом этот механизм работает и с шаблонами. Мы можем создавать шаблонные функции с одинаковыми названиями, но отличающиеся по передаваемым параметрам.
Рассмотрим пример с перегрузкой функции Sum. Первый вариант принимает два аргумента одного типа. Второй — те же аргументы, но с разными типами. Выбор одного из них будет зависеть от переданных значений.
// Перегрузка (1).
template<typename T>
auto Sum(T a, T b);   

// Перегрузка (2).
template<typename T, typename U>
auto Sum(T a, U b);   

int main() {
    //                     Перегрузка
    Sum(1, 1);               // (1)
    Sum(1, '1');             // (2)
    Sum<int, double>(1, 1);  // (2)
    Sum<int>(1, 1.0);        // (2)
    Sum<int, int>(1.0, 1.0); // (2)
}
В первых двух случаях работает вывод типов. Компилятор принимает решение, какую версию Sum вызвать, исходя из набора аргументов. Этим процессом можно управлять, если указать типы явно: в третьем вызове Sum типовые параметры имеют значения int и double, поэтому будет вызвана вторая версия функции. В четвёртом переданный тип int относится к параметру T, а тип для U будет выведен автоматически. В последнем случае Sum вызывается с двумя типовыми аргументами (пусть и одинаковыми), что соответствует её второй реализации.
При перегрузке шаблонные функции можно использовать вместе с обычными. В этом случае действует простое правило: частное лучше общего. У подходящей функции с точными параметрами будет приоритет перед шаблоном.
// Перегрузка (1).
template<typename T>
void Print(T value);   

// Перегрузка (2).
void Print(int value);   

int main() {
    //           Перегрузка
    Print(1);      // (2)
    Print<int>(1); // (1)
    Print<>(1);    // (1)
    Print("1");    // (1)
    Print(1.0);    // (1)
}
Описанное правило иллюстрируется первым вызовом в примере: для целочисленного аргумента выбирается обычная функция. Чтобы вызвать именно шаблон, можно явно передать тип в треугольных скобках <>.
💡 Как еще можно настраивать список параметров в шаблонных функциях? 
Вы уже знаете, что в функции могут быть параметры, имеющие значения по умолчанию. С шаблонными параметрами это тоже будет работать. 
template<typename T>
double PoundsToRubles(double pounds = 0, T coef = 112.5) {
    return pounds * coef;
}

int main() { 
    PoundsToRubles<int>();      // 0
    PoundsToRubles(10, 113);    // 1130
    PoundsToRubles<double>(10); // 1125. Значение 112.5 приведено к double.
    PoundsToRubles<int>(10);    // 1120. Значение 112.5 приведено к int.
    PoundsToRubles(10);         // Ошибка: не указан тип параметра.
}
В этом примере функция PoundsToRubles переводит фунты в рубли. Поскольку параметр coef является шаблонным, при вызове функции нужно явно указать тип, к которому его следует привести. В противном случае вызов приведёт к ошибке.
Особенности выбора перегрузок
При использовании перегрузок нередки ситуации, когда для одного вызова подходит несколько функций. Компилятор делает выбор, отдавая предпочтение более точному варианту — тому, который не требует приведения типов.
Но бывают случаи, когда в результате инстанцирования разных шаблонов на тип получаются одинаковые функции.
// Перегрузка 1.
template<typename T>
auto Max(T a, T b);

// Перегрузка 2.
template<typename T>
auto Max(T a, int b);

int main() {
    Max<int>(1, 2); // Ошибка: оба шаблона подходят.
}
В этом примере после подстановки типа int обе перегрузки будут иметь вид Max(T a, int b). Здесь однозначный выбор невозможен, и мы получим ошибку компиляции.
Возможна и обратная проблема, когда ни одна из функций не подходит.
template<typename T>
auto Sum(T a, T b, T c);

template<typename T, typename U>
auto Sum(T a, U b);

int main() {
    Sum<int>(1, 1, 1.0); // Ок, все параметры приведены к int.

    Sum(1, 1, 1.0); // Ошибка.
  }
Во втором вызове Sum ожидает параметры с типами (int, int, double). Для такого набора перегруженной функции нет, что приведёт к ошибке.
Напоследок давайте рассмотрим более интересный пример выбора перегрузки. Первая версия Print является шаблоном, а вторая — обычной функцией с целочисленным параметром.
template<typename T>
void Print(T value); 

void Print(int& value);

int main() {
    //        Перегрузка
    Print(1);   // 1 – int& не подходит.
    
    int a = 1;
    Print(a);   // 2 – int& подойдёт.
}
При вызове Print(1) можно ожидать, что будет выбран второй вариант, поскольку он работает с точным типом. Однако этого не происходит: компилятор выбирает Print(T value). Причина в том, что вторая функция ожидает не просто значение типа int, а ссылку на него (&int). В С++ неизменяемое значение не может быть передано по ссылке. Число (или числовой литерал) является таким значением, поэтому передать его подобным образом нельзя.
Если же мы создадим переменную a = 1, передача по ссылке будет допустима, и вызовется вариант Print(int& value).
Говоря о перегрузках шаблонных функций, невозможно не упомянуть концепцию SFINAE — substitution failure is not an error (англ. «неудавшаяся подстановка не является ошибкой»). Это значит, что, если подстановка типа в шаблон является некорректной, компилятор не вызывает ошибку, а ищет другую подходящую перегрузку. 
SFINAE помогает минимизировать число ошибок, связанных с наличием в коде неподходящих шаблонов — как вы уже знаете, это одна из частых проблем при работе с ними. 
Вместе с тем эта концепция часто используется в задачах метапрограммирования: создавая искусственные ошибки при инстанцировании шаблона, можно «отключать» некоторые перегрузки и манипулировать вызовами функций. Таким образом можно, например, создавать шаблоны, реагирующие только на нужные типы. 
Применение SFINAE в метапрограммировании — это хак, который устаревает. Теперь его можно заменить констрейнтами и концептами. Эти механизмы позволяют накладывать на шаблонные параметры любые ограничения, не прибегая к излишним хитростям.
Шаблонные классы стандартной библиотеки
Мы посвятили предыдущие уроки рассказу о том, как создавать собственные шаблонные классы и функции. Вместе с тем, затрагивая тему шаблонов, нельзя обойти стороной шаблонные типы и структуры данных, предоставляемые стандартной библиотекой C++. Некоторые из них (например, vector<T> и pair<T1, T2>) вам уже знакомы. Вектор позволяет хранить множество значений одного типа, а пара — два элемента любых типов. Шаблонность делает их универсальными и удобными для решения самых разных задач.
В этом уроке мы рассмотрим ещё два шаблонных класса, которые могут пригодиться в работе: tuple и optional.
Что такое tuple
Шаблонный класс tuple имеет второе распространённое название: кортеж. Как и pair, он позволяет хранить список значений различных типов, но их количество может быть произвольным. Нужные типы указываются при объявлении кортежа в виде шаблонных аргументов.
Следующий пример показывает создание кортежа для трех значений с типами int, string и double.
#include<tuple>

int main() {
    // Создадим кортеж для хранения ID, логина и рейтинга пользователя.
    std::tuple<int, std::string, double> user {10234, "FirTheClever"s, 4.97};
}
Кортежи позволяют объединить несколько элементов в один, что особенно полезно в случаях, когда нужно вернуть из функции более одного значения.
В качестве примера рассмотрим функцию ParseExpression. Она принимает строку с выражением вида a + b, извлекает из неё аргументы и знак операции, а затем возвращает кортеж с ними.
#include <tuple>
#include <sstream>

std::tuple<int, std::string, int> ParseExpression(std::string expr){
    std::istringstream is(expr);
    int a, b;
    std::string operation;
    
    is >> a >> operation >> b;
    
    return {a, operation, b};
}

int main() {
    std::string expression = "600 + 27"s;
    auto result = ParseExpression(expression); // result = {600, "+", 27}.
}
Чтобы заполнить кортеж, можно использовать список инициализации конструктора. При этом перечисленные значения должны соответствовать шаблонным аргументам и идти в том же порядке. Перечисление типов можно и опустить — в этом случае компилятор выведет их сам.
// Объявление со списком инициализации.
std::tuple<int, std::string, double> user_3{330333, "FirTheClever"s, 4.97};

// Шаблонные аргументы передавать не обязательно.
std::tuple user_3{330333, "FirTheClever"s, 4.97};
Работа с кортежем
В некотором смысле кортеж похож на вектор: его элементы тоже упорядочены и к ним возможен доступ по индексу. Чтобы получить k-й элемент кортежа, используется функция get. Ее вызов выглядит следующим образом: get<номер_элемента>(кортеж).
int main() {
    std::tuple<std::string, std::string, int> person {"Henry"s, "Jekyll"s, 50};
    
    std::cout << "Name: "s << std::get<0>(person) << std::endl; // Henry.
    std::cout << "Surname: "s << std::get<1>(person) << std::endl; // Jekyll.
    std::cout << "Age: "s << std::get<2>(person) << std::endl; // 50.
}
Эту же функцию можно использовать, чтобы изменить определённый элемент кортежа.
int main() { 
    std::tuple<std::string, std::string, int> person {"Henry"s, "Jekyll"s, 50};
    std::get<0>(person) = "Edward"s;
    std::get<1>(person) = "Hyde"s;
    
    std::cout << "Name: "s << std::get<0>(person) << std::endl; // Edward.
    std::cout << "Surname: "s << std::get<1>(person) << std::endl; // Hyde.
    std::cout << "Age: "s << std::get<2>(person) << std::endl; // 50.
}
В отличие от вектора, кортеж позволяет только присваивать новые значения своим элементам. Менять их количество, удаляя существующие или добавляя новые, нельзя. Созданный кортеж остаётся с тем же набором элементов, что были указаны при его объявлении.
Распаковка кортежа
Еще одна особенность кортежа — это возможность распаковывать элементы (англ. unpacking), то есть извлекать из него сразу несколько значений в отдельные переменные.
int main() {
    auto expr_tuple = std::tuple(627, "-"s, 27);
    auto [a, operation, b] = expr_tuple;
    std::cout << b << operation << a << std::endl; // 27-600.
}
Этот же подход можно использовать для распаковки нескольких значений, возвращаемых функцией.
int main() {
    std::string expression = "600 + 27"s;
    auto [a, operation, b] = ParseExpression(expression);
    std::cout << b << operation << a << std::endl; // 27+600.
}
Число переменных должно совпадать с количеством элементов в кортеже. Обратите внимание, что переменные не обязательно объявлять заранее: можно перечислить их в квадратных скобках и использовать ключевое слово auto, которое укажет компилятору, что типы нужно определить автоматически.
Помимо описанного способа, для распаковки кортежа можно использовать шаблонную функцию tie. Она аналогичным образом присваивает элементы переменным, которые передаются ей в виде параметров.
int main() {
    std::string expression = "100 * 42"s;
    auto result_tuple = ParseExpression(expression); // result_tuple = {100, "*", 42}.
    
    int a, b;
    std::string operation;

    std::tie(a, operation, b) = result_tuple;
    std::cout << b << operation << a << std::endl; // 42*100.
}
Преимущество tie — возможность работать c уже существующими переменными. Так, с её помощью можно реализовать функцию swap всего в одну строку.
std::string first = "James";
std::string second = "Bond";
std::cout << first << " " << second << std::endl; // James Bond.

std::tie(first, second) = std::tuple(second, first); // Меняем значения местами.

std::cout << first << " " << second << std::endl; // Bond James.
Чтобы создать переменные для распаковки, используется слово auto и квадратные скобки [].
Шаблонный класс optional
Класс optional представляет собой шаблон типа, который может либо иметь значение, либо быть пустым. Чтобы лучше понять область его применения, давайте рассмотрим функцию, которая получает вектор точек Point и возвращает его элемент с координатой х, равной заданной. Вполне возможна ситуация, когда нужная точка в векторе не найдётся.
template<typename T>
struct Point {
    T x, y;
};

template<typename T>
Point<T> FindByX(std::vector<Point<T>> points, T value_x) {
    for (auto point : points) {
        if (point.x == value_x) {
            return point;
        }
    }
    return ??? // Непонятно, что возвращать, если такой точки нет.
}
Класс optional позволяет решить эту проблему. Мы можем вернуть из функции значение, которое будет содержать либо найденную точку, либо «ничего». Поскольку optional — это шаблон, при его использовании необходимо указать тип данных, который он должен содержать: std::optional<Point<T>>.
#include <optional>

template<typename T>
std::optional<Point<T>> FindByX(std::vector<Point<T>> points, T value_x) {
    for (auto point : points) {
        if (point.x == value_x) {
            return point;
        }
    }
    // Если точка не найдена, возвращаем пустой optional.
    return std::nullopt; 
}

int main() {
    auto p_1 = Point<int>{1, 2};
    auto p_2 = Point<int>{3, 4};
    auto found_p = FindByX(std::vector{p_1, p_2}, 3);
    
    // Проверяем, есть ли значение.
    if (found_p) {
        // Записываем значение в переменную.
        Point<int> point = *found_p;
        std::cout << point.x << ", "s << point.y; // 3, 4.
    } else {
        std::cout << "Значение не найдено"s;
    }
}
Получить значение из optional можно с помощью символа *: *found_p. В тех случаях, когда значение optional представлено классом или структурой, можно обращаться к его полям напрямую (например, (*found_p).x) или же использовать более лаконичную запись через стрелочку ->.
if (found_p) { 
    std::cout << found_p->x << ", "s << found_p->y; // 3, 4.
Класс optional также оказывается полезен, когда нельзя выполнить функцию и вернуть из неё значение из-за некорректных параметров. Например, если в функцию GetByIndex передать индекс, выходящий за пределы размера вектора.
template<typename T>
std::optional<Point<T>> GetByIndex(std::vector<Point<T>> points, int index) {
    // Если индекс выходит за границы вектора, возвращаем nullopt.
    if (index < 0) || (index >= points.size()) {
        return std::nullopt;
    }
    return points[index]; 
}
Другое возможное применение optional — использовать его для хранения значения, которое может быть инициализировано не сразу. Так, при поиске максимального элемента в векторе его начальное значение станет известно только после того, как мы начнем перебирать элементы.
std::optional<int> start;
for (auto x : array) {
    if (!start.has_value()) { // Если максимум ещё не присвоен.
        start = x; // Присваиваем его переменной start.
    } else {
        start = std::max(start.value(), x);
    }
}
Получаем значение из optional
Чтобы решить, что делать с переменной типа optional дальше, нужно знать, пустая она или нет. Один из способов сделать это мы уже показали в примере выше.
if (found_p) { // Проверяем, есть ли значение.
optional имеет перегруженное приведение к логическому типу: если переменная не пустая, проверка if (optional) вернёт true.
Аналогичный результат можно получить с помощью метода has_value.
if (found_p.has_value()) { 
    std::cout << found_p->x << ", "s << found_p->y;
    } else {
        std::cout << "Значение не найдено"s;
    }
}
Чтобы извлечь значение из optional, можно воспользоваться записью через звёздочку * или же методом value. Разница между ними в том, что в первом случае программа не выдаст ошибку, но это приведет к неопределенному поведению: некорректному значению, падению программы или иному эффекту.
auto found_p = FindByX(std::vector{p_1, p_2}, 101); // Точка не найдена.
auto point = *found_p; // Ошибки нет.
  
// Но в переменную point попадают некорректные значения.
// Например, -716429744 и 32767.
std::cout << point.x << ", " << point.y; 
Если же попытаться получить значение из пустого optional с помощью value, это приведёт к ошибке.
auto found_p = FindByX(std::vector{p_1, p_2}, 101); // Точка не найдена.
auto point = found_p.value(); // Ошибка: std::bad_optional_access.
О том, как можно обработать такую ошибку, вы узнаете из темы об исключениях.
Чтобы избежать подобных проблем, стоит всегда проверять значение перед его извлечением или же использовать метод value_or. Он работает аналогично value, но в случае пустого optional возвращает значение по умолчанию.
auto found_p = FindByX(std::vector{p_1, p_2}, 101); // Точка не найдена.

// Значения нет — метод вернёт точку (0, 0).
auto point = found_p.value_or(Point<int>{0, 0}); 
std::cout << point.x << ", " << point.y; // 0, 0.
Почему же C++ допускает существование механизма, работа с которым требует ручной проверки, без которой можно всё сломать? Это позволяет языку избегать накладных расходов (оверхеда) на автоматические проверки. Благодаря этому optional можно использовать даже в самом высокопроизводительном коде, где каждый if на счету.
Шаблонные параметры: типовые и нетиповые
До сих пор мы говорили о шаблонах как о конструкциях, способных работать с различными типами данных. Нужный тип указывается при вызове шаблона и передаётся ему как параметр — поэтому такие аргументы называются типовыми. Но передавать в шаблоны можно не только типы. Как и в обычных функциях, в качестве аргументов могут выступать значения. В этом случае речь идёт о нетиповых параметрах (англ. non-type template parameters). Им и посвящен этот урок.
В отличие от параметров простых функций, нетиповые параметры шаблонов имеют ряд особенностей.
Во-первых, для них действует ограничение на типы: они могут принимать только целочисленные или логические значения или же быть указателями. С появлением стандарта C++20 в них стало также возможно передавать числа с плавающей точкой и объекты классов с константными членами.
Во-вторых, нетиповые параметры участвуют в инстанцировании шаблона наравне с типовыми параметрами, а значит, их значения должны быть известны при компиляции и являться константами.
Массивы
В каких случаях нетиповые параметры могут быть полезны? Давайте рассмотрим классический пример их применения — статические массивы. Это тип данных, во многом похожий на знакомый вам вектор: в него можно записывать значения одинакового типа и обращаться к ним с помощью индекса.
int main() {
    std::string week_names[7] = {"Понедельник"s, "Вторник"s, ... "Воскресенье"s};
    std::cout << week_names[1]; // "Вторник".
}
Главное отличие состоит в том, что размер массива — фиксированная величина, которая задается на этапе компиляции и не может меняться. По этой причине статические массивы не поддерживают операции push_back и resize. Но в этом же кроется их преимущество: массивы требуют меньше накладных расходов, чем векторы.
Попытка создать массив с заранее неизвестной длиной приведёт к ошибке.
struct Array {
    Array(size_t new_size): size(new_size) {}
    size_t size;
    int data[size]; // <- Ошибка!
};

int main() {
    auto a = Array(5);
}
Несмотря на то что размер массива указан в коде, объявление будет происходить во время выполнения программы, что недопустимо. Перепишем этот код, передав длину как нетиповой параметр. Для этого используются угловые скобки <>.
template <size_t Size>
struct Array {
  int data[Size];
};

int main() {
    auto a = Array<5>(); // Ок.
}
На этот раз число 5 записывается в Size на этапе компиляции, и ошибка не происходит.
Нетиповые параметры можно использовать вместе с типовыми (например, чтобы создавать массивы не только для целых чисел).
template <typename T, size_t Size>
struct Array {
  T data[Size];
};

int main() {
    auto a = Array<double, 5>();
}
Преимущества нетиповых параметров
Нетиповые параметры помогают не только при объявлении массивов. Поскольку они являются константами, компилятор может использовать их для оптимизации кода, заранее заменяя константные переменные и выражения их фактическими значениями. Это позволяет выполнить часть вычислений на этапе компиляции, что положительно сказывается на производительности программы.
Хорошей иллюстрацией такой оптимизации является случай, когда от значения константы зависит выполнение того или иного блока кода (например, при использовании оператора if). Если компилятор способен заранее определить результат условия, он может исключить ветви, которые не будут использоваться, и в результате избежать лишних проверок.
Рассмотрим пример с функцией, суммирующей несколько точек либо по координате x, либо по y.
template <typename T, bool use_x>
T SumPoints(std::vector<Point<T>> points) {
    T sum_point = T(0);
    for (auto point : points) {
        // Если use_x == true, суммируем координаты по х.
        if (use_x) { 
            sum_point += point.x;
        } 
        // Иначе суммируем по y.
        else { 
            sum_point += point.y;
        }
    }
    return sum_point;
}

int main() {
    auto points = std::vector<Point<int>> {{1, 101}, {2, 201}, {3, 301}};
    std::cout << SumPoints<int, true>(points) << std::endl; // 6.
    std::cout << SumPoints<int, false>(points) << std::endl; // 603.
}
В обычном случае проверка флага use_x выполнялась бы для каждой точки. Здесь же он является нетиповым параметром с неизменным значением. Благодаря этому компилятор знает, что результат проверки условия в рамках вызванной функции будет одним и тем же, и может сразу оставить только нужный код.
С точки зрения компилятора после инстанцирования шаблонных параметров и оптимизации функция будет выглядеть так:
int SumPoints<int, true>(std::vector<Point<int>> points) {
    int sum_point = 0;
    for (auto point : points) {
        // Компилятор уберёт этот if, так как знает, что
        // условие всегда истинно.
        if (true) {
            sum_point += point.x;
        } else {
            ...
        }
    }
    return sum_point;
}
Теперь в ней ничего лишнего!
Оператор if constexpr
Предварительная проверка условий — отличный механизм, позволяющий сделать код быстрее и эффективнее. Чтобы убедиться, что компилятор действительно убрал избыточное ветвление из объектного кода, можно использовать специальную конструкцию if constexpr. Она работает так же, как обычный if, но гарантирует, что проверка условия будет выполнена на этапе компиляции.
template <typename T, bool use_x>
T Sum(Point<T> point_1, Point<T> point_2) {
    if constexpr (use_x) {
        return point_1.x + point_2.x;
    } 
    return point_1.y + point_2.y;
}
Внутри условия if constexpr можно использовать только константы, известные на этапе компиляции. Вызывать обычные функции нельзя. Но можно использовать специальные функции, помеченные словом constexpr. Они могут вычисляться не во время выполнения программы, а при компиляции, поэтому в условие if constexpr попадёт уже готовый результат.
constexpr double ConvertToGalleons(double rubles, double rate = 100) {
    return rubles / rate;
}

template<double rubles, int galleons_limit = 10000>
bool CheckDeclaration() {
    // Функцию ConvertToGalleons можно использовать внутри constexpr if.
    if constexpr (ConvertToGalleons(rubles) > galleons_limit) {
        return true;
    }
    return false;
}

int main() {
    CheckDeclaration<50.0>(); // Вычислится на этапе компиляции.
}
В следующем примере мы рассмотрим задачу, с которой нередко можно столкнуться при использовании шаблонов: функция должна работать с разными типами, но их нужно обрабатывать по-разному. Представим структуру Triangle, которая хранит три элемента — стороны треугольника. Они могут быть представлены числами типа int или же объектами класса Side.
// Класс для хранения стороны фигуры.
class Side {
public:
    Side(double length): length_(length) {}
    int GetLength() const { 
        return length_; 
    }
private:
    int length_;
};

template <typename T> 
struct Triangle {
    Triangle(T a, T b, T c): a(a), b(b), c(c) {}
    T a, b, c;
};
Метод Perimeter суммирует стороны треугольника. Чтобы сделать это корректно, необходимо знать их тип: если он простой, можно просто обратиться к полям структуры — triangle_1.a + triangle_2.a. Если же это тип Side, для получения длины нужно использовать его метод: triangle_1.a.GetLength() + triangle_2.a.GetLength(). Для проверки типа используется конструкция std::is_same_v<T, Side>.
template <typename T> 
struct Triangle {
    Triangle(T a, T b, T c): a(a), b(b), c(c) {}
    
    T Perimeter() const {
        // С обычным if — ошибка при подстановке int:
        // у типа int нет метода GetLength().
        if constexpr (std::is_same_v<T, Side>) {
            // Если стороны треугольника имеют тип Side,
            // нужно использовать метод GetLength().
            return a.GetLength() + b.GetLength() + c.GetLength();
        } else {
            // Иначе достаточно просто взять их значения.
            return a + b + c;
        }
    }
    
    T a, b, c;
};

int main() {
    // Стороны треугольника заданы типом int.
    std::cout << Triangle{3, 5, 4}.Perimeter() << std::endl;
    
    // Стороны треугольника заданы типом Side.
    Side side{1};
    std::cout << Triangle{side, side, side}.Perimeter().GetLength()
              << std::endl;
}
Конструкция if constexpr позволяет исключить ненужный код, оставив тот, что подходит для переданного типа. В этом случае обычный if привёл бы к ошибке: если компилятор оставит обе условные ветви и попытается их разобрать, то обнаружит, что у типа int нет метода GetLength.
Ограничения нетиповых параметров
Вы уже знаете, что нетиповые параметры подставляются в шаблон во время инстанцирования. На практике — их значения должны быть известны (или вычисляемы) на этапе компиляции. Мы не сможем передать в шаблон значение, которое станет известно только при выполнении программы.
template <int Size>
class TicTacToe {
public:
    TicTacToe() = default;

private:
    int board_[Size];
};

int main() {
    TicTacToe<3> tic_tac_game_1; // Ок.
      
    int size;
    std::cin >> size;
    TicTacToe<size> tic_tac_game_2; // Ошибка!
}
В некоторых случаях это ограничение можно обойти, заранее инстанцировать шаблон на возможные значения.
// При вызове компилятор сам определит
// значение Size по типу.
template<int Size>
void DoTick(const TicTacToe<Size>& /*tick_tac_toe*/) {
    std::cout << "Board side size = "s 
              << Size << std::endl;
}

int main() {
    size_t size;
    std::cin >> size;
    
    // Используем константу вместо значения
    // size напрямую.
    switch(size) {
    case 2: 
        DoTick(TicTacToe<2>()); // 2 – известно на этапе компиляции.
        break;
    case 3:
        DoTick(TicTacToe<3>()); // 3 – известно на этапе компиляции.
        break;
    case 4:
        DoTick(TicTacToe<4>()); // 4 – известно на этапе компиляции.
        break;
    };
}
Для нетиповых параметров также возможен вывод типов — даже достаточно сложный. В примере выше мы вывели нетиповой параметр функции DoTick из параметра класса. Ещё компилятор может вывести значение параметра по списку инициализации.
template<typename T, int Size> 
void PrintArray(T const(&array)[Size]) {
    for (int i = 0; i < Size; i++) {
        std::cout << array[i] << " "s;
    }
}

int main() {
    PrintArray({1, 2, 3}); // Т = int, Size = 3.
}
Как еще можно передать аргументы в шаблон? 
Бывает, что количество аргументов шаблона сложно определить заранее. В этом случае на помощь приходит механизм variadic template («вариативный шаблон»), позволяющий создавать шаблоны с переменным числом аргументов как для классов, так и для функций. При создании variadic template список параметров указывается через многоточие .... 
template<typename... Types>
void DoSomething(Types... args);
Такая запись показывает, что шаблон может принять в качестве аргументов несколько типов или же ни одного. Вариативные шаблонные аргументы можно использовать и с нетиповыми параметрами.
В этом уроке вы узнали о нетиповых параметрах шаблонов. Главная особенность в том, что их значения должны быть известны на этапе компиляции. С одной стороны, это накладывает некоторые ограничения: аргументами шаблона не могут быть значения, вычисляемые по ходу выполнения программы. С другой стороны, это даёт ряд преимуществ при оптимизации кода (например, позволяет сделать предварительные расчёты или исключить лишние ветвления).
В следующих уроках вас ждёт знакомство с ещё одним продвинутым свойством шаблонов — частичной и полной специализацией.
Специализация шаблонов
Мы начали знакомство с шаблонами с того, что назвали их идеальным инструментом для создания универсального кода, работающего с любыми типами. И до сих пор придерживались этой идеи. Тем не менее универсальность шаблонов нужна не всегда: порой мы сталкиваемся с необходимостью обрабатывать определенные типы как-то иначе.
Специализация шаблонов классов
Давайте вспомним пример с расчетом периметра треугольника, стороны которого могут быть заданы как числами, так и объектами класса Side.
template <typename T> 
struct Triangle {
    Triangle(T a, T b, T c): a(a), b(b), c(c) {}
    
    T Perimeter() const {
        if constexpr (std::is_same_v<T, Side>) {
            // Если стороны треугольника имеют тип Side,
            // нужно использовать метод GetLength().
            return a.GetLength() + b.GetLength() + c.GetLength();
        } else {
            // Иначе достаточно просто взять их значения.
            return a + b + c;
        }
    }
    T a, b, c;
};
Чтобы корректно получить длины сторон, нужно проверить, какой тип был передан. Если мы захотим добавить в класс новые методы для работы с треугольником, нам придется добавить проверку в каждый из них.
Избежать этого поможет специализация — механизм, позволяющий определить шаблон по-разному для разных типов данных.
template <typename T> 
struct Triangle {
    Triangle(T a, T b, T c): a(a), b(b), c(c) {}
    
    int Perimeter() const {
        // Метод стал значительно проще.
        return a + b + c;
    }
    T a, b, c;
};

// Отдельный вариант Triangle для параметра Side.
// Нужно указать template<>, чтобы показать, что это
// часть шаблона.
template <> 
struct Triangle<Side> {
    Triangle(Side a, Side b, Side c): a(a), b(b), c(c) {}
    
    int Perimeter() const {
        // Проще и тут.
        return a.GetLength() + b.GetLength() + c.GetLength();
    }
    Side a, b, c;
};
Первая версия Triangle — это первичный шаблон, который будет работать со всеми типами, кроме Side. Вторая версия — специализация шаблона, предназначенная именно для Side.
Обратите внимание, что во втором объявлении также используется слово template, а нужные типы указываются в треугольных скобках после имени класса или структуры: struct Triangle<Side>.
У шаблонов стандартной библиотеки тоже имеются специализации. Например, у std::vector есть специализация std::vector<bool> с особенностями для более компактного хранения элементов.
Мы создали реализацию шаблона Triangle для конкретного шаблонного параметра — Side. Такой способ называется полной специализацией шаблона.
Если особый подход нужен не для конкретного типа, а для группы типов, можно написать вариант шаблона для каждого из них или же воспользоваться частичной специализацией.
Рассмотрим класс ConstellationStar, хранящий информацию о созвездии. Звёздную величину и название можно задать различными типами данных (T и U).
template <typename T, typename U>
class ConstellationStar { 
    ConstellationStar(T magnitude, U name);
    ... 
};
Механизм частичной специализации позволяет создать версию класса для параметра U, равного std::string, а параметр T оставить шаблонным.
// Частичная специализация: 
// U = std::string, T по-прежнему может быть любым.
template <typename T>
class ConstellationStar<T, std::string> {
    ConstellationStar(T magnitude, std::string name);
    ... 
};
Магия специализаций
Частичная специализация позволяет различать более сложные конструкции, например классы, работающие с одним элементом или вектором элементов того же типа.
// Звезда в созвездии может быть одиночной.
// Первый вариант шаблона.
template <typename T>
class ConstellationStar { };

// А может быть представлена звёздным скоплением.
// Второй вариант того же шаблона.
template <typename T>
class ConstellationStar<std::vector<T>> { };
В первом случае шаблонный класс ConstellationStar хранит информацию об одной звезде и получает единственный параметр Т для значения звёздной величины. Во втором случае классу нужно хранить данные о нескольких звёздах скопления, и звёздные величины задаются вектором (std::vector<T>).
Нужный класс будет выбран в зависимости от шаблонного аргумента.
// Выберется первый вариант – нельзя рассмотреть
// double как std::vector<T>.
ConstellationStar<double> alpha_orionis;

// Выберется второй вариант – можно рассмотреть
// std::vector<double> как std::vector<T>.
ConstellationStar<std::vector<double>> pleiades;
Специализации можно использовать при создании вспомогательных конструкций для анализа типов. Следующий пример показывает, как с их помощью реализовать проверку, является ли переменная константной.
// Эта структура будет выбрана по умолчанию.
template<typename T>
struct IsConst {
    static constexpr bool value = false;
};

// Эта структура будет выбрана, если тип Т константный.
template<typename T>
struct IsConst<const T> {
    static constexpr bool value = true;
};

int main() {
    int a = 5;
    const int b = 10;
    
    std::cout << "a константа? - "s 
              << (IsConst<decltype(a)>::value ? "да"s : "нет"s) << std::endl;
    std::cout << "b константа? - "s 
              << (IsConst<decltype(b)>::value ? "да"s : "нет"s) << std::endl;
              
    // a константа? - нет
    // b константа? - да
}
Специализация шаблонов функций
Мы можем создавать специализации не только для классов, но и для функций. Принцип их работы останется прежним.
Создадим специализированную функцию Max для сравнения типов Person.
struct Person {
    std::string name;
    int age;
};

template<typename T>
T Max(T value1, T value2) {
    return value1 > value2 ? value1 : value2;
}

template<>
Person Max(Person value1, Person value2) {
    return value1.age > value2.age ? value1 : value2;
}

int main() {
    std::cout << Max(1, 3) << std::endl;
    std::cout << Max(1.7, 3.6) << std::endl;
    std::cout << Max(Person{"Ivan"s, 33}, Person{"Proba"s, 12}).name << std::endl;
}
Как видите, синтаксис специализаций для функций будет немного другим. Вместо того чтобы писать конкретный тип после имени, как было с классами, мы указываем его в списке параметров: Max(Person value1, Person value2).
Специализация функций очень похожа на перегрузку. При этом в большинстве случаев перегрузка является лучшим выбором, поскольку работать с ней гораздо проще.
Специализация нетиповых параметров
Специализации успешно работают и для нетиповых шаблонных параметров. Например, мы можем написать функции, по-разному вычисляющие факториал:
factorial(n)=n!=1∗2∗3∗...∗n.
Если аргумент равен 0, функция должна вернуть 1. В противном случае она должна выполнить рекурсивные вычисления, вызывая саму себя.
// Для любого Value, кроме 0.
template<int Value>
int CountFactorial() {
    return Value * CountFactorial<Value - 1>();
}

// Для Value = 0.
template<>
int CountFactorial<0>() {
    return 1;
}
Используя это свойство специализаций, можно реализовать сложные compile-time-вычисления, позволяющие получить результат ещё до выполнения программы — сразу на этапе компиляции.
В современном C++ подобная магия нужна редко: куда лучше использовать constexpr-функции. Код получается проще как для программиста, так и для компилятора.

## Дополнительные концепции шаблонов

### Шаблонные псевдонимы (Template Aliases)
C++11 введён механизм создания псевдонимов для шаблонов с помощью ключевого слова `using`. Это упрощает работу со сложными шаблонными типами:

```cpp
// Вместо длинного std::vector<std::pair<std::string, int>>
template<typename Key, typename Value>
using Dictionary = std::vector<std::pair<Key, Value>>;

// Теперь можно писать просто:
Dictionary<std::string, int> my_dict;

// Или создать псевдоним для конкретного типа:
using StringIntDict = Dictionary<std::string, int>;
```

### Ограничения шаблонов (Template Constraints)
Для ограничения типов параметров шаблонов можно использовать SFINAE и type traits:

```cpp
#include <type_traits>

// Функция работает только с арифметическими типами
template<typename T>
typename std::enable_if<std::is_arithmetic<T>::value, T>::type
add(T a, T b) {
    return a + b;
}

// Альтернативный синтаксис с static_assert
template<typename T>
T multiply(T a, T b) {
    static_assert(std::is_arithmetic<T>::value, "T must be arithmetic type");
    return a * b;
}
```

### Шаблонные лямбды (Generic Lambdas) - C++14
Лямбда-функции также могут быть шаблонными:

```cpp
// Обычная лямбда
auto lambda1 = [](int x) { return x * 2; };

// Шаблонная лямбда с auto
auto lambda2 = [](auto x) { return x * 2; };

// Можно использовать с любыми типами
std::cout << lambda2(5) << std::endl;      // 10
std::cout << lambda2(2.5) << std::endl;    // 5.0
```

### Fold Expressions - C++17
Для работы с вариативными шаблонами добавлены fold expressions:

```cpp
// Сумма всех аргументов
template<typename... Args>
auto sum(Args... args) {
    return (args + ...);  // fold expression
}

// Использование
std::cout << sum(1, 2, 3, 4, 5) << std::endl;  // 15

// Логическое И для всех аргументов
template<typename... Args>
bool all_true(Args... args) {
    return (args && ...);
}
```

### Шаблоны переменных (Variable Templates) - C++14
Можно создавать шаблонные переменные:

```cpp
template<typename T>
constexpr T pi = T(3.14159265358979323846);

// Использование
float pi_f = pi<float>;
double pi_d = pi<double>;
```

### Автоматическое выведение типов для шаблонных классов - C++17
Компилятор может автоматически выводить типы для шаблонных классов:

```cpp
// До C++17 нужно было писать:
std::pair<int, std::string> p1{42, "hello"};

// С C++17 можно просто:
std::pair p2{42, "hello"};  // автоматически выводится std::pair<int, const char*>

// Работает и с пользовательскими классами:
template<typename T>
class MyContainer {
public:
    MyContainer(T value) : data(value) {}
private:
    T data;
};

MyContainer container{42};  // автоматически MyContainer<int>
```

### Практические советы по использованию шаблонов

#### 1. Предпочитайте `typename` вместо `class` для типовых параметров
```cpp
// Предпочтительно
template<typename T>
void func(T value);

// Менее предпочтительно (хотя работает одинаково)
template<class T>
void func(T value);
```

#### 2. Используйте SFINAE для условной компиляции
```cpp
// Функция работает только с целочисленными типами
template<typename T>
typename std::enable_if<std::is_integral<T>::value, T>::type
process_integer(T value) {
    return value * 2;
}
```

#### 3. Применяйте `constexpr` для compile-time вычислений
```cpp
template<int N>
constexpr int factorial() {
    if (N <= 1) {
        return 1;
    } else {
        return N * factorial<N-1>();
    }
}

// Вычисляется во время компиляции
constexpr int result = factorial<5>();  // 120
```

### Распространённые ошибки при работе с шаблонами

#### 1. Забыть про двухфазный поиск имён
```cpp
template<typename T>
void func() {
    // Ошибка: helper не найден
    helper();  // Нужно: this->helper() или Base<T>::helper()
}
```

#### 2. Проблемы с зависимыми типами
```cpp
template<typename T>
void func() {
    // Ошибка: компилятор не знает, что iterator - это тип
    T::iterator it;  // Нужно: typename T::iterator it;
}
```

#### 3. Неправильное использование специализации
```cpp
// Неправильно - частичная специализация функций не поддерживается
template<typename T>
void func(T value) { /* ... */ }

template<typename T>
void func<std::vector<T>>(std::vector<T> value) { /* Ошибка! */ }

// Правильно - используйте перегрузку
template<typename T>
void func(std::vector<T> value) { /* ... */ }
```

Эти дополнения помогут лучше понять современные возможности шаблонов C++ и избежать распространённых ошибок.

## Лучшие практики / Плохие практики (стандарт до C++17 включительно)

### Объявление шаблонов

**Хорошо:**
```cpp
// Используйте typename для типовых параметров
template<typename T>
class MyClass {};

// Понятные имена для шаблонных параметров
template<typename KeyType, typename ValueType>
class Dictionary {};

// Параметры по умолчанию для удобства
template<typename T, typename Allocator = std::allocator<T>>
class Container {};
```

**Плохо:**
```cpp
// class менее выразительно для типовых параметров
template<class T>
class MyClass {};

// Непонятные имена параметров
template<typename A, typename B, typename C>
class SomeClass {};

// Слишком много обязательных параметров без значений по умолчанию
template<typename T1, typename T2, typename T3, typename T4, typename T5>
class OverlyComplexClass {};
```

### Определение методов шаблонных классов

**Хорошо:**
```cpp
// Методы в заголовочном файле (.h/.hpp)
template<typename T>
class Vector {
public:
    void push_back(const T& value) {
        // реализация внутри класса
    }
    
    // Или с определением вне класса в том же файле
    T& at(size_t index);
};

template<typename T>
T& Vector<T>::at(size_t index) {
    return data_[index];
}
```

**Плохо:**
```cpp
// Определения в .cpp файле без явной инстанциации
// vector.h
template<typename T>
class Vector {
public:
    void push_back(const T& value);
};

// vector.cpp - ошибка линковки!
template<typename T>
void Vector<T>::push_back(const T& value) {
    // реализация
}
```

### Работа с зависимыми именами

**Хорошо:**
```cpp
template<typename T>
class Derived : public Base<T> {
public:
    void method() {
        // Явно указываем зависимое имя
        typename Base<T>::iterator it;
        this->base_method();
        Base<T>::static_method();
    }
};

// Использование auto для сложных типов
template<typename Container>
void process(const Container& container) {
    auto it = container.begin();  // проще чем typename Container::iterator
}
```

**Плохо:**
```cpp
template<typename T>
class Derived : public Base<T> {
public:
    void method() {
        // Ошибка: компилятор не знает что iterator - это тип
        Base<T>::iterator it;  
        
        // Ошибка: не найдет base_method в зависимом базовом классе
        base_method();
    }
};
```

### Специализация шаблонов

**Хорошо:**
```cpp
// Полная специализация класса
template<typename T>
class MyClass {
    // общая реализация
};

template<>
class MyClass<bool> {
    // специализация для bool
};

// Перегрузка функций вместо частичной специализации
template<typename T>
void process(T value) {
    // общий случай
}

template<typename T>
void process(std::vector<T> vec) {
    // специализация для векторов
}
```

**Плохо:**
```cpp
// Частичная специализация функций не поддерживается
template<typename T>
void process(T value) {}

template<typename T>
void process<std::vector<T>>(std::vector<T> value) {}  // Ошибка!

// Специализация в неправильном месте
namespace ns {
    template<typename T> class MyClass {};
}

template<>
class ns::MyClass<int> {};  // Должно быть внутри namespace ns
```

### Ограничения типов и SFINAE

**Хорошо:**
```cpp
// Использование type_traits для ограничений
template<typename T>
typename std::enable_if<std::is_arithmetic<T>::value, T>::type
add(T a, T b) {
    return a + b;
}

// static_assert для понятных сообщений об ошибках
template<typename T>
void process(T value) {
    static_assert(std::is_copy_constructible<T>::value, 
                  "T must be copy constructible");
}

// Проверка концепций через SFINAE
template<typename T>
auto get_size(const T& container) 
    -> decltype(container.size()) {
    return container.size();
}
```

**Плохо:**
```cpp
// Отсутствие ограничений - неясные ошибки компиляции
template<typename T>
T add(T a, T b) {
    return a + b;  // Что если T не поддерживает operator+?
}

// Попытка специализации вместо SFINAE
template<typename T>
void process(T value) {
    // сложная реализация для всех типов
}

// Множество специализаций вместо одного SFINAE решения
template<>
void process<int>(int value) {}
template<>
void process<double>(double value) {}
// и так далее...
```

### Вариативные шаблоны (C++11+)

**Хорошо:**
```cpp
// Рекурсивная распаковка parameter pack
template<typename T>
void print(T&& value) {
    std::cout << value << std::endl;
}

template<typename T, typename... Args>
void print(T&& first, Args&&... args) {
    std::cout << first << " ";
    print(args...);
}

// Perfect forwarding
template<typename T, typename... Args>
std::unique_ptr<T> make_unique(Args&&... args) {
    return std::unique_ptr<T>(new T(std::forward<Args>(args)...));
}
```

**Плохо:**
```cpp
// Забыли perfect forwarding
template<typename T, typename... Args>
std::unique_ptr<T> make_unique(Args... args) {  // потеря ссылок
    return std::unique_ptr<T>(new T(args...));  // копирование вместо перемещения
}

// Неэффективная рекурсия без базового случая
template<typename... Args>
void print(Args... args) {
    // Как остановить рекурсию?
}
```

### Использование auto и выведение типов

**Хорошо:**
```cpp
// auto для сложных типов
template<typename Container>
void process(const Container& container) {
    auto it = container.begin();
    auto value = *it;
}

// Trailing return type для сложных случаев
template<typename T, typename U>
auto multiply(T a, U b) -> decltype(a * b) {
    return a * b;
}

// decltype для получения типа выражения
template<typename T>
void func(T&& param) {
    using ValueType = typename std::decay<T>::type;
    ValueType copy = std::forward<T>(param);
}
```

**Плохо:**
```cpp
// Избыточное указание типов
template<typename Container>
void process(const Container& container) {
    typename Container::const_iterator it = container.begin();
    typename Container::value_type value = *it;
}

// Неправильное использование decltype
template<typename T>
auto func(T param) -> decltype(param) {  // возвращает по значению даже для ссылок
    return param;
}
```

### Производительность и оптимизация

**Хорошо:**
```cpp
// Используйте constexpr для compile-time вычислений
template<int N>
constexpr int factorial() {
    return N <= 1 ? 1 : N * factorial<N-1>();
}

// Избегайте ненужных копий
template<typename T>
void process(const T& value) {  // const reference
    // обработка
}

template<typename T>
void modify(T& value) {  // non-const reference
    // изменение
}

// Move semantics для временных объектов
template<typename T>
class Container {
public:
    void push_back(const T& value) { /* copy */ }
    void push_back(T&& value) { /* move */ }
};
```

**Плохо:**
```cpp
// Ненужные копирования
template<typename T>
void process(T value) {  // копирование при каждом вызове
    // обработка
}

// Игнорирование move semantics
template<typename T>
class Container {
public:
    void push_back(const T& value) { 
        data_.push_back(value);  // всегда копия, даже для временных объектов
    }
};

// Runtime вычисления вместо compile-time
template<int N>
int factorial() {  // не constexpr
    int result = 1;
    for (int i = 2; i <= N; ++i) {
        result *= i;
    }
    return result;
}
```

### Читаемость и поддержка кода

**Хорошо:**
```cpp
// Понятные псевдонимы типов
template<typename Key, typename Value>
using Map = std::unordered_map<Key, Value>;

template<typename T>
using Ptr = std::unique_ptr<T>;

// Документирование ограничений типов
template<typename Iterator>
void sort(Iterator begin, Iterator end) {
    static_assert(std::is_same_v<
        typename std::iterator_traits<Iterator>::iterator_category,
        std::random_access_iterator_tag
    >, "sort requires random access iterators");
}

// Разумное использование SFINAE
template<typename T>
auto to_string(const T& value) 
    -> std::enable_if_t<std::is_arithmetic_v<T>, std::string> {
    return std::to_string(value);
}
```

**Плохо:**
```cpp
// Сложные шаблонные конструкции без объяснений
template<typename T, typename = std::enable_if_t<
    std::is_arithmetic_v<T> && !std::is_same_v<T, bool> && 
    sizeof(T) >= 4 && std::is_signed_v<T>>>
void mysterious_function(T value) {
    // что эта функция делает?
}

// Злоупотребление шаблонами
template<typename T>
T add_one(T value) {  // шаблон не нужен для такой простой функции
    return value + 1;
}

// Отсутствие документации сложных template metaprogramming конструкций
template<bool B, typename T = void>
using enable_if_t = typename std::enable_if<B, T>::type;  // без комментариев
```

