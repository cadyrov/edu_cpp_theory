Зачем нужны тесты
Для создания проекта разработчику приходится выполнять самые разные задачи: формулировать требования к программе, продумывать архитектуру и, конечно, писать код.
Еще один этап, без которого не обходится написание программ, — это тестирование, то есть проверка того, что программа правильно выполняет свои функции и удовлетворяет всем требованиям.
В этом уроке вы познакомитесь с основными принципами тестирования, а также узнаете, как писать тесты и какие они бывают.
Тестирование кода
Как мы уже говорили, создание проектов обычно состоит из нескольких крупных этапов:
планирование и проработка архитектуры;
написание кода;
тестирование и отладка.
При этом программисты не реализуют сразу все функции программы. Разработка ведётся постепенно: сначала реализуется одна функция, затем вторая, третья и так далее. Параллельно с этим происходит тестирование уже написанного кода, что позволяет сразу находить и исправлять ошибки: это гораздо удобнее, чем корректировать полностью готовый проект.
Давайте рассмотрим практический пример, взяв знакомый вам класс Rational для работы с дробными числами. Представим, что перед вами стоит задача реализовать этот класс с различными дополнительными операциями. Начнем с версии с конструктором, который умеет сохранять значения и сокращает дробь.
#include <numeric>
#include <iostream>

class Rational {
public:
    Rational(int numerator, int denominator)
    : numerator_(numerator)
    , denominator_(denominator) {
        if (denominator_ == 0) {
            std::abort();
    }
    if (denominator_ < 0) {
        numerator_ = -numerator_;
        denominator_ = -denominator_;
    }
    const int divisor = std::gcd(numerator_, denominator_);
    numerator_ /= divisor;
    denominator_ /= divisor;
  }    
  int GetNumerator() const {
      return numerator_;
  }
  int GetDenominator() const {
      return denominator_;
  }
private:
    int numerator_ = 0;
    int denominator_ = 1;
};
Прежде чем писать что-то ещё, мы должны убедиться, что написанный код работает правильно. Самый простой способ — дополнить программу так, чтобы можно было передавать классу различные числа, вводимые с клавиатуры, и выводить их на экран.
int main() {
    int num, den;
    std::cin >> num >> den;
    
    Rational r(num, den);
    std::cout << r.GetNumerator() << " / " << r.GetDenominator() << std::endl; 
}
Теперь мы можем проверить, как программа обрабатывает различные варианты ввода. Чтобы протестировать все возможные случаи, будем вводить в консоль следующие значения:
3 и 4 — проверяем, что класс сохраняет числитель и знаменатель. Правильный вывод: 3 / 4.
-3 и 5 — проверяем, что класс правильно сохраняет отрицательные числа. Правильный вывод: -3 / 5.
4 и -5 — проверяем, что класс хранит отрицательную дробь с минусом при числителе. Правильный вывод: -4 / 5.
2 и 6 — проверяем, что класс сокращает дробь. Правильный вывод: 1 / 3.
-3 и -6 — проверяем, что минус тоже сокращается. Правильный вывод: 1 / 2.
Это не все возможные проверки, которые можно провести (например, мы не проверяем, как класс сокращает дробь с минусом при знаменателе). Однако они затрагивают все основные варианты поведения программы.
Ручное тестирование позволяет быстро и легко убедиться, что новые функции работают как ожидается. Однако на практике нужно проверять не только новый, но и старый код, поскольку он тоже может «сломаться» после обновлений. Повторять эти действия вручную может быть долго и неудобно.
К счастью, программисты способны автоматизировать действия с данными! Вместо того чтобы вводить всё самостоятельно, мы можем написать код, который будет использовать класс и сравнивать значения за нас.
Rational r1(3, 4);
if ((r1.GetNumerator() == 3) & (r1.GetDenominator() == 4)) {
    std::cout << "Test 1 passed" << std::endl;
} else {
    std::cout << "Test 1 failed" << std::endl;
}

Rational r2(-3, 5);
if ((r2.GetNumerator() == -3) & (r2.GetDenominator() == 5)) {
    std::cout << "Test 2 passed" << std::endl;
} else {
    std::cout << "Test 2 failed" << std::endl;
}

// И так далее.
Для проверки используем условие с if, в котором полученные результаты будут сравниваться с ожидаемыми. Таким образом, наши тесты будут делать то же самое, что мы делали вручную, но гораздо быстрее.
Дополним наш класс, написав перегрузку для операции сложения. Теперь сокращение дроби требуется в двух местах — при инициализации и расчете суммы, — поэтому будет логично вынести его в отдельную функцию Reduction.
class Rational {
public:
    Rational(int numerator, int denominator)
    : numerator_(numerator)
    , denominator_(denominator) {
        if (denominator_ == 0) {
            std::abort();
        }
        Reduction();
    }
    
    Rational& operator+=(const Rational& r2) {
        auto gcd = std::gcd(denominator_, r2.denominator_);
        numerator_ = numerator_ * (r2.denominator_ / gcd) + 
                 r2.numerator_ * (denominator_ / gcd);
        denominator_ = (denominator_ / gcd) * r2.denominator_;
        Reduction();
        return *this;
    }
    ...
private:
    void Reduction() {
        if (denominator_ < 0) {
            numerator_ = -numerator_;
            denominator_ = -denominator_;
        }
        const int divisor = std::gcd(numerator_, denominator_);
        numerator_ /= denominator_;
        denominator_ /= denominator_;
    }
    ...
};
Напишем новые проверки с if, которые будут проверять сложение. Первый тест может быть таким:
Rational r6 = Rational(1, 5) + Rational(2, 5);
if ((r6.GetNumerator() == 3) & (r6.GetDenominator() == 5)) {
    std::cout << "Test 1 passed" << std::endl;
} else {
    std::cout << "Test 1 failed" << std::endl;
}
// Этот тест класс не пройдёт.
Новые тесты класс почему-то не проходит. Возможно, операция сложения реализована неправильно, а возможно, ошибка происходит раньше (в конструкторе) и связана с добавлением функции Reduction.
Ответить на этот вопрос нам поможет предыдущая группа тестов, которые проверяли конструктор. Запустив их, мы сразу увидим, что инициализация дроби тоже выполняется некорректно, а значит, проблема связана с ее сокращением. Благодаря этому мы можем быстро отыскать ошибку в коде Reduction.
void Reduction() {
    ...
    const int divisor = std::gcd(numerator_, denominator_);
    numerator_ /= divisor;   // Было: numerator_ /= denominator_;
    denominator_ /= divisor; // Было: denominator_ /= denominator_;
}
Теперь, запустив все тесты, убедимся, что и инициализация, и сложение работают корректно.
Особенности тестов
В рассмотренном примере вы увидели, как действуют тесты: они позволяют контролировать происходящее в коде и дают уверенность, что всё работает как надо. Только обычно они пишутся с помощью специальных библиотек, а не через if.
Тесты можно разделить на две группы: интеграционные и модульные. Первые проверяют поведение программы в целом, оценивая, правильно ли взаимодействуют написанные классы и модули.
Модульные тесты часто называют юнит-тестами. Их задача — проверять работу отдельных частей кода, например функций или методов класса. Они могут использоваться с самых ранних этапов разработки, позволяя убедиться, что код работает правильно в любых возможных ситуациях. В примере с Rational мы использовали именно юнит-тесты, которые проверяли, как поведёт себя класс, если получит сокращаемую дробь, дробь с отрицательным знаменателем и так далее. Кроме того, такие тесты используются в Тренажёре, позволяя проверять решения задач.
Идеальные юнит-тесты должны охватывать все возможные пути выполнения кода. Для этого используется специальный показатель — покрытие, который отражает, какой процент строк кода был затронут в процессе тестирования.
Принцип работы юнит-тестов очень прост: они вызывают нужный кусочек кода (например, функцию) с заданными параметрами, а затем сравнивают полученный результат с правильным. Это может быть реализовано различными способами:
Использование готовых ответов. Например, при тестировании функции сортировки мы можем сразу написать, чему должен быть равен результат.
if (DoSort({4, 2, 1, 5, 3}) == std::vector{1, 2, 3, 4, 5}) { ... }
Использование более простых или встроенных алгоритмов для расчёта правильного результата. Например, для получения корректно отсортированной последовательности можно использовать библиотечную функцию std::sort. Если наш код даёт такой же ответ, он работает правильно.
std::vector<int> test_seq = {4, 2, 1, 5, 3};
    
auto true_sorted_seq = test_seq;
std::sort(true_sorted_seq.begin(), true_sorted_seq.end());

if (DoSort(test_seq) == true_sorted_seq) { ... }
Синтетическое получение ответа. В случае сортировки мы можем перемешать отсортированную последовательность и передать ее функции, ожидая, что она вернется в исходное состояние.
std::vector<int> sorted_seq = {1, 2, 3, 4, 5};
    
auto test_seq = sorted_seq;
std::shuffle(std::begin(test_seq), std::end(test_seq), random_engine);
    
if (DoSort(test_seq) == sorted_seq) { ... }
Чем больше функций добавляется в проект, тем больше юнит-тестов нужно написать. Поэтому к ним есть определённые требования.
Во-первых, юнит-тесты должны выполняться автоматически (и не требовать, например, ручного ввода с клавиатуры). Благодаря этому, даже если тестов очень много, мы можем запускать их без дополнительных усилий со своей стороны.
Во-вторых, юнит-тесты не должны зависеть друг от друга или использовать результаты, полученные от предыдущих тестов.
В-третьих, при разработке новых функций старые тесты не удаляются и запускаются вместе с новыми. Как вы видели в примере с Reduction, это позволяет убедиться, что новый код ничего не сломал. Тесты, которые подтверждают работоспособность старого кода, называются регрессионными.
Когда мы устраняем ошибку в программе, рекомендуется написать юнит-тест, проверяющий, что она больше не возникает. Это гарантирует, что в будущем проблема не повторится или что мы сможем оперативно её исправить.
При добавлении тестов в проект следует учитывать еще один важный принцип: они должны работать независимо от основной программы. Для этого тесты размещают в самостоятельных файлах, которые можно запускать отдельно.
Разработка через тестирование
Юнит-тесты можно писать как в процессе создания классов и функций, так и после. Однако существует и другой подход, который предполагает создание тестов до написания кода. Этот подход называется Test-Driven Development (TDD), что в переводе означает «разработка через тестирование». В рамках TDD процесс разработки выглядит следующим образом:
Прежде чем разрабатывать некоторую функцию Func, создаётся тест, который проверяет работу этой функции. Поскольку самой Func ещё нет, тест будет выдавать ошибку.
Пишется код функции Func.
Проверяется прохождение теста: теперь код должен его проходить.
Такой подход позволяет решить сразу несколько задач: протестировать функцию, четко представить, что она должна делать, перед её написанием, а также убедиться, что тест может падать и не выдаёт ложноположительные результаты.

Тестирование с помощью assert
Самый простой инструмент, с помощью которого можно писать тесты, — это функция assert. Она оценивает истинность выражения и, если оно ложно, вызывает ошибку программы, указывая в консоли, какая именно строка кода не прошла проверку.
Перепишем на assert тесты для класса Rational.
// Подключаем, чтобы использовать функцию.
#include <cassert> 
...

// Тесты для проверки конструктора.
Rational r1(3, 4);
assert(r1.GetNumerator() == 3);
assert(r1.GetDenominator() == 4);

Rational r2(-3, 5);
assert(r2.GetNumerator() == -3);
assert(r2.GetDenominator() == 5);
...

// Тесты для проверки сложения.
Rational r6 = Rational(1, 5) + Rational(2, 5);
assert(r6.GetNumerator() == 3);
assert(r6.GetDenominator() == 5);
Как видите, запись получилась более компактной, чем при использовании if. В скобках assert указывается логическое выражение, которое нужно проверить.
Посмотрите на функцию FindMaxIndex, которая ищет индекс максимального элемента вектора. Если вектор пустой, она должна вернуть -1. Если в векторе несколько значений равны максимуму, нужно вернуть индекс последнего. 
После функции идёт несколько assert-тестов, проверяющих её работу. 
int FindMaxIndex(const std::vector<int>& nums) {
    if (nums.empty()) {
        return -1;
    }
    int maxIndex = 0;
    for (size_t i = 1; i < nums.size(); ++i) {
        if (nums[i] > nums[maxIndex]) {
            maxIndex = i;
        }
    }
    return maxIndex;
}

int main() {
    std::vector<int> test1 = {1, 2, 3, 4, 5};
    assert(FindMaxIndex(test1) == 4); 
    
    std::vector<int> test2 = {2, 1, 5, 5, 3};
    assert(FindMaxIndex(test2) == 3); 

    std::vector<int> test3 = {5, 4, 3, 2, 1};
    assert(FindMaxIndex(test3) == 0); 

    std::vector<int> test4 = {-1, -2, -3, -4, -5};
    assert(FindMaxIndex(test4) == 0); 

    std::vector<int> test5 = {};
    assert(FindMaxIndex(test5) == -1);

    std::vector<int> test6 = {1, 1, 1, 1, 1};
    assert(FindMaxIndex(test6) == 1); 
}
Функция assert имеет скромные возможности по сравнению с фреймворками для тестирования, однако у неё есть несколько преимуществ:
assert входит в стандартную библиотеку C++. Чтобы её использовать, не нужно ничего устанавливать.
Проверки с помощью assert полезны в тех случаях, когда нужно просто отладить программу, а не писать для нее полноценные тесты.
Такие проверки можно использовать как документацию кода, наглядно демонстрируя, как он работает в тех или иных случаях. Этот подход вы могли встретить в Тренажёре: там assert часто используется в условии, чтобы показать, что должен делать ваш код.
У assert есть и недостатки:
Если одна из проверок проваливается, программа завершает выполнение, и остальные тесты не выполняются.
assert указывает только на строку, в которой произошла ошибка, но не говорит, что именно пошло не так (например, какой фактический результат вернула функция).
Такой подход не позволяет группировать тесты и автоматизировать подготовку нужных им ресурсов (например, заранее инициализировать вспомогательные данные, которые используются для тестирования).
assert умеет проверять только истинность выражения. При тестировании сложных программ этого может быть недостаточно.

Тестирование — это важный этап разработки программного обеспечения, который позволяет выявлять и устранять ошибки на ранних этапах работы.
Тесты можно создавать как после написания кода, так и одновременно с ним, добавляя проверки для каждой новой функции. Также существует метод TDD (Test-Driven Development), при котором код пишется на основе заранее подготовленных тестов.
Простейшие тесты можно реализовать с помощью функции assert, но на практике чаще всего используются фреймворки. В следующем уроке мы расскажем о некоторых из них.
Обзор фреймворков
Продолжаем знакомство с тестированием в C++. В этом уроке мы расскажем о фреймворках — специальных инструментах, которые упрощают написание и настройку тестов. В качестве примеров мы рассмотрим два самых популярных фреймворка: Google Test и Catch2. А в практической части вы потренируетесь создавать тесты, используя наш собственный мини-фреймворк.
Работа с фреймворками
Фреймворки для тестирования — это библиотеки, которые предлагают набор функций для создания тестов и задают ряд правил, как это делать. Например, в большинстве случаев тесты оформляются в виде методов класса, и для их объявления используется специальный синтаксис.
Кроме того, фреймворки упрощают запуск тестов: они могут запускать тесты, написанные в разных файлах (благодаря чему нам не нужно собирать их вручную), позволяют фильтровать тесты по именам или классам, к которым они относятся, а также умеют автоматически формировать отчёты с результатами тестирования.
Чтобы использовать любой фреймворк (в этом уроке рассмотрим Google Test и Catch2), необходимо подключить его к проекту. Общий алгоритм установки и запуска тестов включает следующие этапы:
Скачивание и установка фреймворка. Для этого можно использовать установщик пакетов или скачать исходный код с GitHub или из другого источника.
Подключение заголовочных файлов с помощью #include. Так компилятор будет знать, где искать код фреймворка.
Линковка и создание исполняемого файла с тестами. Как вам известно, при компиляции компоновщик объединяет код программы и сторонних библиотек, формируя единый исполняемый файл. Это можно сделать через командную строку или средствами IDE.
Запуск тестов. Полученный исполняемый файл можно использовать для выполнения тестирования. Он будет содержать сами тесты, а также код тестируемой программы и фреймворка.
 Многие фреймворки позволяют выбрать тесты, которые нужно запустить: все или только те, что соответствуют определённым критериям, например принадлежат к определённому классу или имеют конкретные теги.
Тестирование с помощью Google Test
Google Test представляет собой один из наиболее широко используемых фреймворков для написания тестов на C++. В отличие от таких простых инструментов, как assert, он даёт множество полезных функций для упрощения тестирования, например возможность писать как модульные, так и интеграционные тесты, и формирует подробные отчеты с результатами.
Давайте вернемся к примеру с Rational и посмотрим, как тестировать этот класс с помощью Google Test. Напомним, что в нём реализованы конструктор с параметрами и перегрузка операции сложения. В прошлом уроке мы написали проверки для них, используя функцию assert.
#include <cassert> 
#include "rational.h"

int main() {
    // Тест для проверки конструктора.
    Rational r1(3, 4);
    assert(r1.GetNumerator() == 3);
    assert(r1.GetDenominator() == 4);
    
    // Тест для проверки сложения.
    Rational r6 = Rational(1, 5) + Rational(2, 5);
    assert(r6.GetNumerator() == 3);
    assert(r6.GetDenominator() == 5);
}
При использовании Google Test код будет выглядеть следующим образом.
#include <gtest/gtest.h> // Подключаем библиотеку.
#include "rational.h"    // Подключаем файл с определением Rational.

// Объявление тестового класса RationalTest.
class RationalTest : public ::testing::Test {};

// Тест для конструктора.
TEST(RationalTest, ConstructorTest) {
    Rational r = Rational(3, 4);
    EXPECT_EQ(r.GetNumerator(), 3);
    EXPECT_EQ(r.GetDenominator(), 4);
}

// Тест для сложения.
TEST(RationalTest, AdditionTest) {
    Rational r = Rational(1, 5) + Rational(2, 5);
    EXPECT_EQ(r.GetNumerator(), 3);
    EXPECT_EQ(r.GetDenominator(), 5);
}

// Главная функция для запуска тестов.
int main(int argc, char **argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
Чтобы использовать фреймворк, необходимо подключить заголовочный файл <gtest/gtest.h> (название может отличаться в зависимости от способа установки).
Далее следует объявление класса RationalTest, который будет хранить все тесты для Rational. Как правило, имя класса отражает часть кода, которую он проверяет. Запись class RationalTest : public ::testing::Test означает, что RationalTest наследуется от библиотечного класса ::testing::Test, то есть содержит все его методы и свойства в дополнение к собственным. Это позволяет использовать RationalTest для выполнения тестов через Google Test.
Затем в коде описываются юнит-тесты. Для создания теста используется макрос TEST, который принимает два аргумента: название тестового класса (RationalTest) и название теста (AdditionTest).
Макрос EXPECT_EQ позволяет убедиться, что два значения, переданные в качестве его аргументов, равны. Если это условие выполняется, тест считается пройденным.
Функция main инициализирует Google Test с аргументами командной строки (int argc и char **argv), а команда RUN_ALL_TESTS() запускает выполнение всех тестов.
Как и во многих других фреймворках, в Google Test используются макросы — специальные директивы препроцессора, которые позволяют писать тесты в удобной форме. Далее представлен список наиболее распространённых макросов.
EXPECT_EQ(actual_value, true_value): проверяет равенство двух значений. Если они не равны, тест не проходит.
EXPECT_NE(actual_value, true_value): проверяет, что два значения не равны.
EXPECT_LT(value_1, value_2): проверяет, что value_1 меньше value_2.
EXPECT_GT(value_1, value_2): проверяет, что value_1 больше value_2.
EXPECT_TRUE(condition): проверяет, что условие истинно.
EXPECT_FALSE(condition): проверяет, что условие ложно.
Префикс EXPECT_ можно заменить на ASSERT_. В первом случае при падении теста программа продолжит выполнение, во втором — завершится с ошибкой.
После завершения тестирования Google Test выводит в консоль отчет, показывающий, что все тесты успешно пройдены. Если какой-либо тест не проходит, отчёт включает в себя информацию о месте и причине сбоя, что значительно облегчает отладку.
Подробная документация Google Test.
Фреймворк Catch2
Catch2 во многом похож на Google Test. Он также поддерживает различные виды тестов и формирует отчёты. У него меньше встроенных функций, но это компенсируется простотой использования — его легче настраивать и интегрировать в проекты.
Вот как будут выглядеть тесты для Rational.
#define CATCH_CONFIG_MAIN  // Эта строка создаёт функцию main.
#include <catch2/catch.hpp>
#include "rational.h" 

// Тест для конструктора.
TEST_CASE("Rational constructor", "[Rational]") {
    Rational r = Rational(3, 4);
    REQUIRE(r.GetNumerator() == 3);
    REQUIRE(r.GetDenominator() == 4);
}

// Тест для сложения.
TEST_CASE("Rational addition", "[Rational]") {
    Rational r = Rational(1, 5) + Rational(2, 5);
    REQUIRE(r.GetNumerator() == 3);
    REQUIRE(r.GetDenominator() == 5);
}
Чтобы объявить тест, используется макрос TEST_CASE, который принимает два параметра: название теста и список тегов, которые указываются в квадратных скобках. Теги можно использовать для логической группировки тестов — например, в нашем случае все тесты, связанные с классом Rational, имеют тег [Rational]. Также они позволяют фильтровать тесты, которые нужно запустить: можно выбрать или, наоборот, исключить тесты с определёнными тегами.
Проверка результата выполняется с помощью макроса REQUIRE(expression).
К другим популярным макросам относятся CHECK(expression), который, в отличие от REQUIRE, продолжает выполнять тестовый случай, даже если какая-то из проверок провалена, REQUIRE_EQ(actual_value, true_value) и другие.
Подробная документация Catch2 доступна на GitHub.
Помимо макросов, у фреймворков есть другие инструменты, упрощающие проверку кода. Например, существуют механизмы Setup и Teardown, которые позволяют выполнять определённые действия до и после каждого теста — благодаря этому можно не писать один и тот же код во всех тестах. Setup можно использовать для инициализации исходных переменных, чтения из файла и подключения к базе данных. Teardown применяется для освобождения ресурсов, закрытия соединений и т. д.
Изучив принципы работы одного фреймворка, вы без труда сможете освоить и другие.
Зачем нужны моки
Как правило, настоящие приложения состоят из большого количества независимых компонентов, взаимодействующих друг с другом. Чтобы проверить работу одной части, нужно использовать и другие, что может усложнить тестирование. В таких случаях на помощь приходят моки (от англ. mock — «подражание») — специальные объекты, которые заменяют компоненты приложения, имитируя их работу.

Моки могут выполнять следующие функции:
Замена сложных зависимостей простыми объектами. Например, подключение к настоящей базе данных может быть сложным и долгим процессом (или вовсе недоступным в тестовой среде). Вместо него можно использовать мок, который возвращает заранее подготовленную информацию.
Изоляция от внешних систем. Если приложение использует сетевые запросы, имеет смысл заменить сетевое подключение на моки. Это позволит тестам получать стабильные данные, которые не будут зависеть от состояния сети.
Контроль данных. Моки позволяют задавать определённые данные, которые должен возвращать элемент системы. Например, если в программе используется генератор случайных чисел, тестировать её может быть сложно. (Представьте, что вы пишете тесты для игры «Камень, ножницы, бумага», в которой фигура компьютера выбирается случайно.) Замена генератора случайных чисел на мок значительно упростит тестирование.
Контроль вызовов. Моки можно использовать вместо настоящих объектов, чтобы подсчитать, какие методы вызывались и сколько раз.
Вы уже встречали моки, когда разрабатывали приложение «Фотоальбом». Вместо объекта QTimer в нём использовался prac::QTimer, который внешне работал так же, но при этом позволял протестировать код.
Представьте, что вы создали приложение, способное распознавать картины по фотографиям и предоставлять информацию о картинах и художниках. 
Тестирование в Qt
Вы изучили базовые принципы юнит-тестирования программ с помощью фреймворков, познакомившись с Google Test и Catch2. В этом уроке вы разберетесь, как писать тесты для приложений, разработанных на Qt.
Добавляем тесты в проект
Qt имеет собственную библиотеку для написания тестов — QTestLib, которая является частью фреймворка и не требует отдельной установки. Эта библиотека позволяет тестировать пользовательские интерфейсы и другие компоненты графических приложений, с которыми бывает сложно работать через стандартные фреймворки.
Рассмотрим работу с библиотекой на примере простого приложения Converter, которое переводит километры в мили и обратно. Его код вы найдёте в папке sprint5/logs-for-converter.

Как вы уже знаете, хорошей практикой считается возможность запускать тесты отдельно от основной программы. Поэтому для тестирования в Qt Creator создаётся так называемый проект с подпроектами — специальный проект, который не содержит код, но в котором могут быть папки других проектов. В нашем случае таких папок будет две: с приложением и с тестами. Это позволит собирать их в разные исполняемые файлы.
Чтобы создать проект с подпроектами, выберите в окне создания пункт «Другой проект», затем «Проект с поддиректориями». Далее, как обычно, укажите название и расположение.

После создания корневого проекта Qt Creator предложит создать для него первый подпроект. Вместо этого можно добавить готовый проект, который станет подпроектом. Для этого разместите папку с проектом в корневом проекте, а затем в Qt Creator кликните правой кнопкой мыши по названию корневого проекта, выберите пункт «Добавить существующие проекты» и выберите готовый проект.
Чтобы добавить ещё один подпроект (с тестами), кликните правой кнопкой мыши по названию корневого проекта и выберите пункт «Создать подпроект».

В открывшемся окне выберите «Test Project» и «Qt Test Project».

После этого дайте название проекту с тестами (например, «Tests + имя приложения»).
В окне с информацией о проекте поставьте галочки у всех пунктов.
Опции «Требуется QApplication» и «Приложение с GUI» нужны для тестирования элементов интерфейса, таких как события и виджеты. Если вы собираетесь проверять только не-GUI-компоненты, эти пункты можно не отмечать.
Опция «Создать код инициализации и очистки» добавляет в проект шаблон кода для методов инициализации и очистки (Setup и Teardown).

В результате мы получили корневую папку (в нашем случае с названием Example), которая содержит два проекта: Converter и TestConverter.

В TestConverter был автоматически сгенерирован файл tst_testconverter.cpp с шаблоном для юнит-тестов. Давайте посмотрим на него поближе.
#include <QCoreApplication>
#include <QtTest>
// Главный класс для тестирования, наследуется от QObject.
class TestConverter : public QObject
{
    Q_OBJECT

public:
    TestConverter();
    ~TestConverter();

// Список тестовых функций.
private slots:
    void initTestCase();
    void cleanupTestCase();
    void test_case1();
};
...
// Генерация функции main.
QTEST_MAIN(TestConverter) 
#include "tst_testconverter.moc"


Структура тестов имеет сходство с другими фреймворками: есть главный класс TestConverter и сами юнит-тесты (объявляются как его методы). Чтобы работать с Qt, TestConverter наследуется от класса QObject.
В секции private slots перечисляются тестовые функции. Здесь же объявлено несколько вспомогательных функций, сгенерированных Qt Creator:
initTestCase() — это слот, который вызывается перед выполнением всех тестов. Если одно и то же действие нужно выполнять перед каждым тестом, можно воспользоваться слотом init().
cleanupTestCase() вызывается после тестов (например, для удаления ресурсов).
test_case1() — пример тестовой функции.
После класса следует макрос QTEST_MAIN(TestConverter), который генерирует функцию main() для запуска тестов.
Чтобы наши тесты скомпилировались, в файл TestConverter.pro нужно добавить пути к исходным файлам проекта Converter.
...
CONVERTER_PATH = ../Converter

INCLUDEPATH += $$CONVERTER_PATH

SOURCES +=  tst_testconverter.cpp \
    $$CONVERTER_PATH//mainwindow.cpp

HEADERS +=  \
    $$CONVERTER_PATH//mainwindow.h
    
FORMS += \
    $$CONVERTER_PATH//mainwindow.ui
Затем к tst_testconverter.cpp нужно подключить заголовочный файл из исходного приложения.
#include <QCoreApplication>
#include <QtTest>

#include <mainwindow.h> // Заголовочный файл из Converter.

class TestConverter : public QObject { ... }
Теперь всё готово к написанию тестов. Давайте вспомним основные свойства юнит-тестирования: тесты должны быть автоматическими и независимыми друг от друга, а также должны проверять отдельные компоненты кода.
Написание тестов
Начнём с простого примера: протестируем функцию, которая конвертирует значения, не взаимодействуя с пользовательским интерфейсом.
double MainWindow::ConvertToMiles(double km) {
    return km * 0.621371;
}
Добавим в TestConverter юнит-тест для ConvertToMiles.
void TestConverter::TestMilesToKm() {
    auto converter = MainWindow();

    QCOMPARE(converter.ConvertToMiles(0), 0);
    QCOMPARE(converter.ConvertToMiles(0.1), 0.0621371);
    QCOMPARE(converter.ConvertToMiles(10),  6.213712);
}
Макрос QCOMPARE позволяет сравнить два значения, в том числе представленные типом double. При этом значение, вычисляемое функцией, должно быть первым параметром, а правильное — вторым.
Среди других макросов Qt Test часто используются следующие:
QVERIFY — используется для проверки условия.
QVERIFY2 — аналогичен QVERIFY, но позволяет добавить дополнительное сообщение, которое выводится в случае провала теста.
QFAIL — вызывает ошибку теста с указанным сообщением, независимо от каких-либо условий. Используется для случаев, когда нужно специально пометить тест как неудавшийся.
В инструментах Qt Creator есть отдельный раздел, позволяющий управлять запуском тестов. Можно выбрать нужные тесты или запустить сразу все.

Отчёт с результатами появится во вкладке «Результаты тестирования». В случае успешного прохождения тестов они будут отмечены зелёным маркером.

Если какой-нибудь тест провалится, можно посмотреть подробную информацию о том, что пошло не так: в каком классе и в какой функции возникла ошибка, какая именно проверка не прошла. В нашем случае ожидаемое значение (6.213712) не совпадает с тем, что вернула функция (6.21371).

Тестирование интерфейса
В графических приложениях необходимо проверять не только бизнес-логику, но и работу экранных форм: как программа реагирует на ввод текста, нажатие кнопки и т. д. Qt Test позволяет тестировать элементы интерфейса и имитировать действия пользователя.
Очистим файл tst_testconverter.cpp и создадим в нём новый класс для тестирования виджета: TestMainWindow. Чтобы он мог обращаться к приватному элементу ui из класса MainWindow, его нужно сделать дружественным классом.
class MainWindow : public QMainWindow
{
    ...
    friend class TestMainWindow;
    ...
private:
    Ui::MainWindow *ui;
}
Напишем простой тест TestConstruction, который будет проверять, что экранная форма создана правильно и содержит все нужные элементы.
#include "ui_mainwindow.h" // Добавляем для работы с ui.

class TestMainWindow : public QObject
{
...
private slots:
    void TestConstruction();
    
private:
    MainWindow converter;
};

// Убедимся, что окно содержит все нужные элементы.
void TestMainWindow::TestConstruction() {
    QVERIFY2(converter.ui->txt_km_input, "Не найден элемент для ввода километров");
    QVERIFY2(converter.ui->btn_convert_to_miles, "Не найдена кнопка для конвертации километров");
    // Поиск остальных элементов.
}

QTEST_MAIN(TestMainWindow) 

#include "tst_testconverter.moc"
Рассмотрим пример теста для более сложного поведения: когда пользователь пытается конвертировать в мили нечисловое значение, вместо результата должно появляться сообщение: «Неверный ввод для километров».

Напишем тест, который будет имитировать ввод текста и нажатие на кнопку, а затем проверять результат.
void TestMainWindow::TestWrongMilesInput() {
    QTest::keyClicks(converter.ui->txt_miles_input, "Not a number"); // Ввод.
    QTest::mouseClick(converter.ui->btn_convert_to_km, Qt::LeftButton); // Нажатие на кнопку.
    
    QVERIFY2( // Проверка, что появилось сообщение.
        !converter.ui->result_label_km->text().isEmpty(),
        "Error message is not printed"
    );
    QVERIFY2( // Проверка текста сообщения.
        converter.ui->result_label_km->text() == "Invalid input for miles",
        "Incorrect error text"
    );
}
Функция QTest::keyClicks позволяет записывать текст в указанное поле, а QTest::mouseClick имитирует нажатие кнопки мыши (в нашем случае левой).
С помощью Qt Test можно проверять не только содержимое элементов, но и их свойства, что особенно полезно в случаях, когда они меняются с помощью кода. Например, можно убедиться, что кнопка не заблокирована и имеет заданные минимальные размеры.
void TestMainWindow::TestButton() {
    QVERIFY2(
        converter.ui->btn_convert_to_milesa->isEnabled(), 
        "The button is blocked"
        );
    QVERIFY2(
        converter.ui->btn_convert_to_milesa->minimumSize() == QSize(50, 10), 
        "Incorrect button size"
    );
}
Тестирование приложений в Qt имеет свои особенности. Тесты должны храниться в собственном подпроекте, который использует код из основной программы. Они могут проверять как обычные функции и классы, так и работу интерфейса.
Встроенная библиотека QTestLib даёт широкие возможности для работы с элементами окна. С её помощью можно проверять их свойства, вводить значения и имитировать нажатия кнопок.
Однако, несмотря на все эти особенности, основные принципы написания юнит-тестов остаются неизменными: тесты должны проверять отдельные варианты поведения кода, а также быть небольшими и независимыми.
Введение в логирование
Вывод промежуточных результатов
В общем случае под логированием подразумевается вывод информации о работе программы (запущенных функциях, текущих значениях переменных и т. д.), что позволяет следить за ходом ее выполнения.
Даже если ранее вы не встречали этот термин, идея подхода наверняка вам знакома: вы могли использовать вывод в консоль, чтобы видеть промежуточные результаты при написании сложного кода.
В качестве примера рассмотрим функцию FindMaxIndex, которая ищет индекс максимального элемента вектора, но делает это с ошибкой.
#include <iostream>
#include <vector>

int FindMaxIndex(const std::vector<int>& nums) {
    if (nums.empty()) {
        return -1;
    }
    int maxIndex = 0;
    for (int i = 1; i <= nums.size() ; ++i) {
        if (nums[i] >= nums[maxIndex]) {
            maxIndex = i;
        }
    }
    return maxIndex;
}

int main() {
    std::cout<< FindMaxIndex({10, 5, 627, 1000}) << std::endl; // Результат равен 4.
}
Чтобы понять, почему функция работает неправильно, выведем список обрабатываемых элементов и промежуточные значения максимума.
int FindMaxIndex(const std::vector<int>& nums) {
    if (nums.empty()) {
        return -1;
    }
    int maxIndex = 0;
    std::cout << "First max = " << nums[maxIndex] << std::endl;
    
    for (int i = 1; i <= nums.size() ; ++i) {
        std::cout << "vector[" << i << "] = " << nums[i];
        if (nums[i] >= nums[maxIndex]) {
            std::cout << " New max = " << nums[i];
            maxIndex = i;
        }
        std::cout << std::endl;
    }
    return maxIndex;
}

int main() {
    std::cout<< FindMaxIndex({10, 5, 1000, 627}) << std::endl; // Результат равен 4.
}
// Вывод:
// First max = 10
// vector[1] = 5
// vector[2] = 1000 New max = 1000
// vector[3] = 627
// vector[4] = 12376876 New max = 12376876
Теперь видно, где именно возникает ошибка: в цикле for переменная i выходит за пределы вектора. Есть компиляторы, с которыми такое поведение вызовет исключение, но в нашем примере происходит обращение к области памяти со случайным значением (числом 12376876), которое принимается за максимум.
Вывод промежуточных значений называется отладочной печатью. Этот метод отладки очень популярен: он простой, быстрый и позволяет легко отслеживать изменения переменных. Если вы используете систему контроля версий (например, Git), добавленные строки для печати можно легко убрать, откатив проект к предыдущему коммиту.
Но у этого подхода есть и недостатки. Например, чтобы проконтролировать каждый шаг выполнения программы, нужно дописать очень много строк с выводом, что занимает время и засоряет код.
Ведение логов
Отладочные печати — это упрощенный способ логирования, применяемый на этапе разработки. В готовых проектах информация о действиях программы сохраняется в логах — специальных текстовых файлах, которые хранят историю работы системы. Благодаря этому можно не только следить за действиями приложения, но и анализировать их постфактум.
В C++ существуют различные библиотеки, которые упрощают процесс логирования и позволяют указывать, какие данные должны записываться в логи (например, время и название функции).
Рассмотрим небольшой пример: у нас имеется приложение для решения квадратных уравнений, которое в большинстве случаев дает правильные ответы, но иногда без видимых причин прекращает работу с ошибкой. К счастью, в этом приложении настроено логирование: в файл с логами записывается условие каждого уравнения, промежуточные шаги с расчётом дискриминанта и получившийся ответ. Достаточно заглянуть в логи, чтобы увидеть, при каких входных данных приложение падает и на каком этапе решения это происходит.
Типичные записи в логах (лог-сообщениях) выглядят следующим образом.
[2023-10-10 14:23:45] [INFO] [EquationSolver] Received input: a=2, b=5, c=-3
[2023-10-10 14:23:45] [DEBUG] [EquationSolver] Calculated discriminant: D=49
[2023-10-10 14:23:45] [INFO] [EquationSolver] Roots calculated: x1=0.5, x2=-3
[2023-10-10 14:27:30] [INFO] [EquationSolver] Received input: a=1, b=2, c=5
[2023-10-10 14:27:30] [DEBUG] [EquationSolver] Calculated discriminant: D=-16
[2023-10-10 14:27:30] [CRITICAL] [EquationSolver] Attempted to extract square root from negative discriminant: D=-16


Каждая запись содержит:
временную метку (дату и время события);
уровень критичности (например, INFO или DEBUG, о которых мы расскажем позже);
контекст события — название функции или класса;
сообщение с информацией о том, какое действие выполняет программа.
В последней записи мы видим сообщение о том, что код пытается извлечь корень из отрицательного дискриминанта, что, очевидно, и приводит к сбою приложения.
Лог-сообщения различаются по уровням логирования — это способ классификации логов, который отражает важность записанного события. Ниже перечислены основные уровни.
DEBUG: используется для отладки и содержит информацию, нужную для контроля правильности выполнения кода. Например, можно выводить значения переменных и результаты промежуточных вычислений.
INFO: сообщает о важных этапах при нормальном выполнении программы. Например, об успешном завершении операции.
WARN: указывает на потенциально проблемные ситуации, которые могут привести к ошибкам. Примерами могут служить превышение лимита памяти или получение комплексных корней уравнения.
ERROR: сообщает об ошибках, которые влияют на выполнение операции, но не приводят к завершению программы. Например, такой уровень может иметь запись об ошибке при сохранении данных в файл.
CRITICAL (или FATAL): указывает на серьёзные ошибки, которые могут прервать выполнение программы. В примере с квадратными уравнениями такой уровень получила запись о попытке извлечь корень из отрицательного числа.
Логирование в Qt
Логирование особенно полезно в работе над графическими приложениями. Фреймворк Qt предоставляет специальные макросы, которые можно использовать как для ведения логов, так и для отладочных печатей. Эти макросы соответствуют основным уровням логирования: qDebug(), qInfo(), qWarning(), qCritical() и qFatal().
Чтобы их использовать, нужно подключить заголовочный файл QDebug.
#include <QDebug>
...
qInfo() << "Вывод сообщения уровня Info";
qDebug() << "Вывод сообщения уровня Debug";
qWarning() << "Вывод сообщения уровня Warning";
qCritical() << "Вывод сообщения уровня Critical";
В этом примере макросы применяются с синтаксисом в стиле C++. Помимо него, они поддерживают запись в стиле C:
qInfo("Вывод сообщения Info в стиле C");
На практике лучше использовать стиль C++.
Как и другие объекты для вывода значений, макросы логирования можно перегружать для собственных типов. Например, для std::map.
QDebug operator<<(QDebug debug, const std::map<std::string, std::string> &map) {
    debug << "Map(";
    for (auto it = map.begin(), end = map.end(); it != end; ++it) {
        debug << QString::fromStdString(it->first) 
              << ": " 
              << QString::fromStdString(it->second);
        if (std::next(it) != end) {
            debug << ", ";
        }
    }
    debug << ")";
    return debug;
}

...
qDebug() << sampleMap;

// Напечатает в консоли:
// Map("Т. Пратчетт": "Плоский мир", "Р. Брэдбери": "Лёд и пламя")
При необходимости с помощью макросов можно настраивать и более сложное логирование — например, записывая сообщения в файл.
В этом уроке вы разобрались с концепцией логирования — ведения записей о действиях программы. Самый простой вариант логирования — это отладочные печати, которые выводят информацию прямо в консоль. Этот способ часто применяется в процессе разработки. 
В готовых проектах вместо отладочных печатей принято использовать специальные текстовые файлы (логи) и библиотеки для логирования, которые позволяют записывать не только сообщение, но и вспомогательную информацию, например время и уровень важности.
В следующем уроке вы познакомитесь с отладчиком — еще одним инструментом, упрощающим поиск ошибок в приложениях.
Отладка кода в Qt Creator
Вы уже знакомы с некоторыми инструментами, которые упрощают написание программ и поиск ошибок: логирование, отладочные печати и юнит-тесты. В этом уроке вы разберетесь с ещё одним важным инструментом — отладчиком.
Польза отладки
В прошлой теме вы разрабатывали Qt-приложение для работы со словарём. Давайте вспомним, как оно выглядело.

Одна из функций программы — работа с итератором, указывающим на текущий элемент словаря. Представим, что во время написания кода мы допустили ошибку, из-за которой приложение не просто показывает неверные результаты, а совсем не запускается.

По тексту ошибки можно предположить, что она связана с итератором — где-то в коде он используется неправильно.
Для решения этой проблемы можно использовать отладочные печати: вывести сообщение о вызове каждой функции и напечатать значения переменных. К сожалению, мы не знаем, где именно происходит ошибка, поэтому будем вынуждены проверить все части программы, а если захотим вывести содержимое контейнера std::map, придётся написать цикл. В итоге в нашем коде появится множество лишних строк, а в консоли — большое количество записей о каждом шаге программы.
Чтобы этого избежать, вместо отладочных печатей можно использовать отладчик (его также называют дебаггером). Это инструмент, предназначенный специально для наблюдения за выполнением кода. С его помощью можно выполнить программу по шагам, наблюдая за промежуточными значениями переменных.
Режим отладки в Qt Creator
Чтобы запустить отладчик в среде Qt Creator, выберите сборку в режиме «Отладка» и нажмите кнопку запуска с изображением жука.

Второй способ — нажать клавишу F5. Чтобы выйти из этого режима, используйте сочетание клавиш Shift + F5.
В режиме отладки в сборку приложения включаются дополнительные данные, которые позволяют отладчику контролировать состояние кода. По этой причине приложение работает медленнее, а исходные файлы занимают больше места.
После запуска отладки Qt Creator открывает несколько дополнительных окон.

В нижней части экрана находится панель для управления отладкой. Здесь есть кнопки для установки паузы, перехода к следующему шагу и завершения процесса. В левой половине окна выводится список вызываемых функций, а в правом — список точек остановки (о них вы узнаете далее). В правом окне отображается список переменных и их текущие значения.
Отладчик позволяет выполнять программу, останавливая выполнение кода в определённых местах. Мы можем самостоятельно указать, в каких точках нужно сделать паузу, или позволить отладчику останавливаться только на строках, которые вызывают ошибку.
Для нахождения ошибки из нашего примера подойдёт второй вариант. При запуске программы отладчик остановится, и мы увидим, что переменной iterator не присвоено начальное значение. Теперь проблему легко исправить — нужно проинициализировать итератор Map::iterator iterator = items.begin();.

Точки остановки
Остановка на ошибках — только один из вариантов работы отладчика. В других случаях требуется приостановить выполнение кода в определённых местах (например, чтобы посмотреть текущие значения переменных). В этом случае используются точки остановки (или точки останова).
В коде точки остановки отображаются в виде красных кружков напротив строк, на которых нужно остановиться.

Чтобы установить точку, нужно щёлкнуть на поле слева от номера строки или нажать F9, когда курсор находится на нужной строке. Для удаления точки можно либо щёлкнуть по ней, либо снова нажать F9.
При запуске отладчика в его окнах будет отображена информация о состоянии программы на момент выполнения строки с точкой остановки. Например, для функции FindMax, которая ищет максимум в векторе, точки установлены на строках 9 и 11. Сначала отладчик остановится на строке 9, и справа мы увидим элементы вектора, а также значение переменной max на этом этапе.

Для перехода к следующей точке остановки используется клавиша F5. Перейдя к строке 11, мы увидим новые значения переменных.

Точки остановки могут быть обычными или условными. Обычные срабатывают каждый раз, когда программа доходит до указанной строки, а условные — только если в этот момент выполняется заданное условие.
Чтобы добавить условие для точки остановки, нужно щелкнуть по кружку правой кнопкой мыши и выбрать пункт Изменить точку останова. В открывшемся окне в поле Условие можно ввести любое условное выражение, которое будет проверяться в этом месте программы.

В нашем примере условная точка сработает, только когда переменная num будет равна 2.
Точки остановки можно настраивать и более сложными способами: например, они могут срабатывать при возникновении ошибки конкретного типа или при изменении определенного места в памяти.
В сложных программах может быть гораздо больше данных, и тогда искать нужные переменные в общем списке становится неудобно. К счастью, в отладчике можно указать, какие именно переменные нас интересуют: для этого нужно найти их в коде, щелкнуть правой кнопкой мыши и выбрать пункт Добавить вычисляемое выражение. После этого выбранные переменные будут отображаться отдельно в окне Выражения, в правой нижней части экрана.
В нашем примере мы можем отслеживать переменную max.

Дополнительные возможности отладчика
Помимо остановки программы на определенных местах, отладчик обладает еще одной полезной функцией: возможностью выполнять код по шагам, перемещаясь между строками.
Управлять ходом выполнения можно с помощью кнопок на панели окна в нижней части экрана.

Кнопка Пауза (синего цвета) служит для приостановки работы программы. Это особенно удобно, когда в приложении происходят долгие вычисления или если оно зависло. Нажав на кнопку, можно возобновить работу.
Кнопка Остановить отладчик (красного цвета) завершает текущую сессию отладки. Вместо неё можно использовать сочетание клавиш Shift + F5.
Кнопка Перейти через (англ. Step Over) выполняет текущую строку кода и переходит к следующей, не заходя внутрь функций. Например, в представленном коде отладчик перейдёт со строки 18 на строки 19 и 20, не останавливаясь на функции FindMax. Вместо этой кнопки можно использовать клавишу F10.
Кнопка Войти в (англ. Step Into) позволяет перейти внутрь функции, вызываемой в текущей строке. В нашем примере после строки 19 отладчик перешёл бы к первой строке FindMax, имеющей номер 5. Горячая клавиша для этой функции — F11.
Кнопка Выйти из функции (англ. Step Out) позволяет выйти из функции, пропустив оставшуюся часть её кода, и перейти к следующей строке после её вызова. Нажав эту кнопку, мы бы переместились со строки 5 на строку 20. Для этой функции используется сочетание Shift + F11.
Кнопка Перезапуск отладки останавливает текущую сессию отладчика и запускает её заново. Вместо неё можно использовать сочетание Ctrl + Shift + F5.
В нижнем окне можно увидеть стек вызовов — список функций, которые были вызваны, но на момент остановки ещё не завершились. В нашем примере список содержит две функции, определённые в программе: FindMax, на которой остановился отладчик, и main, которая её вызывает.
Каждый уровень стека отображает имя функции, её параметры, название файла и номер строки, где она была вызвана. Благодаря этому списку можно проанализировать, каким образом программа дошла до текущей точки выполнения.
Существуют и другие отладчики, например LLDB, Valgrind и Visual Studio Debugger. Каждый из них имеет свои особенности и подходит для различных задач.
В этом уроке вы узнали, как использовать отладчик для анализа кода: с его помощью можно находить строки, вызывающие ошибки, останавливать программу в заранее определённых местах или выполнять её построчно.
Отладчик предоставляет подробную информацию о состоянии программы, включая вызовы функций и значения переменных. Это упрощает отслеживание действий приложения и избавляет от необходимости использовать отладочные печати.
Большинство существующих IDE имеют встроенные отладчики, работающие по схожим принципам. Освоив один, вы без труда сможете научиться использовать и другие.
В следующем уроке мы расскажем, как работает механизм исключений и как с его помощью писать программы, способные обрабатывать критические ошибки.
Исключения
Зачем нужны исключения
Вспомним случаи, когда запущенная программа сталкивалась с проблемой и прерывала работу. Это могло быть обращение к элементу вектора с несуществующим индексом или попытка перевести неподходящую строку в число. Например, в классе Rational с помощью команды std::abort происходила остановка программы, если знаменатель дроби равнялся нулю.
Эти ситуации объединяет то, что с возникшей ошибкой программа не могла продолжать выполнение. Проблему нельзя было проигнорировать, и о ней нужно было сообщить.
Эту задачу решает механизм исключений. Исключение — это специальный объект, который создаётся в случае исключительной ситуации и содержит информацию о ней. При генерации исключения нормальный порядок выполнения кода прерывается, и программа либо находит код для обработки ошибки, либо завершает работу.
Вы неоднократно сталкивались со стандартными исключениями. Например, при использовании неверного индекса возникает исключение std::out_of_range («выход за пределы диапазона»), а при некорректном переводе в число — std::invalid_argument («недопустимый аргумент»). Такие исключения генерируются программой автоматически.
Не все критические проблемы выбрасывают исключения. Бывают ситуации, которые вместо этого приводят к неопределённому поведению или ошибкам компиляции. Это происходит, потому что исключения позволяют обрабатывать ошибки на уровне языка, в то время как подобные случаи требуют других подходов к исправлению. Например, утечка памяти или использование неинициализированной переменной не считаются исключительными ситуациями, поскольку эти проблемы нужно решать на уровне разработчика.
Обработка исключений
Мы уже упоминали, что исключения можно перехватывать и обрабатывать в коде, благодаря чему проблема решается, и программа продолжает работу. В противном случае она либо завершается, либо демонстрирует неопределённое поведение.
Для обработки исключений в C++ существует конструкция try-catch. В блок try помещается код, который потенциально может выбросить исключение, а в блоке catch — действия, которые нужно выполнить в этом случае.
try {
    std::string str = "Geronimo";
    str.at(8) = '!'; // Попытаемся изменить символ за пределами строки.
} catch (const std::exception& e) {
    std::cerr << "Ошибка: " << e.what() << std::endl;
}
// Вывод:
// Ошибка: basic_string::at: __n (which is 8) >= this->size() (which is 8)
В этом примере в блоке try происходит ошибка, вызывающая исключение std::out_of_range, которое затем перехватывается и обрабатывается в блоке catch. Метод what() выводит стандартное сообщение о полученной ошибке.
Запись catch (const std::exception& e) значит, что catch отреагирует на любое исключение, в том числе std::out_of_range.
Тип std::exception является общим для исключений и содержит более специфичные типы. В их числе, например:
std::runtime_error — для ошибок во время выполнения программы. К этому типу относятся такие исключения, как std::range_error и std::overflow_error.
std::logic_error — для ошибок, которые можно найти до выполнения, например std::invalid_argument или std::out_of_range.
std::bad_cast — ошибки, возникающие из-за неудачного динамического приведения типов.

Такая структура позволяет обрабатывать ошибки на разном уровне детализации: от самых общих, когда неважно, что именно пошло не так, до очень специфических, когда нужно точно знать тип исключения. Например, следующий код обработает любое исключение типа std::runtime_error, будь то std::range_error, std::overflow_error или другие.
catch (const std::runtime_error& e) { ... }
А в этом примере обработчик отреагирует только на исключение std::range_error.
catch (const std::range_error& e) { ... }
При наличии нескольких подходящих обработчиков выбирается самый специфичный, то есть тот, который находится ниже в иерархии исключений. Поэтому в коде важно располагать обработчики от более специфичных к более общим.
Как вызывается подходящий catch? 
При возникновении исключения программа начинает искать ближайший подходящий блок catch. Если он находится в той же функции, то он вызывается, чтобы обработать проблему. Код выполняется дальше. 
Если функция, в которой было вызвано исключение, не имеет подходящего обработчика, она завершается, а исключение передается функции, которая ее вызвала, и ищет catch в ней. Это может продолжаться вплоть до функции main. Если обработчик не найдётся на всём стеке вызовов, код завершится с ошибкой. 
void InnerFunction() {
    // Код, который генерирует исключение типа А.
}
void MiddleFunction() {
    try {
        InnerFunction();
    } catch (<исключение типа B>) { ... } // Не подходит.
    // Функция прервётся, а исключение А перейдёт к OuterFunction.
    ...
}
void OuterFunction() {
    try {
        MiddleFunction();
    } catch (<исключение типа А>) { 
            // Здесь обработается ошибка из InnerFunction.
    }
}
Вызов исключений
Кроме стандартных случаев генерации исключений, в C++ можно вызывать исключения самостоятельно. Это полезно в тех ситуациях, когда ваши классы или функции сталкиваются с проблемой, которая нарушает их работу.
В примере с классом Rational такой проблемой была попытка создать дробь с нулевым знаменателем. Ранее в этом случае вы использовали команду std::abort, чтобы остановить программу. Вместо этого можно сгенерировать исключение, которое класс будет «выбрасывать» наружу и которое можно обработать. Это делается с помощью команды throw.
#include <iostream>
#include <numeric>
#include <stdexcept> // Для std::runtime_error.

class Rational {
public:
    Rational(int numerator, int denominator)
    : numerator_(numerator)
    , denominator_(denominator) {
        if (denominator_ == 0) {
            // Вместо std::abort() генерируем исключение.
            throw std::runtime_error("Деление на ноль!");
    }
    if (denominator_ < 0) {
        numerator_ = -numerator_;
        denominator_ = -denominator_;
    }
    ...
  }    
private:
    int numerator_ = 0;
    int denominator_ = 1;
};

int main() {
    try {
        auto r = Rational(5, 0);
        std::cout << r << std::endl;
    } catch (const std::runtime_error &e) {
        std::cerr << "Ошибка: " << e.what() << std::endl;
    }
    std::cout << "Программа завершается без прерываний." << std::endl;
}
// Вывод:
// Ошибка: Деление на ноль!
// Программа завершается без прерываний.
Запись throw std::runtime_error("Деление на ноль!") выбрасывает стандартное исключение типа std::runtime_error, а в скобках описывается причина ошибки.
При необходимости можно создавать исключения собственного типа. Например, для обработки ошибок, связанных с парсингом строк.
class ParseException {
public: 
    ParseException(std::string message): message_ {message} {}

    std::string GetMessage() const { 
        return message_; 
    }
private:
    std::string message_;
};
Класс ParseException содержит всего одну переменную — для текста ошибки.
Его можно использовать вместе с throw и catch.
...
throw ParseException("Неверный формат строки.");
...

try { ... } 
catch (const ParseException& e) {
    std::cerr << "Ошибка: " << e.GetMessage() << std::endl;
}
Такой подход позволяет использовать исключения для нестандартных задач. В качестве примера рассмотрим функцию VectorFromString, которая принимает строку формата "слово1,слово2,слово3" и преобразовывает её в вектор ["слово1", "слово2", "слово3"].
#include <iostream>
#include <sstream>
#include <vector>

...
std::vector<std::string> VectorFromString(const std::string& input) {
    std::vector<std::string> result;
    std::stringstream ss(input);
    std::string word;
    
    if (input.empty()) {
        throw ParseException("Пустая строка.");
    }
    if ( // Убедимся, что в строке нет лишних символов и пробелов.
        input.front() == ',' || 
        input.back() == ',' || 
        input.find(' ') != std::string::npos
        ) {
            throw ParseException("Неверный формат строки.");
    }
    while (std::getline(ss, word, ',')) {
        if (word.empty()) {
            throw ParseException("Неверный формат строки.");
        }
        result.push_back(word);
    }
    return result;
}
При любой ошибке парсинга функция выбрасывает ParseException с соответствующим сообщением. Исключение попадает в нужный обработчик и не пересекается с другими.
try {
    auto words = VectorFromString("");
} catch (const ParseException& e) { 
    std::cerr << "Ошибка: " << e.GetMessage() << std::endl;
}
try {
    auto words = VectorFromString("мяу ,, мяу");
} catch (const ParseException& e) {
    std::cerr << "Ошибка: " << e.GetMessage() << std::endl;
}
try {
    auto words = VectorFromString("мяу,мяу");
    std::cout << "Функция отработала без ошибок.";
} catch (const ParseException& e) {
    std::cerr << "Ошибка: " << e.GetMessage() << std::endl;
}
// Вывод:    
// Ошибка: Пустая строка.    
// Ошибка: Неверный формат строки.
// Функция отработала без ошибок.
В этом уроке рассмотрен простой способ создания своих исключений. В более сложных ситуациях вы можете сделать исключение собственного типа частным случаем другого исключения, например std::runtime_error. Для этого используют наследование, которое вы изучите далее.

Дополнительный материал для экзамена (C++17 и лучшие практики для тестирования и исключений)

Современные подходы к тестированию в C++17

1. Использование auto и структурированных привязок в тестах
// До C++17
std::pair<bool, std::string> result = ValidateInput("test");
EXPECT_TRUE(result.first);
EXPECT_EQ(result.second, "valid");

// С C++17
auto [is_valid, message] = ValidateInput("test");
EXPECT_TRUE(is_valid);
EXPECT_EQ(message, "valid");

2. Тестирование с std::optional
#include <optional>

std::optional<int> ParseInt(const std::string& str) {
    try {
        return std::stoi(str);
    } catch (...) {
        return std::nullopt;
    }
}

// Тестирование
TEST(ParseIntTest, ValidInput) {
    auto result = ParseInt("123");
    ASSERT_TRUE(result.has_value());
    EXPECT_EQ(*result, 123);
}

TEST(ParseIntTest, InvalidInput) {
    auto result = ParseInt("abc");
    EXPECT_FALSE(result.has_value());
}

3. Тестирование с std::variant
#include <variant>

using Result = std::variant<int, std::string>; // Успех или ошибка

Result Divide(int a, int b) {
    if (b == 0) {
        return std::string("Division by zero");
    }
    return a / b;
}

// Тестирование
TEST(DivideTest, ValidDivision) {
    auto result = Divide(10, 2);
    ASSERT_TRUE(std::holds_alternative<int>(result));
    EXPECT_EQ(std::get<int>(result), 5);
}

TEST(DivideTest, DivisionByZero) {
    auto result = Divide(10, 0);
    ASSERT_TRUE(std::holds_alternative<std::string>(result));
    EXPECT_EQ(std::get<std::string>(result), "Division by zero");
}

Продвинутые техники тестирования

1. Параметризованные тесты
class CalculatorTest : public ::testing::TestWithParam<std::tuple<int, int, int>> {};

TEST_P(CalculatorTest, Addition) {
    auto [a, b, expected] = GetParam();
    EXPECT_EQ(Calculator::Add(a, b), expected);
}

INSTANTIATE_TEST_SUITE_P(
    AdditionTests,
    CalculatorTest,
    ::testing::Values(
        std::make_tuple(1, 2, 3),
        std::make_tuple(0, 0, 0),
        std::make_tuple(-1, 1, 0),
        std::make_tuple(100, -50, 50)
    )
);

2. Тестирование с временными ограничениями
TEST(PerformanceTest, SortingPerformance) {
    std::vector<int> data(100000);
    std::iota(data.rbegin(), data.rend(), 1); // Заполняем в обратном порядке
    
    auto start = std::chrono::high_resolution_clock::now();
    std::sort(data.begin(), data.end());
    auto end = std::chrono::high_resolution_clock::now();
    
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
    EXPECT_LT(duration.count(), 100); // Должно выполниться менее чем за 100мс
}

3. Тестирование исключений с более точной проверкой
TEST(ExceptionTest, SpecificExceptionMessage) {
    EXPECT_THROW({
        try {
            ThrowingFunction();
        } catch (const std::runtime_error& e) {
            EXPECT_STREQ("Expected error message", e.what());
            throw; // Повторно выбрасываем для EXPECT_THROW
        }
    }, std::runtime_error);
}

Современные практики логирования

1. Структурированное логирование
#include <sstream>
#include <iomanip>

class StructuredLogger {
public:
    enum Level { DEBUG, INFO, WARN, ERROR, CRITICAL };
    
    template<typename... Args>
    void Log(Level level, const std::string& message, Args&&... args) {
        std::ostringstream oss;
        oss << "[" << GetTimestamp() << "] "
            << "[" << LevelToString(level) << "] "
            << FormatMessage(message, std::forward<Args>(args)...) << std::endl;
        
        std::cout << oss.str();
    }
    
private:
    std::string GetTimestamp() {
        auto now = std::chrono::system_clock::now();
        auto time_t = std::chrono::system_clock::to_time_t(now);
        std::ostringstream oss;
        oss << std::put_time(std::localtime(&time_t), "%Y-%m-%d %H:%M:%S");
        return oss.str();
    }
    
    template<typename... Args>
    std::string FormatMessage(const std::string& format, Args&&... args) {
        if constexpr (sizeof...(args) == 0) {
            return format;
        } else {
            // Простое форматирование - в реальности используйте std::format (C++20)
            return format; // Упрощенная версия
        }
    }
    
    std::string LevelToString(Level level) {
        switch (level) {
            case DEBUG: return "DEBUG";
            case INFO: return "INFO";
            case WARN: return "WARN";
            case ERROR: return "ERROR";
            case CRITICAL: return "CRITICAL";
            default: return "UNKNOWN";
        }
    }
};

// Использование
StructuredLogger logger;
logger.Log(StructuredLogger::INFO, "User logged in", "user_id", 123);

2. Логирование с контекстом
class LogContext {
private:
    std::map<std::string, std::string> context_;
    
public:
    LogContext& Add(const std::string& key, const std::string& value) {
        context_[key] = value;
        return *this;
    }
    
    std::string ToString() const {
        std::ostringstream oss;
        for (const auto& [key, value] : context_) {
            oss << key << "=" << value << " ";
        }
        return oss.str();
    }
};

// Использование
LogContext context;
context.Add("function", "ProcessOrder")
       .Add("order_id", "12345")
       .Add("user_id", "67890");

qInfo() << "Processing started" << context.ToString();

Улучшенная обработка исключений в C++17

1. Использование std::exception_ptr для передачи исключений
#include <exception>
#include <future>

std::exception_ptr ProcessAsync() {
    try {
        // Какая-то работа, которая может выбросить исключение
        throw std::runtime_error("Async error");
    } catch (...) {
        return std::current_exception();
    }
    return nullptr;
}

void HandleAsyncResult() {
    auto exception_ptr = ProcessAsync();
    if (exception_ptr) {
        try {
            std::rethrow_exception(exception_ptr);
        } catch (const std::exception& e) {
            std::cerr << "Caught async exception: " << e.what() << std::endl;
        }
    }
}

2. Создание иерархии исключений
class BaseException : public std::exception {
protected:
    std::string message_;
    std::string context_;
    
public:
    BaseException(const std::string& message, const std::string& context = "")
        : message_(message), context_(context) {}
    
    const char* what() const noexcept override {
        return message_.c_str();
    }
    
    const std::string& GetContext() const { return context_; }
};

class ValidationException : public BaseException {
public:
    ValidationException(const std::string& field, const std::string& reason)
        : BaseException("Validation failed: " + reason, "field=" + field) {}
};

class NetworkException : public BaseException {
public:
    NetworkException(const std::string& operation, int error_code)
        : BaseException("Network error during " + operation, "error_code=" + std::to_string(error_code)) {}
};

// Использование
try {
    if (email.empty()) {
        throw ValidationException("email", "Email cannot be empty");
    }
} catch (const ValidationException& e) {
    std::cerr << e.what() << " [" << e.GetContext() << "]" << std::endl;
}

3. RAII для безопасной обработки ресурсов
class FileGuard {
private:
    std::FILE* file_;
    
public:
    explicit FileGuard(const std::string& filename, const std::string& mode)
        : file_(std::fopen(filename.c_str(), mode.c_str())) {
        if (!file_) {
            throw std::runtime_error("Failed to open file: " + filename);
        }
    }
    
    ~FileGuard() {
        if (file_) {
            std::fclose(file_);
        }
    }
    
    // Запрещаем копирование
    FileGuard(const FileGuard&) = delete;
    FileGuard& operator=(const FileGuard&) = delete;
    
    // Разрешаем перемещение
    FileGuard(FileGuard&& other) noexcept : file_(other.file_) {
        other.file_ = nullptr;
    }
    
    FileGuard& operator=(FileGuard&& other) noexcept {
        if (this != &other) {
            if (file_) std::fclose(file_);
            file_ = other.file_;
            other.file_ = nullptr;
        }
        return *this;
    }
    
    std::FILE* Get() const { return file_; }
};

// Использование
try {
    FileGuard file("data.txt", "r");
    // Работа с файлом
    // Файл автоматически закроется при выходе из области видимости
} catch (const std::exception& e) {
    std::cerr << "File operation failed: " << e.what() << std::endl;
}

Продвинутые техники отладки

1. Условная компиляция отладочного кода
#ifdef DEBUG
    #define DEBUG_PRINT(x) std::cout << "[DEBUG] " << x << std::endl
    #define DEBUG_ASSERT(condition) assert(condition)
#else
    #define DEBUG_PRINT(x)
    #define DEBUG_ASSERT(condition)
#endif

void ComplexFunction(const std::vector<int>& data) {
    DEBUG_PRINT("Entering ComplexFunction with " << data.size() << " elements");
    DEBUG_ASSERT(!data.empty());
    
    // Основная логика функции
    for (size_t i = 0; i < data.size(); ++i) {
        DEBUG_PRINT("Processing element " << i << ": " << data[i]);
        // Обработка элемента
    }
    
    DEBUG_PRINT("Exiting ComplexFunction");
}

2. Профилирование производительности
class ScopeTimer {
private:
    std::chrono::high_resolution_clock::time_point start_;
    std::string name_;
    
public:
    explicit ScopeTimer(const std::string& name) 
        : start_(std::chrono::high_resolution_clock::now()), name_(name) {}
    
    ~ScopeTimer() {
        auto end = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start_);
        std::cout << "[TIMER] " << name_ << " took " << duration.count() << " microseconds" << std::endl;
    }
};

#define PROFILE_SCOPE(name) ScopeTimer timer(name)

void ExpensiveOperation() {
    PROFILE_SCOPE("ExpensiveOperation");
    
    // Какая-то дорогая операция
    std::this_thread::sleep_for(std::chrono::milliseconds(100));
}

Интеграция с современными инструментами

1. Использование Sanitizers
// Компиляция с AddressSanitizer:
// g++ -fsanitize=address -g -o program program.cpp

// Компиляция с ThreadSanitizer:
// g++ -fsanitize=thread -g -o program program.cpp

// Компиляция с UndefinedBehaviorSanitizer:
// g++ -fsanitize=undefined -g -o program program.cpp

void TestWithSanitizer() {
    std::vector<int> vec = {1, 2, 3};
    
    // AddressSanitizer поймает выход за границы
    // int value = vec[10]; // Ошибка!
    
    int value = vec[2]; // Корректно
}

2. Статический анализ кода
// Использование clang-tidy:
// clang-tidy program.cpp -checks='*' -- -std=c++17

// Аннотации для статического анализа
[[nodiscard]] int ImportantCalculation(int x, int y) {
    return x * y + 42;
}

void SomeFunction() {
    // Предупреждение: результат функции игнорируется
    // ImportantCalculation(5, 10);
    
    // Корректно
    int result = ImportantCalculation(5, 10);
    std::cout << "Result: " << result << std::endl;
}

Лучшие практики для тестирования и отладки

1. Принципы написания хороших тестов
// ARRANGE - подготовка данных
// ACT - выполнение действия
// ASSERT - проверка результата

TEST(StringUtilsTest, TrimWhitespace) {
    // ARRANGE
    std::string input = "  hello world  ";
    std::string expected = "hello world";
    
    // ACT
    std::string result = TrimWhitespace(input);
    
    // ASSERT
    EXPECT_EQ(result, expected);
}

2. Тестирование граничных случаев
TEST(VectorUtilsTest, FindMaxElement) {
    // Пустой вектор
    std::vector<int> empty_vec;
    EXPECT_THROW(FindMaxElement(empty_vec), std::invalid_argument);
    
    // Один элемент
    std::vector<int> single_vec = {42};
    EXPECT_EQ(FindMaxElement(single_vec), 42);
    
    // Все элементы одинаковые
    std::vector<int> same_vec = {5, 5, 5, 5};
    EXPECT_EQ(FindMaxElement(same_vec), 5);
    
    // Максимум в начале
    std::vector<int> max_first = {10, 2, 3, 4};
    EXPECT_EQ(FindMaxElement(max_first), 10);
    
    // Максимум в конце
    std::vector<int> max_last = {1, 2, 3, 10};
    EXPECT_EQ(FindMaxElement(max_last), 10);
    
    // Отрицательные числа
    std::vector<int> negative = {-5, -1, -10, -3};
    EXPECT_EQ(FindMaxElement(negative), -1);
}

3. Мокирование зависимостей
class DatabaseInterface {
public:
    virtual ~DatabaseInterface() = default;
    virtual bool SaveUser(const User& user) = 0;
    virtual std::optional<User> GetUser(int id) = 0;
};

class MockDatabase : public DatabaseInterface {
public:
    MOCK_METHOD(bool, SaveUser, (const User& user), (override));
    MOCK_METHOD(std::optional<User>, GetUser, (int id), (override));
};

class UserService {
private:
    std::unique_ptr<DatabaseInterface> db_;
    
public:
    explicit UserService(std::unique_ptr<DatabaseInterface> db) : db_(std::move(db)) {}
    
    bool CreateUser(const std::string& name, const std::string& email) {
        if (name.empty() || email.empty()) {
            return false;
        }
        
        User user{0, name, email};
        return db_->SaveUser(user);
    }
};

// Тестирование с мокированием
TEST(UserServiceTest, CreateUserSuccess) {
    auto mock_db = std::make_unique<MockDatabase>();
    
    EXPECT_CALL(*mock_db, SaveUser(testing::_))
        .WillOnce(testing::Return(true));
    
    UserService service(std::move(mock_db));
    
    bool result = service.CreateUser("John Doe", "john@example.com");
    EXPECT_TRUE(result);
}

Обработка ошибок в многопоточной среде

1. Безопасная передача исключений между потоками
#include <thread>
#include <future>

class ThreadSafeProcessor {
public:
    std::future<int> ProcessAsync(int value) {
        return std::async(std::launch::async, [value]() -> int {
            if (value < 0) {
                throw std::invalid_argument("Value must be non-negative");
            }
            
            // Симуляция долгой работы
            std::this_thread::sleep_for(std::chrono::milliseconds(100));
            
            return value * 2;
        });
    }
};

// Использование
ThreadSafeProcessor processor;
auto future = processor.ProcessAsync(-5);

try {
    int result = future.get(); // Исключение будет повторно выброшено здесь
    std::cout << "Result: " << result << std::endl;
} catch (const std::exception& e) {
    std::cerr << "Error: " << e.what() << std::endl;
}

2. Логирование в многопоточной среде
class ThreadSafeLogger {
private:
    mutable std::mutex mutex_;
    std::ofstream file_;
    
public:
    explicit ThreadSafeLogger(const std::string& filename) : file_(filename) {}
    
    template<typename... Args>
    void Log(const std::string& level, Args&&... args) {
        std::lock_guard<std::mutex> lock(mutex_);
        
        auto now = std::chrono::system_clock::now();
        auto time_t = std::chrono::system_clock::to_time_t(now);
        
        file_ << "[" << std::put_time(std::localtime(&time_t), "%Y-%m-%d %H:%M:%S") << "] "
              << "[" << level << "] "
              << "[Thread:" << std::this_thread::get_id() << "] ";
        
        (file_ << ... << args) << std::endl;
    }
};

// Использование в многопоточной среде
ThreadSafeLogger logger("app.log");

void WorkerFunction(int worker_id) {
    try {
        logger.Log("INFO", "Worker ", worker_id, " started");
        
        // Какая-то работа
        if (worker_id % 2 == 0) {
            throw std::runtime_error("Simulated error in worker " + std::to_string(worker_id));
        }
        
        logger.Log("INFO", "Worker ", worker_id, " completed successfully");
    } catch (const std::exception& e) {
        logger.Log("ERROR", "Worker ", worker_id, " failed: ", e.what());
    }
}

Заключение дополнительного материала

Современные практики тестирования и обработки исключений в C++17 значительно улучшают качество и надежность кода. Использование структурированных привязок, std::optional, std::variant и других возможностей C++17 делает тесты более читаемыми и выразительными. Правильная организация иерархии исключений, применение RAII и безопасная работа с ресурсами критически важны для создания устойчивых приложений. Интеграция современных инструментов анализа кода и профилирования помогает выявлять проблемы на ранних стадиях разработки.
