# Ответы на тест "Тесты и исключения в C++" с указанием номеров строк в теории

## Вопрос 1: **B** - Тест, который проверяет работу отдельных частей кода (функций, методов)
**Ссылка на теорию:** строки 114-118
*Объяснение:* Юнит-тесты проверяют работу отдельных частей кода, например функций или методов класса.

## Вопрос 2: **B** - Быть автоматическими, независимыми и быстрыми
**Ссылка на теорию:** строки 152-161
*Объяснение:* Юнит-тесты должны выполняться автоматически, не зависеть друг от друга и быть быстрыми.

## Вопрос 3: **B** - Программа завершится с ошибкой
**Ссылка на теорию:** строки 186-190
*Объяснение:* assert проверяет истинность выражения и вызывает ошибку программы, если оно ложно.

## Вопрос 4: **C** - Написание тестов до реализации кода
**Ссылка на теорию:** строки 169-176
*Объяснение:* TDD предполагает создание тестов до написания кода.

## Вопрос 5: **B** - `#include <cassert>`
**Ссылка на теорию:** строки 182-183
*Объяснение:* Для использования assert нужно подключить заголовочный файл cassert.

## Вопрос 6: **C** - Тест упадет на первой проверке, но выполнит вторую
**Ссылка на теорию:** строки 315-320
*Объяснение:* EXPECT_EQ продолжает выполнение теста даже при ошибке, в отличие от ASSERT_EQ.

## Вопрос 7: **B** - EXPECT_EQ продолжает выполнение теста при ошибке, ASSERT_EQ завершает тест
**Ссылка на теорию:** строки 315-320
*Объяснение:* Префикс EXPECT_ продолжает выполнение при падении теста, ASSERT_ завершает его.

## Вопрос 8: **B** - Объект, который имитирует поведение реального компонента
**Ссылка на теорию:** строки 348-355
*Объяснение:* Моки - это специальные объекты, которые заменяют компоненты приложения, имитируя их работу.

## Вопрос 9: **B** - `TEST_CASE`
**Ссылка на теорию:** строки 329-334
*Объяснение:* В Catch2 для объявления теста используется макрос TEST_CASE.

## Вопрос 10: **C** - Debug message и Info message
**Ссылка на теорию:** строки 431-436
*Объяснение:* Оба макроса qDebug() и qInfo() выведут свои сообщения.

## Вопрос 11: **B** - Запись информации о работе программы в файлы или консоль
**Ссылка на теорию:** строки 420-425
*Объяснение:* Логирование - это вывод информации о работе программы для отслеживания ее выполнения.

## Вопрос 12: **A** - DEBUG, INFO, WARN, ERROR, CRITICAL
**Ссылка на теорию:** строки 481-492
*Объяснение:* Уровни логирования расположены от наименее к наиболее критичным.

## Вопрос 13: **B** - Приостанавливает выполнение программы на указанной строке
**Ссылка на теорию:** строки 642-645
*Объяснение:* Точки остановки используются для приостановки выполнения кода в определенных местах.

## Вопрос 14: **C** - F10
**Ссылка на теорию:** строки 687-690
*Объяснение:* Клавиша F10 используется для пошагового выполнения (Step Over).

## Вопрос 15: **B** - Специальный объект, создаваемый в исключительных ситуациях
**Ссылка на теорию:** строки 712-716
*Объяснение:* Исключение - это специальный объект, который создается в случае исключительной ситуации.

## Вопрос 16: **B** - Exception caught\nProgram continues
**Ссылка на теорию:** строки 731-742
*Объяснение:* Исключение будет перехвачено блоком catch, и программа продолжит выполнение.

## Вопрос 17: **C** - `std::out_of_range`
**Ссылка на теорию:** строки 716-718
*Объяснение:* При выходе за границы контейнера выбрасывается исключение std::out_of_range.

## Вопрос 18: **B** - Программа завершится с ошибкой
**Ссылка на теорию:** строки 754-760
*Объяснение:* std::runtime_error не наследуется от std::logic_error, поэтому исключение не будет поймано.

## Вопрос 19: **B** - `throw std::runtime_error("message");`
**Ссылка на теорию:** строки 791-794
*Объяснение:* Для выброса исключения используется ключевое слово throw.

## Вопрос 20: **A** - Техника автоматического управления ресурсами
**Ссылка на теорию:** строки 1170-1200 (дополнительный материал)
*Объяснение:* RAII - это техника автоматического управления ресурсами через время жизни объектов.

## Вопрос 21: **A** - 5
**Ссылка на теорию:** строки 855-870 (дополнительный материал)
*Объяснение:* Функция вернет std::optional<int> со значением 5 (10/2).

## Вопрос 22: **B** - Делает код более читаемым при работе с парами и кортежами
**Ссылка на теорию:** строки 833-840 (дополнительный материал)
*Объяснение:* Структурированные привязки упрощают работу с составными типами данных.

## Вопрос 23: **B** - Проверяет, что функция выбрасывает исключение типа std::runtime_error
**Ссылка на теорию:** строки 315-320
*Объяснение:* EXPECT_THROW проверяет, что функция выбрасывает исключение указанного типа.

## Вопрос 24: **B** - Методы для подготовки и очистки ресурсов до и после тестов
**Ссылка на теорию:** строки 344-347
*Объяснение:* Setup и Teardown выполняют действия до и после каждого теста.

## Вопрос 25: **B** - "Destructor called\nException: Error"
**Ссылка на теорию:** строки 791-805
*Объяснение:* При выбросе исключения деструктор вызывается до обработки исключения.

## Вопрос 26: **B** - `QCOMPARE`
**Ссылка на теорию:** строки 410-415
*Объяснение:* Макрос QCOMPARE используется для сравнения двух значений в Qt Test.

## Вопрос 27: **B** - Процент строк кода, которые были выполнены во время тестирования
**Ссылка на теорию:** строки 118-122
*Объяснение:* Покрытие кода показывает, какой процент строк был затронут в процессе тестирования.

## Вопрос 28: **B** - Выведет "2"
**Ссылка на теорию:** строки 731-742
*Объяснение:* Обращение к vec.at(1) корректно, так как вектор содержит элементы с индексами 0 и 1.

## Вопрос 29: **B** - Тесты, которые подтверждают работоспособность старого кода
**Ссылка на теорию:** строки 163-166
*Объяснение:* Регрессионные тесты подтверждают работоспособность старого кода после изменений.

## Вопрос 30: **B** - 42
**Ссылка на теорию:** строки 890-910 (дополнительный материал)
*Объяснение:* getValue(true) вернет int со значением 42, который будет выведен.

## Вопрос 31: **B** - Arrange-Act-Assert
**Ссылка на теорию:** строки 1390-1400 (дополнительный материал)
*Объяснение:* AAA означает Arrange (подготовка), Act (действие), Assert (проверка).

## Вопрос 32: **B** - Выводит отладочную информацию только в режиме отладки
**Ссылка на теорию:** строки 1250-1265 (дополнительный материал)
*Объяснение:* Условная компиляция позволяет включать отладочный код только в режиме отладки.

## Вопрос 33: **B** - Ошибка выделения памяти
**Ссылка на теорию:** строки 754-760
*Объяснение:* std::bad_alloc выбрасывается при неудачном выделении памяти.

## Вопрос 34: **B** - Outer catch: Inner error
**Ссылка на теорию:** строки 766-785
*Объяснение:* Исключение не поймано внутренним catch, поэтому передается внешнему обработчику.

## Вопрос 35: **B** - Тесты взаимодействия между компонентами системы
**Ссылка на теорию:** строки 110-114
*Объяснение:* Интеграционные тесты проверяют взаимодействие между компонентами программы.

## Вопрос 36: **B** - Возвращает указатель на текущее обрабатываемое исключение
**Ссылка на теорию:** строки 1110-1125 (дополнительный материал)
*Объяснение:* std::current_exception() возвращает std::exception_ptr для текущего исключения.

## Вопрос 37: **B** - Constructor Destructor Caught
**Ссылка на теорию:** строки 791-805
*Объяснение:* Деструктор вызывается при раскрутке стека перед обработкой исключения.

## Вопрос 38: **A** - `#include <exception>`
**Ссылка на теорию:** строки 1110-1125 (дополнительный материал)
*Объяснение:* std::exception_ptr объявлен в заголовочном файле <exception>.

## Вопрос 39: **B** - Тесты, которые выполняются с разными наборами входных данных
**Ссылка на теорию:** строки 950-970 (дополнительный материал)
*Объяснение:* Параметризованные тесты позволяют запускать один тест с разными данными.

## Вопрос 40: **B** - Time: примерно 100ms
**Ссылка на теорию:** строки 1270-1290 (дополнительный материал)
*Объяснение:* Деструктор Timer измерит время выполнения, которое составит примерно 100 миллисекунд.

## Статистика теста:
- **Общее количество вопросов:** 40
- **Вопросы с примерами кода:** 22 (55%)
- **Вопросы по основам тестирования:** 15 (37.5%)
- **Вопросы по исключениям:** 13 (32.5%)
- **Вопросы по логированию и отладке:** 7 (17.5%)
- **Вопросы по C++17:** 5 (12.5%)

## Покрытие тем:
- ✅ Юнит-тестирование и принципы
- ✅ Фреймворки тестирования (Google Test, Catch2, Qt Test)
- ✅ Логирование и отладка
- ✅ Исключения и их обработка
- ✅ Современные возможности C++17
- ✅ Лучшие практики тестирования
- ✅ RAII и управление ресурсами
- ✅ Многопоточность и исключения 