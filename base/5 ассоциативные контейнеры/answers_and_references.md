# Ответы на тест "Ассоциативные контейнеры в C++" с указанием номеров строк в теории

## Вопрос 1: **B** - Контейнер, где с каждым элементом ассоциирован ключ
**Ссылка на теорию:** строки 8-10
*Объяснение:* Ассоциативные контейнеры - это контейнеры, где с каждым элементом ассоциирован ключ, дающий доступ к этому элементу.

## Вопрос 2: **B** - `#include <map>`
**Ссылка на теорию:** строки 69-70
*Объяснение:* Для работы с std::map необходимо подключить заголовочный файл `<map>`.

## Вопрос 3: **C** - 2
**Ссылка на теорию:** строки 82-90
*Объяснение:* Map содержит 2 элемента: {"apple", 100} и {"banana", 50}.

## Вопрос 4: **C** - По возрастанию ключей
**Ссылка на теорию:** строки 57-58, 146-148
*Объяснение:* Элементы в std::map автоматически сортируются по возрастанию ключей.

## Вопрос 5: **C** - orange_price = 0, в map добавится элемент {"orange", 0}
**Ссылка на теорию:** строки 31-42
*Объяснение:* Если ключ отсутствует, operator[] автоматически добавляет его со значением по умолчанию.

## Вопрос 6: **B** - insert()
**Ссылка на теорию:** строки 170-180
*Объяснение:* Метод insert не переписывает имеющиеся элементы, в отличие от operator[].

## Вопрос 7: **B** - false
**Ссылка на теорию:** строки 180-190
*Объяснение:* insert возвращает пару (итератор, bool). Поскольку ключ "a" уже существует, inserted будет false.

## Вопрос 8: **C** - contains()
**Ссылка на теорию:** строки 200-205
*Объяснение:* Метод contains() проверяет наличие ключа в словаре.

## Вопрос 9: **B** - Возвращает итератор на элемент или end()
**Ссылка на теорию:** строки 210-220
*Объяснение:* find() возвращает итератор на найденный элемент или end() если элемент не найден.

## Вопрос 10: **B** - 1 2 3
**Ссылка на теорию:** строки 146-148
*Объяснение:* Элементы в map автоматически сортируются по ключам, поэтому выводятся в порядке 1, 2, 3.

## Вопрос 11: **C** - Красно-черное дерево
**Ссылка на теорию:** строки 57-62
*Объяснение:* std::map использует красно-черное дерево для хранения элементов.

## Вопрос 12: **B** - Удаляет элемент по ключу или итератору
**Ссылка на теорию:** строки 520-530
*Объяснение:* Метод erase может принимать как ключ, так и итератор для удаления элемента.

## Вопрос 13: **C** - Нет, ключи константные
**Ссылка на теорию:** строки 500-510
*Объяснение:* Ключи в std::map являются константными (const Key), их нельзя изменить.

## Вопрос 14: **B** - 4
**Ссылка на теорию:** строки 665-670
*Объяснение:* В set дублирующие элементы игнорируются, остаются уникальные: {1, 3, 4, 5}.

## Вопрос 15: **B** - set хранит только ключи, map - пары ключ-значение
**Ссылка на теорию:** строки 650-655
*Объяснение:* std::set хранит только уникальные значения, а std::map - пары ключ-значение.

## Вопрос 16: **B** - Позволяет дублирование ключей
**Ссылка на теорию:** строки 46-48
*Объяснение:* std::multimap позволяет хранить несколько элементов с одинаковыми ключами.

## Вопрос 17: **B** - 2
**Ссылка на теорию:** строки 46-48
*Объяснение:* count() возвращает количество элементов с данным ключом. У "Alice" два элемента.

## Вопрос 18: **B** - Быстрее поиск (в среднем)
**Ссылка на теорию:** строки 49-52
*Объяснение:* unordered_map использует хеш-таблицу, что обеспечивает более быстрый поиск в среднем.

## Вопрос 19: **B** - operator== и hash функцию
**Ссылка на теорию:** строки 1080-1100
*Объяснение:* Для unordered_map нужны функция хеширования и оператор равенства.

## Вопрос 20: **B** - Возвращает диапазон элементов с одинаковым ключом
**Ссылка на теорию:** строки 1020-1030
*Объяснение:* equal_range возвращает пару итераторов, ограничивающих диапазон элементов с заданным ключом.

## Вопрос 21: **B** - hello world
**Ссылка на теорию:** строки 665-670
*Объяснение:* set хранит только уникальные элементы в отсортированном порядке.

## Вопрос 22: **C** - insert()
**Ссылка на теорию:** строки 700-710
*Объяснение:* Для добавления элементов в std::set используется метод insert().

## Вопрос 23: **C** - Элемент игнорируется
**Ссылка на теорию:** строки 700-710
*Объяснение:* set хранит только уникальные элементы, дублирующие игнорируются.

## Вопрос 24: **A** - 100
**Ссылка на теорию:** строки 830-840
*Объяснение:* try_emplace вставляет элемент только если ключа нет, второй вызов не изменит значение.

## Вопрос 25: **B** - std::less
**Ссылка на теорию:** строки 600-610
*Объяснение:* По умолчанию std::map использует компаратор std::less для сортировки по возрастанию.

## Вопрос 26: **C** - Вставляет новые или обновляет существующие
**Ссылка на теорию:** строки 840-850
*Объяснение:* insert_or_assign вставляет новый элемент или обновляет существующий.

## Вопрос 27: **B** - false
**Ссылка на теорию:** строки 850-860
*Объяснение:* extract извлекает узел из контейнера, node.empty() вернет false для успешно извлеченного узла.

## Вопрос 28: **C** - Никакие (итераторы стабильны)
**Ссылка на теорию:** строки 570-580
*Объяснение:* Итераторы std::map стабильны при вставке, не инвалидируются.

## Вопрос 29: **B** - Перемещает элементы из одного map в другой
**Ссылка на теорию:** строки 860-870
*Объяснение:* merge() перемещает элементы из исходного контейнера в целевой.

## Вопрос 30: **B** - 2 0
**Ссылка на теорию:** строки 860-870
*Объяснение:* После merge все элементы из data2 перемещаются в data1.

## Вопрос 31: **B** - Использовать equal_range()
**Ссылка на теорию:** строки 1020-1030
*Объяснение:* equal_range возвращает диапазон всех элементов с заданным ключом.

## Вопрос 32: **B** - Компаратор, позволяющий поиск без создания временных объектов
**Ссылка на теорию:** строки 950-970
*Объяснение:* Transparent comparator позволяет искать элементы без создания временных объектов ключа.

## Вопрос 33: **B** - 1
**Ссылка на теорию:** строки 980-990
*Объяснение:* set_intersection находит пересечение множеств, общий элемент только 3.

## Вопрос 34: **B** - at() генерирует исключение для несуществующих ключей
**Ссылка на теорию:** строки 900-910
*Объяснение:* at() генерирует std::out_of_range для несуществующих ключей, operator[] создает новый элемент.

## Вопрос 35: **B** - Возвращает итератор на первый элемент не меньше заданного
**Ссылка на теорию:** строки 480-490
*Объяснение:* lower_bound возвращает итератор на первый элемент, который не меньше заданного значения.

## Вопрос 36: **A** - `std::map data = {{"a", 1}, {"b", 2}};`
**Ссылка на теорию:** строки 810-820
*Объяснение:* В C++17 возможен автоматический вывод типов шаблонов (CTAD).

## Вопрос 37: **B** - Инвалидируется только итератор на удаленный элемент
**Ссылка на теорию:** строки 570-580
*Объяснение:* При удалении элемента инвалидируется только итератор на удаленный элемент.

## Вопрос 38: **B** - banana
**Ссылка на теорию:** строки 480-490
*Объяснение:* upper_bound возвращает итератор на первый элемент больше заданного, это "banana".

## Вопрос 39: **C** - std::set или std::unordered_set
**Ссылка на теорию:** строки 720-730
*Объяснение:* set и unordered_set оптимизированы для быстрой проверки принадлежности элемента.

## Вопрос 40: **B** - Конструирует вектор на месте с элементами {1, 2, 3}
**Ссылка на теорию:** строки 880-890
*Объяснение:* emplace конструирует объект на месте, создавая вектор с заданными элементами.

---

## Статистика теста:
- **Общее количество вопросов:** 40
- **Вопросы с примерами кода:** 22 (55%)
- **Вопросы по основам:** 15 (37.5%)
- **Вопросы по C++17:** 8 (20%)
- **Вопросы по продвинутым темам:** 17 (42.5%)

## Покрытие тем:
1. **Основы map и set** - вопросы 1-15
2. **Multimap и unordered контейнеры** - вопросы 16-20
3. **Методы и операции** - вопросы 21-30
4. **Продвинутые техники** - вопросы 31-40
5. **C++17 возможности** - вопросы 24, 26, 27, 29, 30, 36
6. **Итераторы и безопасность** - вопросы 28, 34, 37
7. **Компараторы и оптимизация** - вопросы 25, 32, 35, 39 