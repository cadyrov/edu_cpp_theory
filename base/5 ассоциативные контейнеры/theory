Концепция словаря
Во время работы с данными порой возникает необходимость отыскать нужный элемент по связанному с ним значению. Например, номер телефона по имени владельца или цену товара по названию. Есть несколько способов справиться с этой задачей: можно создать несколько векторов или вектор пар. Однако в C++ есть более элегантное решение — контейнер std::map.
В этом уроке вы познакомитесь с map как структурой данных и узнаете, как использовать её, чтобы сохранять элементы и быстро находить нужные.
Ассоциативные контейнеры
В русском языке map также известен под названием «словарь». Он относится к ассоциативным контейнерам — таким, где с каждым элементом ассоциирован ключ, дающий доступ к этому элементу.
Содержание контейнера удобно представить в виде пар «ключ-значение».

Знакомый вам вектор относится к последовательным контейнерам, в которых элементы пронумерованы и хранятся в заданном порядке. В отличие от вектора, в map нельзя получить элемент по порядковому номеру.
Типы ключей и значений могут быть любыми: строками, числами или даже символами — главное, чтобы они были одними и теми же для всех элементов в словаре. Поэтому в стандартной библиотеке (STL) контейнер std::map реализован как шаблон. При этом для однозначного доступа к элементам необходимо, чтобы ключи в словаре были уникальными.
Словарь — одна из самых востребованных структур данных, поэтому неудивительно, что он имеет реализацию во всех популярных языках программирования. Кроме того, существуют специальные форматы для обмена данными, такие как JSON и YAML, которые хранят информацию именно в виде словарей.
Например, в JSON данные выглядят так.
{
    «имя»    : «Иван»,
    «пароль» : «13243546hello»,
    «логин»  : «@FirTheClever»
}
Здесь первые элементы пар выполняют роль ключей, а вторые — значений.
Применение контейнеров
Как и любая структура данных, словарь позволяет добавлять, удалять и находить элементы. Получить нужный элемент можно, указав его ключ.
auto result = Map["Кошка"s];
// result = 4.
Таким же образом можно менять значения элементов.
Map["Кошка"s] = 1; // Кошка свернулась клубочком, теперь видно только одну лапу.
auto result = Map["Кошка"s];
// result = 1.
Изменить значение ключа нельзя — для этого придется удалить элемент со старым ключом из словаря и добавить его заново.
Стоит отметить, что в C++ отсутствие нужного ключа в словаре не обязательно приводит к ошибке (в отличие от отсутствующего индекса в векторе, к примеру). Если используется операция взятия по индексу [], а не встроенные методы, отсутствующий ключ автоматически добавится в словарь.
// Было: 
// paws = {{ "Кошка", 4 }, {"Паук", 8}, {"Хомяк", 4}, {"Питон", 0}}.
auto result = paws["Зяблик"s];
// Стало:
// paws = {{ "Кошка", 4 }, {"Паук", 8}, {"Хомяк", 4}, {"Питон", 0}, {"Зяблик", 0}}.
// result = 0.
Ошибка не возникает, и новый элемент получает значение по умолчанию.
C++ предлагает несколько разновидностей map, имеющих свои особенности.
std::map — классический словарь, в котором хранятся уникальные пары «ключ-значение» и ключи автоматически сортируются по возрастанию. Поиск элемента в std::map выполняется быстрее, чем в векторе.
std::multimap — эта версия словаря также хранит пары «ключ-значение», упорядоченные по ключам, однако здесь ключи могут повторяться.
std::unordered_map — реализация словаря с уникальными ключами, но без сортировки. Для хранения элементов используется хеш-таблица — еще одна структура данных для пар ключей и значений, позволяющая очень быстро находить нужные элементы. Благодаря ей эта версия map более эффективна для поиска, чем остальные.
Аналогичная классификация есть и у другого ассоциативного контейнера, с которым вы познакомитесь в текущей теме, — std::set.
std::set — контейнер, который хранит только уникальные элементы в отсортированном порядке. В нем каждый элемент встречается только один раз.
std::multiset — контейнер, который также сортирует элементы, но при этом допускает их дублирование.
std::unordered_set — контейнер, который хранит уникальные элементы, но не упорядочивает их. Как и std::unordered_map, он часто используется в случаях, когда требуется быстрый поиск.
Знакомство с контейнером map и его особенностями
Этот контейнер используется в задачах, где нужен быстрый доступ к элементам по ключу. Ключи хранятся в особом порядке — в структуре данных, называемой красно-чёрным деревом. Она позволяет находить нужный элемент быстрее, чем при обычном переборе.
Деревом называют особую структуру данных, в которой элементы связаны друг с другом как «родительские» и «дочерние» узлы. В красно-черном дереве родительские и дочерние элементы упорядочены особым образом, что гарантирует быстрое выполнение операций вставки, удаления и поиска.
Создание словаря
Давайте представим, что перед нами стоит следующая задача: нужно реализовать хранение аккаунтов пользователей таким образом, чтобы можно было получать, менять и удалять их личные номера по именам.
Создадим пустой std::map для этой задачи.
#include <map> // Подключаем для работы с контейнером.
#include <cstdint>
int main() {
    std::map<std::string, uint64_t> accounts;
}
Контейнер — это шаблон, поэтому в угловых скобках <> нужно указать типы ключей и значений. В нашем случае ключами будут имена пользователей, а значениями — номера аккаунтов.
Как и другие контейнеры, std::map можно инициализировать сразу при создании.
// Вариант 1.
std::map<std::string, uint64_t> accounts = {
    {"Jeff"s, 1000000},
    {"Bill"s, 9999999},
};

// Вариант 2.
std::map<std::string, uint64_t> accounts {
    {"Jeff"s, 1000000},
    {"Bill"s, 9999999},
};
Каждый элемент словаря заключается в фигурные скобки {}. После последнего необязательно ставить запятую, но, как правило, это делается для упрощения возможного добавления других элементов.
Если в списке инициализации указано несколько значений с одинаковыми ключами, в словарь попадёт самое первое.
std::map<std::string, uint64_t> accounts {
    {"Jeff"s, 1000000}, 
    {"Mary"s, 5555515},
    {"Jeff"s, 1011777}, // Этот элемент будет проигнорирован.
};
Доступ к элементам
Получить значение словаря можно с помощью операции взятия по индексу []. Она же позволяет редактировать значения.
std::cout << accounts["Mary"s] << std::endl; // Выведет 5555515.
accounts["Mary"s] = 700055555;
std::cout << accounts["Mary"s] << std::endl; // Выведет 700055555.
Как видите, ключи работают почти так же, как индексы в векторе. Если бы в нашей задаче ключи были представлены целыми числами, сходство было бы еще больше.
Для проверки, есть ли элементы в словаре, существует метод empty, возвращающий логическое значение. Если нужно узнать точный размер словаря, можно использовать метод size.
std::map<std::string, uint64_t> accounts {
    {"Jeff"s, 1000000},
    {"Mary"s, 5555515},
};
if (accounts.empty()) {
    std::cout << "Словарь пустой. "s;
} else {
    std::cout << "Словарь не пустой. "s;
}
std::cout << "Количество значений = "s << accounts.size() << std::endl; 
// Вывод: "Словарь не пустой. Количество значений = 2"
Несмотря на то что элементы в std::map не пронумерованы, их можно перебрать с помощью цикла for. Самый простой способ — использовать декомпозицию auto& [key, value].
std::map<std::string, uint64_t> accounts {
    {"Jeff"s, 1000000},
    {"Mary"s, 5555515},
    {"Bill"s, 9999999}
};
    
for (auto& [key, value]: accounts) {
    std::cout << key << ", "s << value << std::endl;
}   

// Вывод:
// Bill, 9999999
// Jeff, 1000000
// Mary, 5555515
Обратите внимание, что цикл перебирает элементы по возрастанию ключей, то есть так же, как они хранятся внутри словаря.
При обходе можно менять значения элементов через переменную value.
for (auto& [key, value]: accounts) {
    value = 0;
}  

// Вывод:
// Bill, 0
// Jeff, 0
// Mary, 0
Однако, если таким же образом попытаться изменить key, произойдёт ошибка. Ключи в словарях менять нельзя.
Для обработки словаря можно передать его в функцию.
void ShowAccounts(const std::map<std::string, uint64_t>& accounts) {
    for (const auto& [key, value]: accounts) {
        std::cout << key << ", "s << value << std::endl;
    }
}

... 

std::map<std::string, uint64_t> accounts;
ShowAccounts(accounts);
Заранее записывать словарь в переменную необязательно — при необходимости можно передать его напрямую.
ShowAccounts(std::map<std::string, uint64_t>{
    {"Jeff"s, 1000000},
    {"Bill"s, 9999999},
});
Добавление элементов в словарь
Чтобы добавить в std::map элемент с новым ключом, используется метод insert. Он принимает один параметр — пару из ключа и значения.
std::map<std::string, uint64_t> accounts {
    {"Mary"s, 5555515},
    {"Bill"s, 9999999},
};

// Добавим новые элементы.
accounts.insert({"Mark"s, 10101010101});
accounts.insert({"Bill"s, 100});

ShowAccounts(accounts);

// Вывод:
// Bill, 9999999
// Mark, 10101010101
// Mary, 5555515
Как видите, элементы по-прежнему выводятся в отсортированном порядке — новый элемент занял своё место.
Второе значение не попало в словарь, поскольку ключ Bill в нём уже есть. Метод insert не переписывает имеющиеся элементы.
Чтобы убедиться, добавлен ли элемент в словарь, можно использовать значения, которые возвращает insert.
auto [iterator, inserted] = accounts.insert({"Jeff"s, 100});
if (inserted) {
    std::cout << "Ключ добавлен"s << std::endl;
}
Первая переменная (iterator) содержит итератор, указывающий на позицию вставленного элемента. Вторая (inserted) — флаг, принимающий значение true в случае удачной вставки.
Если нужно удалить все элементы из словаря, поможет метод clear.
После вставки новых элементов ключи словаря будут отсортированы.
Проверка ключей
Одна из частых операций при работе со словарём — это проверка того, есть ли в нём тот или иной ключ. Она позволяет избежать потенциальных ошибок и обработать случай, если нужного ключа нет.
Самый простой способ проверить ключ — использовать метод contains, который возвращает true или false.
if (accounts.contains("Jeff")) {
    // Обрабатываем элемент accounts["Jeff"s].
} else {
    std::cout << "Аккаунт не найден"s << std::endl;
}
Но этот подход неэффективен: при поиске элемента contains обходит весь словарь, что является дорогой операцией. Если нужный ключ всё-таки имеется, мы с большой вероятностью захотим к нему обратиться с помощью операции [], для которой потребуется повторный обход.
Вместо этого лучше использовать метод find. Он не только ищет указанный элемент, но и возвращает итератор на его позицию, который затем можно использовать для доступа. Если искомого элемента нет, итератор будет указывать на позицию после последнего элемента std::map, то есть будет равен итератору end.
auto iterator = accounts.find("Mary"s); 

if (iterator != accounts.end()) { 
  std::cout << "Элемент есть в словаре"s << std::endl;
  
  // Обрабатываем элемент через итератор.
  int user_number = iterator->second;
}
Функция GetAuthor должна принимать два параметра: словарь и название книги. Если такая книга есть в словаре, функция возвращает имя автора, в противном случае она должна вернуть пустую строку.
Работа с несколькими словарями
В C++ есть множество методов и операций, упрощающих работу со словарями.
Например, перегруженные операции сравнения позволяют сравнивать словари целиком в соответствии с их элементами.
std::map<std::string, uint64_t> old_accounts {
    {"Annie"s, 9859489},
};

std::map<std::string, uint64_t> new_accounts {
    {"Annie"s, 10000},
};

if (old_accounts != new_accounts) {
    std::cout << "Словари не одинаковые"s << std::endl;
}
Ещё один из встроенных методов для работы с std::map — это swap. Он позволяет менять местами содержимое двух словарей. На практике эта операция требуется не так часто, как другие, однако её полезно иметь в своем арсенале. При необходимости лучше использовать встроенные методы, поскольку они работают гораздо эффективнее. Например, swap перемещает словари как структуры, а не по элементам, благодаря чему нет лишних операций копирования и сложность операции не зависит от размера словаря.
Ниже приведён пример использования swap.
std::map<std::string, uint64_t> old_accounts {
    {"Annie"s, 9859489},
};

std::map<std::string, uint64_t> new_accounts {
    {"Martha"s, 10000},
    {"Mary"s, 1055515},
};

ShowAccounts(old_accounts); // Annie, 9859489.
ShowAccounts(new_accounts); // Martha, 10000, Mary, 1055515.

old_accounts.swap(new_accounts); // Меняем словари местами.

ShowAccounts(old_accounts); // Martha, 10000, Mary, 1055515.
ShowAccounts(new_accounts); // Annie, 9859489.
Внутренности map
Изменение значений
Вы уже знаете, что операция взятия по индексу [] позволяет менять значения элементов.
std::map<std::string, int> prices = {
    {"Milk"s, 100},
    {"Donut"s, 150},
};

prices["Milk"s] = 99;
Но что будет, если указанного ключа нет в словаре? В случае вектора попытка использовать несуществующий индекс приводит к ошибке. Словарь работает иначе: если элемента с нужным ключом нет, он автоматически добавится со значением по умолчанию.
std::map<std::string, int> prices = {
    {"Milk"s, 99},
    {"Donut"s, 150},
};

// Пытаемся изменить значение элемента, которого ещё нет.
prices["Croissant"s] += 10; 

// Вывод:
// Croissant, 10
// Donut, 150
// Milk, 99
При обращении по ключу «Croissant» в словаре появляется новый элемент с таким ключом и значением 0, которое сразу же увеличивается на 10.
В следующей таблице приведены результаты выполнения операции [] для различных вариаций вектора и словаря.


Есть ключ/индекс
Нет ключа/индекса
vector
Ок
Неопределённое поведение
const vector
Ок
Неопределённое поведение
map
Ок
Добавляется элемент со значением по умолчанию
const map
Ошибка компиляции
Ошибка компиляции

Вектор работает предсказуемо: возвращает либо найденный элемент, либо ошибку.
Словарь возвращает элемент в любом случае.
Константный словарь вообще не допускает обращения к своим элементам с помощью []. В этом случае нужно использовать итераторы.
Это свойство словарей удобно для создания счетчиков, так как позволяет не инициализировать новые элементы вручную.
std::string word = "Hello"s;
std::map<char, int> char_counter;
for (auto c : word) {
    char_counter[c]++; 
}
Добавлять элементы таким образом можно в тех случаях, когда поведение программы предсказуемо. В сложном коде для избежания ошибок рекомендуется использовать конструкцию с find, которую вы изучили в прошлом уроке.
Обращение к несуществующему индексу в векторе приводит к неопределенному поведению.
Элементы словаря и итераторы
Каждый элемент в std::map представляет собой пару из ключа и значения:  std::pair<const Key, Value>. Как и для любой пары, для них работает обращение через first и second, которое вы уже встречали в некоторых примерах.
auto iterator = prices.find("Milk"s); 

// Сохраним элемент целиком в тип pair. 
std::pair<std::string, int> item = *iterator;
std::cout << item.first << ": "s << item.second << std::endl;
Вы могли обратить внимание, что при добавлении элементов в словарь с помощью insert ключ и значение заключаются в скобки {}. Это нужно, поскольку параметр должен быть типа pair.
// Можно создать пару с помощью {}.
prices.insert({"Salt"s, 40});

// Или использовать переменную.
std::pair<std::string, int> new_item = {"Sugar"s, 80};
prices.insert(new_item);
Итераторы в std::map и в векторе работают аналогично: они определяют позицию элемента (в данном случае — пары), по которой к нему можно обратиться. Итератор begin указывает на первый элемент словаря, а end — на позицию за словарём.
std::map<std::string, int> prices = {
    {"Milk"s, 99},
    {"Donut"s, 150},
};  

// Выведет значение "Milk".
std::cout << prices.begin()->first << std::endl;

// Ошибка: на позиции end элементов уже нет.
std::cout << prices.end()->first << std::endl;
Подобно вектору, в словаре итераторы позволяют переходить от одного элемента к другому в том порядке, в котором они хранятся.
for(auto it = prices.begin(); it!= prices.end(); it++) {
    std::cout << it->first << ": "s << it->second << std::endl;
}

// Вывод:
// Donut: 150
// Milk: 99
У перемещения по словарю есть свои особенности. Как мы говорили в прошлом уроке, std::map хранит ключи таким образом, чтобы обеспечивать быстрый доступ к ним, поэтому организация данных сложнее, чем в последовательном векторе. Из-за этого итераторы словаря не поддерживают операции прибавления и вычитания чисел. Зато доступны -- и ++:
// Переход к следующему элементу с помощью инкремента разрешён.
std::cout << (++accounts.begin())->first << std::endl;

// Переход на указанное количество позиций вызовет ошибку.
std::cout << (accounts.begin() + 3)->first << std::endl; // <- Ошибка!
Для перемещения на определенное количество позиций можно использовать функцию std::advance, которая передвигает итератор на заданное количество шагов:
std::map<int, std::string> numbers = {
      {1, "one"s},
      {2, "two"s},
      {3, "three"s},
      {4, "four"s},
      {5, "five"s}
};

auto it = numbers.begin(); 
std::advance(it, 3); // Перемещаем итератор на 3 позиции вперёд.

// Выведет: 4, four.
std::cout << it->first << ", "s << it->second << std::endl;
Похожим образом работают функции std::next и std::prev. Они не меняют итератор, но позволяют получить новый, смещенный:
auto other_it = std::prev(it, 2); // other_it -> {2, "two"}.

auto iter_to_last = std::next(other_it, 3); // iter_to_last -> {5, "five"}.
Поскольку итераторы словаря — не итераторы произвольного доступа, функции advance, prev, next не так эффективны, как перемещения итераторов вектора. Под капотом они многократно вызывают ++ либо --, в зависимости от направления движения.
Вычитание итераторов друг из друга также недоступно. Чтобы определить количество шагов между двумя итераторами, можно использовать функцию std::distance.
auto iter_begin = numbers.begin();
auto iter_end = numbers.find("4"s);

// Расстояние между первым элементом и элементом "4" равно 3.
int dist = std::distance(iter_begin, iter_end);
Перед вами словарь для хранения информации о сданных экзаменах. 
std::map<std::string, bool> passing_exams {
    {"Math"s, true},
    {"Physics"s, false}
};
Замена ключей и удаление элементов
Как вы уже знаете, словари не позволяют менять ключи, так как они являются константными: std::pair<const Key, Value>.
auto it = prices.find("Milk"s);
    
it->second = 220;               // Ок.
it->first = "Сhocolate milk"s;  // Ошибка: попытка изменить константный элемент пары.
Причина снова кроется в сложной структуре «дерева». Все элементы в такой структуре данных упорядочены по ключу, и при изменении одного из них этот порядок будет нарушен. Поэтому, чтобы заменить ключ, необходимо сначала удалить элемент из словаря, а затем вставить новый.
Для удаления элемента используется метод erase. Он возвращает логическое значение true, если указанный ключ найден и элемент удалён, и false в противном случае.
auto is_erased = prices.erase("Milk"s);

// Если ключ найден, вставляем новый элемент на место старого.
if (is_erased) { 
    prices.insert({"Сhocolate milk"s, 220});
} else {
    std::cout << "Ключ не найден"s;
}
    
// Donut: 150
// Сhocolate milk: 220
Метод erase также позволяет удалять элементы по итератору.
auto it = prices.find("Milk"s);

if (it != prices.end()) {
    prices.erase(it);
}
В некоторых случаях бывает необходимо удалить несколько ключей, идущих подряд. erase позволяет сделать это с помощью двух итераторов, указывающих на границы диапазона. При этом элемент, соответствующий верхней границе, не входит в диапазон и не удаляется.
Ниже приведён пример с удалением из словаря элементов от {"Donut"s, 150} до {"Milk chocolate"s, 150} включительно.
std::map<std::string, int> prices = {
    {"Donut"s, 150},
    {"Milk"s, 100},
    {"Milk chocolate"s, 150},
    {"Sugar"s, 80},
}; 

// Находим границы диапазона.
auto it_begin = prices.find("Donut"s);
auto it_end = ++prices.find("Milk chocolate"s);

if ((it_begin != prices.end()) && (it_end != prices.end())) {
    prices.erase(it_begin, it_end);
}

// Результат после удаления:
// Sugar, 80
Обратите внимание: чтобы элемент {"Milk chocolate"s, 150} попал в удаляемый диапазон, его итератор нужно сдвинуть на следующую позицию, увеличив на 1.
Рассмотрим теперь инвалидацию итераторов. Как вы знаете, итераторы вектора довольно чувствительны: при изменении количества элементов они могут инвалидировать.
Итераторы std::map гораздо более устойчивые. Причина в том, что элементы словаря хранятся не подряд, а разрозненно. Благодаря этому им никогда не нужно переезжать, делая релокацию.
Итератор на элемент std::map остается корректным, если вы:
Добавляете новый элемент.
Удаляете другой элемент.
Меняете значение любого элемента, в том числе того, на который указывает итератор.
Единственный случай, когда итератор действительно будет инвалидироваться, — удаление элемента, на который он указывает.
Словарь со сложными типами данных
Контейнер std::map — шаблон, а потому может хранить не только встроенные типы (вроде чисел и строк), но и более сложные объекты. Например, можно создать словарь с векторами.
// map<название_рецепта, вектор_ингредиентов>.
std::map<std::string, std::vector<std::string>> recipes {
    {"Carbonara"s, std::vector{"pasta"s, "eggs"s, "cheese"s}},
    {"Cookies"s, std::vector{"flour"s, "sugar"s, "butter"s, "eggs"s}},
};
При инициализации необходимо указать типы элементов, в том числе для вектора.
Можно поместить в словарь объекты класса.
class Recipe {
public:
    Recipe(std::string d, std::vector<std::string> i):
        description_(d), ingredients_(i) {}
    // ...

private:
    std::string description_;
    std::vector<std::string> ingredients_;
};

int main() {
    std::map<std::string, Recipe> recipes {
        {
            "Carbonara"s, 
            Recipe{ 
                "Very fast and delicious"s, 
                {"pasta"s, "eggs"s, "cheese"s}
            }
        },
    };
}
Или даже другие словари.
// map<название_рецепта, map<ингредиент, количество>>.
std::map<std::string, std::map<std::string, int>> recipes {
    {
        "Carbonara"s, {
            {"Pasta"s, 200},{"Eggs"s, 50},{"Cheese"s, 100},
        }   
    } 
};

std::cout << recipes["Carbonara"s]["Cheese"s] << std::endl;
Такой подход может быть удобен, если мы имеем дело со сложными данными, к которым удобно обращаться по ключам.
Компараторы для словарей
Сортировка ключей в словаре происходит с помощью операций сравнения, которые определяют порядок элементов. Для встроенных типов используется стандартное сравнение — именно поэтому числовые или строковые ключи сортируются по возрастанию.
Контейнер std::map позволяет задавать собственные правила для упорядочивания элементов. Благодаря этому можно не только иначе сортировать стандартные типы, но и использовать в качестве ключей более сложные объекты.
Правила сортировки задаются через компаратор — функцию, которая принимает два параметра и возвращает логический результат их сравнения. В std::map компаратор указывается в момент создания словаря и не может быть изменен в процессе работы.
Существует несколько способов задать компаратор. Его можно объявить в виде функционального объекта (структуры или класса) и передавать как шаблонный аргумент.
Создадим компаратор, сортирующий ключи в обратном порядке.
// Компаратор для сортировки строк по убыванию.
struct Comparator{
    bool operator()(std::string a, std::string b) const {
        return a > b;
    }
};

// Передаём Comparator в виде шаблонного аргумента.
std::map<std::string, int, Comparator> prices = {
    {"Milk"s, 99},
    {"Sugar"s, 110},
    {"Donut"s, 150},
};

// Теперь ключи хранятся в обратном порядке.   
// Sugar: 110
// Milk: 99
// Donut: 150
Чтобы сократить запись, можно объявить компаратор в виде лямбда-функции.
auto comparator = [](std::string a, std::string b) {
    return a > b;
};

std::map<std::string, int, decltype(comparator)> prices = {
    {"Milk"s, 99},
    {"Sugar"s, 110},
    {"Donut"s, 150},
};
В этом случае он также указывается среди шаблонных аргументов. Поскольку используется анонимная лямбда-функция, для определения типа необходимо использовать decltype.
Этого можно избежать, если явно прописать тип лямбда-функции.
std::function<bool(std::string, std::string)> 
comparator = [](std::string a, std::string b) {
    return a > b;  
};

std::map<std::string, 
         std::string, 
         std::function<bool(std::string, std::string)>
         > prices(comparator);
Введение в контейнер Set и его использование
При работе с данными можно столкнуться с самыми разными задачами. Иногда нужно найти уникальные значения в наборе элементов (например, составить словарь из текста). В других случаях требуется эффективно проверить, присутствует ли конкретное значение в списке: например, когда важен сам факт его наличия, а не количество вхождений.
Обе эти задачи легко решаются с помощью контейнера std::set. В этом уроке мы подробно рассмотрим, что это за контейнер и как с ним работать.
Особенности set
Контейнер std::set имеет второе распространённое название — множество, указывающее на то, что он может содержать только уникальные значения.
std::set birds = {
    "зяблик"s, "синица"s, "снегирь"s, "зяблик"s, "синица"s
};
// birds = {"зяблик", "синица", "снегирь"}.
Как и в словарях, элементы множества хранятся упорядоченно в виде красно-черного дерева.
Деревом называют особую структуру данных, в которой элементы связаны друг с другом как «родительские» и «дочерние» узлы. В красно-черном дереве родительские и дочерние элементы упорядочены особым образом, что гарантирует быстрое выполнение операций вставки, удаления и поиска.
Ключами для сортировки являются сами значения элементов — поэтому std::set считается ассоциативным контейнером, несмотря на отсутствие явных ключей для обращения к элементам.
Такой способ хранения позволяет быстро находить значения и предотвращать дублирование.
Для std::set доступно большинство базовых операций: добавление и удаление элементов, а также проверка их наличия. Этот контейнер редко используется для доступа к конкретному значению, поэтому у него нет операции взятия по индексу или по ключу. При необходимости нужный элемент можно извлечь с помощью итераторов.
Применение множеств
Как и большинство структур данных в библиотеке STL, std::set является шаблоном, поэтому при создании необходимо указать тип его элементов.
std::set<int> years;
Если множество инициализируется сразу, шаблонный аргумент можно опустить.
std::set years = {1917, 1984, 1917};
// years = {1917, 1984}.
В множество будут записаны только уникальные значения из списка инициализации, отсортированные по возрастанию.
Чтобы узнать, есть ли элементы в множестве и сколько их, можно использовать знакомые вам методы empty и size.
std::set words = {
    "world"s, "hello"s, "hello"s
};
if (!words.empty()) {
    std::cout << "Множество не пустое. Количество элементов = "s 
              << words.size() << std::endl;
}
// Множество не пустое. Количество элементов = 2.
Для добавления новых элементов в std::set есть метод insert, который работает аналогично методу insert для std::map. Он позволяет вставлять значения, которые будут сохранены только в том случае, если их еще не было в множестве.
std::set years = {1917, 1984};
years.insert(1561); // Ок: это новый элемент.
years.insert(1984); // Этот элемент не будет добавлен.
// years = {1561, 1917, 1984}.
Результат операции можно узнать по значениям, которые возвращает insert: итератору, указывающему на место нового элемента, и флагу, равному true, если элемент успешно добавлен.
auto [iterator, is_inserted] = years.insert(1984);  
if (is_inserted) {
    std::cout << "Добавлен год: "s << *iterator;
} else {
    std::cout << "Этот год уже записан!"s;
}
Элементы множества хранятся упорядоченно.
Работа с элементами
Одна из самых частых операций с std::set — это проверка наличия элемента. Её можно выполнить с помощью метода contains, который возвращает логическое значение.
std::set words = {
    "hello"s, "world"s, "hello"s
};

auto word = "hello"s;
if (words.contains(word)) {
    std::cout << "Слово уже есть"s << std::endl;
}
Второй способ — метод find, возвращающий итератор, указывающий либо на найденное слово, либо на конец контейнера, если поиск оказался неудачным.
auto word = "hello"s;
auto iter = words.find(word);

if (iter != words.end()) {
    std::cout << "Слово уже есть"s << std::endl;
}
Еще одна полезная операция — перебор элементов множества. Как и в случае с std::map, это можно сделать как с помощью итераторов, так и обращаясь к значениям напрямую через ссылку.
// Перебор через итераторы.
for (auto iter = words.begin(); iter!= words.end(); ++iter) {
    std::cout << *iter << std::endl;
}

// Перебор через ссылку.
for (const auto& word : words) {
    std::cout << word << std::endl;
}
// Вывод:
// hello
// world
В обоих случаях значение (итератор или ссылка), которое участвует в цикле, является константным. Через него нельзя менять элементы множества.
for (auto iter = words.begin(); iter!= words.end(); ++iter) {
    *iter = "another"s; // Ошибка!
}

Изменение значений — сложная операция, которая потребовала бы перестроения всего «дерева» (структуры данных). Вместо этого можно удалить ненужный элемент и добавить в множество новый. Удаление выполняется с помощью метода erase, который может работать и со значениями, и с итераторами.
// Удаление по значению.
words.erase("hello"s);

// Удаление по итератору.
words.erase(words.find("hello"s));
Если указанный элемент нашёлся в контейнере и был успешно удалён, erase возвращает true.
auto is_erased = words.erase("hello"s);
if (is_erased) {
    std::cout << "Элемент был удалён"s << std::endl;
}
Множества для сложных типов
Подобно другим контейнерам, std::set может хранить простые и сложные объекты. Например, мы можем создать множество из векторов.
std::set<std::vector<int>> set_of_vectors;
    
std::vector<int> vec_1 = {1, 2, 3};
std::vector<int> vec_2 = {4, 5, 6};
std::vector<int> vec_3 = {1, 2, 3};

set_of_vectors.insert(vec_1);
set_of_vectors.insert(vec_2);
set_of_vectors.insert(vec_3);

// set_of_vectors = { [1 2 3], [4 5 6] }.
В качестве значений могут выступать и нестандартные объекты, созданные на основе классов или структур. Главное требование к ним — наличие компаратора, который позволит множеству сравнивать и упорядочивать элементы.
class User {
public:
    User(std::string name, int rd) : name_(name), registration_date_(rd) {}
    
    int GetRegDate() const {
        return registration_date_;
    }
private:
    std::string name_;
    int registration_date_;
};

struct UserComparator {
    bool operator() (const User& u1, const User& u2) const {
        return u1.GetRegDate() < u2.GetRegDate();
    }
};

...

std::set<User, UserComparator> set_of_users{
    User ("Alice"s, 20240907),
    User ("Bobby"s, 20190115),
    User ("Charlie"s, 20220910),
    User ("Mary"s, 20220910),
};
// set_of_users = { 
// ("Bobby", 20190115), 
// ("Charlie", 20220910), 
// ("Alice", 20240907) 
// }
В приведённом примере компаратор UserComparator задаёт правило для сравнения объектов типа User: они будут упорядочены по дате регистрации (поле registration_date_). Поскольку у пользователей Charlie и Mary даты совпадают, они считаются одинаковыми элементами, и множество сохранит только один из них.
Преобразование одних контейнеров в другие
В библиотеке STL предусмотрена возможность создавать новые контейнеры на основе пары итераторов из уже существующих контейнеров. Например, таким образом можно получить std::set из элементов вектора.
std::vector vec{1, 1, 2, 2, 3, 4, 5, 6};
// Создадим множество из элементов вектора.  
auto unique_elements = std::set<int>(vec.begin(), vec.end());
for (auto item : unique_elements) {
    std::cout << item << " "s;
} 
//Вывод: 1 2 3 4 5 6 .
Аналогично можно выполнить и обратное преобразование, создав вектор из элементов множества.
std::set set{'a', 'b', 'c', 'd'};
auto vec = std::vector<char>(set.begin(), set.end());
for (auto item : vec) {
    std::cout << item << " "s;
} 
//Вывод: a b c d .
При объявлении нового контейнера конструктор получает два параметра — итераторы, указывающие на начало и конец диапазона, которые не обязательно должны совпадать с итераторами begin и end.
// Выберем элементы от 'a' до 'с' (не включительно).
auto vec = std::vector<char>(set.begin(), set.find('c'));
// vec = ['a', 'b'].
Подобные преобразования возможны и для других контейнеров — главное, чтобы их элементы были одного типа. Например, превратить множество в словарь не получится, поскольку элементы словаря должны быть парами. Зато это свойство позволяет создавать новые словари на основе существующих, в том числе с новыми компараторами.
В следующем примере мы создадим словарь new_accounts с другим правилом сортировки: вместо того, чтобы упорядочивать числовые значения по возрастанию, он будет сравнивать ключи лексикографически.
struct Comparator{
    bool operator()(int a, int b) const {
        return std::to_string(a) < std::to_string(b);
    }
};

...
// Словарь со стандартным компаратором.
std::map<int, std::string> accounts {
    {1000000, "Jeff"s}, 
    {5555, "Mary"s},
    {90000, "Jeff"s},
};

// Создадим на его основе новый словарь с Comparator.    
auto new_accounts = std::map<int, std::string, Comparator>(
                             accounts.begin(), accounts.end());

// В первом варианте элементы сортируются по возрастанию числовых ключей:
// 5555, Mary
// 90000, Jeff
// 1000000, Jeff
    
// Во втором варианте ключи сортируются как строки:
// 1000000, Jeff
// 5555, Mary
// 90000, Jeff
Работа с контейнерами в Qt
Словарь. Версия Qt
Qt-версия словаря QMap — аналог std::map. Ключи в этих словарях уникальны и упорядочены идентично. Как и std::map, Qt-версия словаря обладает методами:
empty() — проверить словарь на пустоту;
size() — вернуть количество записей;
contains(ключ) — узнать, есть ли запись с заданным значением ключа;
find(ключ) — вернуть итератор на элемент.
Эти методы работают одинаково в обоих типах словарей.
Добавление записей
Как у стандартного словаря, у QMap есть метод insert. Однако элемент при вставке передается не как пара (std::pair), а двумя параметрами: ключом и значением. На примере для словаря «число-строка» это выглядит так:
std::map<int, std::string> std_map;
std_map.insert( {1, "1"} );
QMap<int, QString> q_map;
q_map.insert(1, "1");
В примере выше в словари вставляется пара с ключом «1» и значением «1». Теперь повторим эти операции с теми же ключами, но другими значениями.
std_map.insert( {1, "2"} );
std::cout << std_map[1] << std::endl; 
// Вывод: 1 — значение осталось прежним.
q_map.insert(1, "2");
std::cout << q_map[1] << std::endl; 
// Вывод: 2 — значение обновилось.
В отличие от std::map, где при вставке по существующему ключу значение не переписывается, в QMap значение изменится.
Особенности чтения
Пройдемся по элементам словарей с помощью итераторов. Стандартный словарь std::map позволяет получить ключ и значение как элементы std::pair. У итератора QMap для этого есть два удобных метода — key() и value(). Разыменование итератора возвращает значение.
Посмотрим на примере:
for (auto it = std_map.begin(); it != std_map.end(); ++it) {
    std::cout << it->first << " " << it->second << std::endl;
}

for (auto it = q_map.begin(); it != q_map.end(); ++it) {
    // Вариант 1: использование методов key() и value():
    std::cout << it.key() << " " << it.value() << std::endl;
    // Вариант 2 (если ключ не нужен, а достаточно значения). 
    // Разыменование итератора:
    std::cout << *it << std::endl;
}
При использовании range-based-цикла с QMap можно вывести все значения:
for (const auto& value : q_map) {
    std::cout << value << std::endl;
}
Ещё одна удобная возможность QMap — метод keys(), который возвращает все ключи. В результате в цикле можно пройти по ключам и прочитать хранимые значения, используя квадратные скобки или метод value():
for (const auto& key : q_map.keys()) {
    // Используем квадратные скобки:
    std::cout << q_map[key] << std::endl;
    
    // Используем value:
    std::cout << q_map.value(key) << std::endl;
}     
Удаление элементов
Метод erase в QMap удаляет элемент только по итератору, для удаления по ключу нужно использовать метод remove. Два варианта удаления ключа «1»:
// Вариант 1:
q_map.erase(q_map.find(1));

// Вариант 2:
q_map.remove(1);
Анализируя сравнение QMap и std::map, отметим, что эти контейнеры имеют идентичные методы empty(), size(), contains(ключ) и find(ключ). При этом в QMap есть и свой метод проверки словаря на пустоту — isEmpty(). По-разному работают методы записи, чтения и удаления элементов.
Чтобы получить std::map из QMap, можно воспользоваться методом toStdMap().
std::map<int, std::string> std_map = q_map.toStdMap();
Линейное хранение элементов в Qt. Освоение QList
Контейнер QList не ассоциативный, но часто используется в приложениях Qt (например, для хранения списков).
Этот контейнер похож на вектор. Он может хранить разные типы данных и располагает элементы в памяти линейно. При этом у него есть удобные методы, которые позволяют делать код компактнее, чем при выборе std::vector. При работе с QList желательно заранее выделять нужное количество памяти, чтобы в процессе работы программы не происходила реаллокация.
Добавление элементов в QList
Есть несколько способов добавить элементы в QList. Первый из них — использовать знакомые по вектору методы push_back и insert. Наличие первого позволяет использовать back_inserter с QList.
В качестве примера возьмём QList с числами и добавим элементы, используя знакомые методы:
QList<int> list;
// Как в вектор:
list.push_back(2);
list.insert(0, 3);
В Qt есть свой метод для добавления элементов в конец — append. Он используется не только для QList, но ещё и для других Qt-контейнеров, таких как QVector и QStringList. QStringList — это частный случай QList с уже определённым типом элементов QString.
Начиная с версии Qt 6 QList и QVector — это одно и то же.
Метод append удобно использовать для добавления как одного элемента, так и сразу нескольких:
QList<int> list{};
// Одно значение:
list.append(1);
// Несколько значений:
list.append({2, 3, 4});
// list: 1, 2, 3, 4.
Ещё один способ заполнения листа — использование операции <<. Как и append, операция позволяет добавить одну или сразу несколько записей друг за другом:
QList<QString> friends_list{};
friends_list << "Маша" << "Вера" << "Илья" << "Пётр";
// friends_list: "Маша", "Вера", "Илья", "Пётр".
Чтение и поиск элементов в QList
Читать элементы из контейнера QList можно, как и из вектора, используя квадратные скобки или метод at. Частные случаи — методы back()и front(). Они позволяют получить последний и первый элементы из списка.
Функции find и find_if поддерживают поиск в QList по итераторам, аналогично std::vector.
// Создаём список целых чисел.
QList<int> list{1, 2, 3, 4, 5};

// Поиск значения 3.
QList<int>::iterator it = std::find(list.begin(), list.end(), 3);

if (it != list.end()) {
    std::cout << "Найдено значение: " << *it << "." << std::endl;
} else {
    std::cout << "Значение не найдено." << std::endl;
}

// Результат: Найдено значение: 3.
Неудобство при работе с std::find — это возврат итератора. При необходимости узнать позицию элемента в списке нужно будет дополнительно подключить std::distance:
auto it = std::find(list.begin(), list.end(), 3);
int index = -1;
if(it != list.end()) {
    index = std::distance(list.begin(), it);
}
QList обладает удобным интерфейсом для поиска элементов по их значениям и получения их индексов с помощью методов indexOf и lastIndexOf. Их использование полезно в ситуациях, когда вам нужно работать с позицией элемента, а не только с его значением. Теперь код можно переписать компактнее:
QList<int> list{1, 2, 3, 4, 5};
int index1 = list.indexOf(3);
// Результат: index1 = 2.

int index2 = list.indexOf(42);
// Результат: index2 = -1.
Если в последовательности будет несколько одинаковых значений — indexOf вернет первый найденный элемент. При поиске 42 мы получили результат -1. Это значение показывает, что элемент не найден: так же, как end() при использовании std::find. Поиск начинается с позиции 0. Чтобы указать другую позицию старта, передайте её вторым параметром. Например, укажем поиск числа 2 с позиции 3:
QList<int> list{1, 2, 3, 4, 5};
int index_2 = list.indexOf(2, 3);
// Ищем значение 2 с индекса 3, то есть в значениях {4, 5}.
// Результат: index_2 = -1.

int index_4 = list.indexOf(4, 3);
// Результат: index_4 = 3.
Третья позиция — это элемент со значением 4. Поиск выполняется на отрезке с элементами {4, 5}. В первом случае в наборе нет искомого числа 2, поэтому indexOf вернёт -1. Во втором случае искомое число 4 есть в наборе, поэтому возвращается индекс 3.
Метод с названием lastIndexOf схож с indexOf, но поиск начинается с конца, поэтому возвращается индекс последнего вхождения в список.
QList<int> list{1, 2, 3, 2, 5};
// В этом списке два элемента 2 — на позициях 1 и 3.
int index = list.lastIndexOf(2);
// Результат: index = 3.
// Так как при поиске используется lastIndexOf, то возвращается 3.
Второй параметр также означает позицию, с которой будет выполняться поиск.
// В этом списке два элемента 2 — на позициях 1 и 3.
QList<int> list{1, 2, 3, 2, 5};

int index_2 = list.lastIndexOf(2, 2);
// Результат: index_2 = 1.
// Поиск выполняется от индекса 2 до индекса 0,
// возвращается индекс 1.

int index_4 = list.lastIndexOf(5, 2);
// Результат: index_4 = -1.
// Так как в подсписке {1, 2, 3} нет значения 5.
QList и виджеты Qt
QList пригодится при использовании в графических виджетах Qt: как для заполнения, так и для сохранения считанных данных.
К примеру, графический виджет — выпадающий список (QComboBox) заполняется элементами с помощью метода addItems(список), где список — это QStringList или QList<QString>. В примере выше мы заполнили лист именами друзей, теперь при наличии виджета cb_list_friends можем добавить в него строки, передав лист со значениями:
ui->cb_list_friends->addItems(list_friends);
Предположим, теперь хотим прочитать всё, что добавили. Применим QStringList, чтобы сохранить все элементы выпадающего списка. Для этого надо узнать количество элементов в списке с помощью метода count(), затем прочитать значение элемента с помощью itemText(), передав в него индекс:
QStringList items{};
for(int i = 0; i < ui->cb_list_friends->count(); ++i) {
    items << ui->cb_list_friends->itemText(i);
}
С помощью indexOf в items можем найти индекс записи и использовать в методе выпадающего списка setCurrentIndex, чтобы изменить выбранное значение в нём:
int index = items.indexOf("Маша");
ui->cb_list_friends->setCurrentIndex(index);

Дополнительный материал для экзамена (C++17 и лучшие практики для ассоциативных контейнеров)

Новые возможности C++17 для ассоциативных контейнеров

1. Автоматический вывод типов шаблонов (CTAD)
До C++17:
std::map<std::string, int> prices = {{"apple", 100}, {"banana", 50}};
std::set<int> numbers = {1, 2, 3, 4, 5};

С C++17:
std::map prices = {{"apple"s, 100}, {"banana"s, 50}}; // автоматически std::map<std::string, int>
std::set numbers = {1, 2, 3, 4, 5}; // автоматически std::set<int>

2. Структурированные привязки для map
auto prices = std::map{{"apple"s, 100}, {"banana"s, 50}};
for (const auto& [key, value] : prices) {
    std::cout << key << ": " << value << std::endl;
}

// При работе с insert
auto [iterator, inserted] = prices.insert({"orange"s, 75});
if (inserted) {
    std::cout << "Добавлен новый элемент: " << iterator->first << std::endl;
}

3. try_emplace и insert_or_assign (C++17)
std::map<std::string, std::string> config;

// try_emplace - вставляет только если ключа нет
config.try_emplace("debug", "true");
config.try_emplace("debug", "false"); // не изменит существующее значение

// insert_or_assign - вставляет или обновляет
config.insert_or_assign("version", "1.0");
config.insert_or_assign("version", "2.0"); // обновит значение

4. extract и merge для узлов (C++17)
std::map<int, std::string> map1 = {{1, "one"}, {2, "two"}};
std::map<int, std::string> map2 = {{3, "three"}, {4, "four"}};

// Извлечение узла
auto node = map1.extract(1);
if (!node.empty()) {
    node.key() = 10; // можно изменить ключ!
    map2.insert(std::move(node));
}

// Слияние контейнеров
map1.merge(map2); // перемещает элементы из map2 в map1

Лучшие практики для ассоциативных контейнеров

1. Выбор правильного контейнера
// Для уникальных ключей с сортировкой
std::map<std::string, int> sorted_unique;

// Для уникальных ключей без сортировки (быстрее)
std::unordered_map<std::string, int> hash_unique;

// Для неуникальных ключей с сортировкой
std::multimap<std::string, int> sorted_multi;

// Для неуникальных ключей без сортировки
std::unordered_multimap<std::string, int> hash_multi;

2. Эффективная вставка элементов
std::map<std::string, std::vector<int>> data;

// Неэффективно - создает пустой вектор, затем копирует
data["key"] = std::vector<int>{1, 2, 3};

// Эффективно - конструирует на месте
data.emplace("key", std::vector<int>{1, 2, 3});

// Еще лучше - используем try_emplace
data.try_emplace("key", std::initializer_list<int>{1, 2, 3});

3. Безопасный доступ к элементам
std::map<std::string, int> prices = {{"apple", 100}};

// Опасно - создает элемент если его нет
int apple_price = prices["apple"]; // OK
int orange_price = prices["orange"]; // Создает элемент со значением 0!

// Безопасно - использование find
auto it = prices.find("orange");
if (it != prices.end()) {
    int orange_price = it->second;
} else {
    std::cout << "Товар не найден" << std::endl;
}

// Безопасно - использование at (генерирует исключение)
try {
    int orange_price = prices.at("orange");
} catch (const std::out_of_range& e) {
    std::cout << "Товар не найден: " << e.what() << std::endl;
}

4. Эффективная работа с множествами
std::set<int> numbers = {1, 2, 3, 4, 5};

// Проверка наличия элемента
if (numbers.count(3)) { // Работает, но неэффективно для set
    std::cout << "Элемент найден" << std::endl;
}

// Лучше использовать find
if (numbers.find(3) != numbers.end()) {
    std::cout << "Элемент найден" << std::endl;
}

// В C++20 можно использовать contains
if (numbers.contains(3)) { // C++20
    std::cout << "Элемент найден" << std::endl;
}

Продвинутые техники

1. Кастомные компараторы и хеш-функции
// Компаратор для сортировки по длине строки
struct StringLengthComparator {
    bool operator()(const std::string& a, const std::string& b) const {
        return a.length() < b.length();
    }
};

std::map<std::string, int, StringLengthComparator> words_by_length;

// Кастомная хеш-функция для unordered_map
struct CustomHash {
    std::size_t operator()(const std::pair<int, int>& p) const {
        return std::hash<int>{}(p.first) ^ (std::hash<int>{}(p.second) << 1);
    }
};

std::unordered_map<std::pair<int, int>, std::string, CustomHash> point_names;

2. Использование transparent comparators (C++14/17)
struct TransparentComparator {
    using is_transparent = void; // Ключевое объявление
    
    bool operator()(const std::string& a, const std::string& b) const {
        return a < b;
    }
    
    bool operator()(const std::string& a, const char* b) const {
        return a < b;
    }
    
    bool operator()(const char* a, const std::string& b) const {
        return a < b;
    }
};

std::map<std::string, int, TransparentComparator> data;
// Можно искать без создания временного std::string
auto it = data.find("key"); // Эффективно!

3. Работа с диапазонами и алгоритмами
std::map<std::string, int> inventory = {
    {"apples", 50}, {"bananas", 30}, {"oranges", 20}
};

// Подсчет элементов с определенным условием
int expensive_items = std::count_if(inventory.begin(), inventory.end(),
    [](const auto& pair) { return pair.second > 25; });

// Поиск элемента с максимальным значением
auto max_item = std::max_element(inventory.begin(), inventory.end(),
    [](const auto& a, const auto& b) { return a.second < b.second; });

// Преобразование в другой контейнер
std::vector<std::string> item_names;
std::transform(inventory.begin(), inventory.end(), 
               std::back_inserter(item_names),
               [](const auto& pair) { return pair.first; });

Типичные ошибки и их избежание

1. Неправильное использование operator[]
// ОШИБКА - изменяет map даже при чтении
std::map<std::string, int> const& get_prices() {
    static std::map<std::string, int> prices = {{"apple", 100}};
    return prices;
}

void bad_function() {
    auto& prices = get_prices();
    // int apple_price = prices["apple"]; // Ошибка компиляции - const map
}

// ПРАВИЛЬНО
void good_function() {
    auto& prices = get_prices();
    auto it = prices.find("apple");
    if (it != prices.end()) {
        int apple_price = it->second;
    }
}

2. Неэффективное удаление элементов
std::map<int, std::string> data = {{1, "one"}, {2, "two"}, {3, "three"}};

// НЕЭФФЕКТИВНО
for (auto it = data.begin(); it != data.end();) {
    if (it->second == "two") {
        data.erase(it++); // Постфиксный инкремент
    } else {
        ++it;
    }
}

// ЭФФЕКТИВНО (C++11+)
for (auto it = data.begin(); it != data.end();) {
    if (it->second == "two") {
        it = data.erase(it); // erase возвращает следующий итератор
    } else {
        ++it;
    }
}

3. Неправильная работа с multimap/multiset
std::multimap<std::string, int> scores = {
    {"Alice", 95}, {"Bob", 87}, {"Alice", 92}
};

// НЕПРАВИЛЬНО - найдет только первое вхождение
auto it = scores.find("Alice");
if (it != scores.end()) {
    std::cout << it->second << std::endl; // Выведет только 95
}

// ПРАВИЛЬНО - найдет все вхождения
auto range = scores.equal_range("Alice");
for (auto it = range.first; it != range.second; ++it) {
    std::cout << it->second << std::endl; // Выведет 95 и 92
}

Оптимизация производительности

1. Резервирование памяти для unordered контейнеров
std::unordered_map<int, std::string> data;
data.reserve(1000); // Избегаем перехеширования

2. Использование emplace вместо insert
std::map<std::string, std::vector<int>> data;

// Менее эффективно
data.insert({"key", std::vector<int>{1, 2, 3}});

// Более эффективно
data.emplace("key", std::vector<int>{1, 2, 3});

3. Минимизация копирований при поиске
std::map<std::string, int> data;
std::string key = "search_key";

// Неэффективно - может создать копию ключа
auto it = data.lower_bound(key);

// Эффективно с transparent comparator
// auto it = data.lower_bound("search_key"); // Если есть transparent comparator

Совместимость и переносимость

1. Итераторы и их стабильность
// map/set итераторы стабильны при вставке
std::map<int, std::string> data = {{1, "one"}, {2, "two"}};
auto it = data.find(1);
data.insert({3, "three"}); // it остается валидным

// unordered_map итераторы могут инвалидироваться при rehash
std::unordered_map<int, std::string> hash_data = {{1, "one"}};
auto hash_it = hash_data.find(1);
hash_data.insert({2, "two"}); // hash_it может стать невалидным

2. Требования к ключам
// Для map/set ключи должны поддерживать operator< или иметь компаратор
struct Point {
    int x, y;
    bool operator<(const Point& other) const {
        return std::tie(x, y) < std::tie(other.x, other.y);
    }
};

std::map<Point, std::string> point_map;

// Для unordered_map/unordered_set нужны hash и equality
struct PointHash {
    std::size_t operator()(const Point& p) const {
        return std::hash<int>{}(p.x) ^ (std::hash<int>{}(p.y) << 1);
    }
};

struct PointEqual {
    bool operator()(const Point& a, const Point& b) const {
        return a.x == b.x && a.y == b.y;
    }
};

std::unordered_map<Point, std::string, PointHash, PointEqual> point_hash_map;

Заключение дополнительного материала

Ассоциативные контейнеры в C++ предоставляют мощные инструменты для организации данных. Выбор между map/set и unordered_map/unordered_set зависит от требований к производительности и необходимости сортировки. Современные стандарты C++ добавляют новые возможности для более эффективной и безопасной работы с этими контейнерами. Правильное использование методов вставки, поиска и удаления, а также понимание особенностей итераторов критически важно для написания эффективного кода.

