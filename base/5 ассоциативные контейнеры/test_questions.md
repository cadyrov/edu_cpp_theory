# Тест по теме "Ассоциативные контейнеры в C++" (40 вопросов)

## Вопрос 1
Что такое ассоциативный контейнер?

A) Контейнер, где элементы пронумерованы
B) Контейнер, где с каждым элементом ассоциирован ключ
C) Контейнер для хранения только чисел
D) Контейнер с фиксированным размером

## Вопрос 2
Какой заголовочный файл нужно подключить для использования std::map?

A) `#include <container>`
B) `#include <map>`
C) `#include <dictionary>`
D) `#include <associative>`

## Вопрос 3
Что выведет следующий код?
```cpp
std::map<std::string, int> prices = {{"apple", 100}, {"banana", 50}};
std::cout << prices.size();
```

A) 0
B) 1
C) 2
D) Ошибка компиляции

## Вопрос 4
В каком порядке хранятся элементы в std::map?

A) В порядке вставки
B) В случайном порядке
C) По возрастанию ключей
D) По убыванию ключей

## Вопрос 5
Что произойдет при выполнении этого кода?
```cpp
std::map<std::string, int> prices = {{"apple", 100}};
int orange_price = prices["orange"];
```

A) Ошибка компиляции
B) Исключение во время выполнения
C) orange_price = 0, в map добавится элемент {"orange", 0}
D) orange_price получит неопределенное значение

## Вопрос 6
Какой метод НЕ переписывает существующие элементы в std::map?

A) operator[]
B) insert()
C) at()
D) emplace()

## Вопрос 7
Что вернет следующий код?
```cpp
std::map<std::string, int> data = {{"a", 1}, {"b", 2}};
auto [iter, inserted] = data.insert({"a", 10});
std::cout << inserted;
```

A) true
B) false
C) 1
D) 10

## Вопрос 8
Какой метод используется для проверки наличия ключа в map?

A) exists()
B) has_key()
C) contains()
D) present()

## Вопрос 9
Что делает метод find() в std::map?

A) Возвращает значение по ключу
B) Возвращает итератор на элемент или end()
C) Удаляет элемент
D) Подсчитывает количество элементов

## Вопрос 10
Что выведет этот код?
```cpp
std::map<int, std::string> data = {{3, "three"}, {1, "one"}, {2, "two"}};
for (const auto& [key, value] : data) {
    std::cout << key << " ";
}
```

A) 3 1 2
B) 1 2 3
C) Случайный порядок
D) Ошибка компиляции

## Вопрос 11
В какой структуре данных хранятся элементы std::map?

A) Массив
B) Связный список
C) Красно-черное дерево
D) Хеш-таблица

## Вопрос 12
Что делает метод erase() в std::map?

A) Очищает весь контейнер
B) Удаляет элемент по ключу или итератору
C) Удаляет последний элемент
D) Удаляет первый элемент

## Вопрос 13
Можно ли изменить ключ элемента в std::map?

A) Да, через итератор
B) Да, через operator[]
C) Нет, ключи константные
D) Только для числовых ключей

## Вопрос 14
Что выведет следующий код?
```cpp
std::set<int> numbers = {3, 1, 4, 1, 5};
std::cout << numbers.size();
```

A) 3
B) 4
C) 5
D) Ошибка компиляции

## Вопрос 15
Какое основное отличие std::set от std::map?

A) set быстрее map
B) set хранит только ключи, map - пары ключ-значение
C) set не сортирует элементы
D) set может хранить дубликаты

## Вопрос 16
Что делает std::multimap?

A) Хранит несколько типов данных
B) Позволяет дублирование ключей
C) Хранит элементы в нескольких контейнерах
D) Автоматически увеличивает размер

## Вопрос 17
Что выведет этот код?
```cpp
std::multimap<std::string, int> scores = {{"Alice", 95}, {"Alice", 87}};
std::cout << scores.count("Alice");
```

A) 1
B) 2
C) 95
D) 87

## Вопрос 18
В чем основное преимущество std::unordered_map над std::map?

A) Меньше памяти
B) Быстрее поиск (в среднем)
C) Автоматическая сортировка
D) Поддержка дубликатов

## Вопрос 19
Что нужно определить для использования пользовательского типа как ключа в std::unordered_map?

A) operator<
B) operator== и hash функцию
C) operator>
D) Только конструктор копирования

## Вопрос 20
Что делает метод equal_range() в std::multimap?

A) Проверяет равенство двух map
B) Возвращает диапазон элементов с одинаковым ключом
C) Сравнивает значения
D) Удаляет равные элементы

## Вопрос 21
Что выведет следующий код?
```cpp
std::set<std::string> words = {"hello", "world", "hello"};
for (const auto& word : words) {
    std::cout << word << " ";
}
```

A) hello world hello
B) hello world
C) world hello
D) hello hello world

## Вопрос 22
Какой метод добавляет элемент в std::set?

A) add()
B) push()
C) insert()
D) append()

## Вопрос 23
Что происходит при попытке вставить дублирующий элемент в std::set?

A) Элемент добавляется
B) Генерируется исключение
C) Элемент игнорируется
D) Заменяется существующий элемент

## Вопрос 24
Что выведет этот код?
```cpp
std::map<std::string, int> data;
data.try_emplace("key", 100);
data.try_emplace("key", 200);
std::cout << data["key"];
```

A) 100
B) 200
C) 0
D) Ошибка компиляции

## Вопрос 25
Какой компаратор используется по умолчанию в std::map?

A) std::greater
B) std::less
C) std::equal_to
D) std::hash

## Вопрос 26
Что делает insert_or_assign() в C++17?

A) Только вставляет новые элементы
B) Только обновляет существующие
C) Вставляет новые или обновляет существующие
D) Удаляет и вставляет заново

## Вопрос 27
Что выведет следующий код?
```cpp
std::map<int, std::string> data = {{1, "one"}, {2, "two"}};
auto node = data.extract(1);
std::cout << node.empty();
```

A) true
B) false
C) 1
D) Ошибка компиляции

## Вопрос 28
Какие итераторы инвалидируются при вставке в std::map?

A) Все итераторы
B) Только end()
C) Никакие (итераторы стабильны)
D) Только итераторы на вставленный элемент

## Вопрос 29
Что делает метод merge() для map в C++17?

A) Объединяет ключи
B) Перемещает элементы из одного map в другой
C) Создает новый map
D) Сортирует элементы

## Вопрос 30
Что выведет этот код?
```cpp
std::map<std::string, int> data1 = {{"a", 1}};
std::map<std::string, int> data2 = {{"b", 2}};
data1.merge(data2);
std::cout << data1.size() << " " << data2.size();
```

A) 1 1
B) 2 0
C) 2 1
D) 1 0

## Вопрос 31
Как правильно перебрать все значения с одним ключом в std::multimap?

A) Использовать find()
B) Использовать equal_range()
C) Использовать count()
D) Использовать operator[]

## Вопрос 32
Что такое transparent comparator?

A) Компаратор для прозрачных типов
B) Компаратор, позволяющий поиск без создания временных объектов
C) Компаратор, который не сравнивает элементы
D) Компаратор для указателей

## Вопрос 33
Что выведет следующий код?
```cpp
std::set<int> s1 = {1, 2, 3};
std::set<int> s2 = {3, 4, 5};
std::set<int> result;
std::set_intersection(s1.begin(), s1.end(), s2.begin(), s2.end(), 
                      std::inserter(result, result.begin()));
std::cout << result.size();
```

A) 0
B) 1
C) 3
D) 6

## Вопрос 34
В чем разница между at() и operator[] для map?

A) at() быстрее
B) at() генерирует исключение для несуществующих ключей
C) operator[] безопаснее
D) Нет разницы

## Вопрос 35
Что делает метод lower_bound() в std::map?

A) Находит минимальный элемент
B) Возвращает итератор на первый элемент не меньше заданного
C) Устанавливает нижнюю границу
D) Удаляет элементы ниже границы

## Вопрос 36
Какой из этих кодов корректен в C++17?

A) `std::map data = {{"a", 1}, {"b", 2}};`
B) `std::map<> data = {{"a", 1}, {"b", 2}};`
C) `std::map data<string, int> = {{"a", 1}, {"b", 2}};`
D) `auto data = std::map{{"a", 1}, {"b", 2}};`

## Вопрос 37
Что происходит с итераторами при удалении элемента из std::map?

A) Все итераторы инвалидируются
B) Инвалидируется только итератор на удаленный элемент
C) Итераторы остаются валидными
D) Инвалидируются итераторы после удаленного элемента

## Вопрос 38
Что выведет этот код?
```cpp
std::map<std::string, int> data = {{"apple", 100}, {"banana", 50}};
auto it = data.upper_bound("apple");
std::cout << it->first;
```

A) apple
B) banana
C) Ошибка выполнения
D) Первый элемент после "apple"

## Вопрос 39
Какой контейнер лучше использовать для быстрой проверки принадлежности элемента множеству?

A) std::vector
B) std::list
C) std::set или std::unordered_set
D) std::array

## Вопрос 40
Что делает следующий код?
```cpp
std::map<std::string, std::vector<int>> data;
data.emplace("key", std::initializer_list<int>{1, 2, 3});
```

A) Создает пустой вектор
B) Конструирует вектор на месте с элементами {1, 2, 3}
C) Копирует существующий вектор
D) Ошибка компиляции 