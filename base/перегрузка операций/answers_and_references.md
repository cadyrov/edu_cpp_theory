# Ответы на тест и ссылки на теорию

## Вопрос 1: B (правильный ответ)
**Ссылка на теорию:** строки 4-5
*Операция — это значок, используемый в коде в выражениях, такой как +, *, =.*

## Вопрос 2: B (правильный ответ)
**Ссылка на теорию:** строки 6-7
*Большинство операций бинарные, то есть имеют два операнда.*

## Вопрос 3: C (правильный ответ)
**Ссылка на теорию:** строки 8-9
*Тернарная операция в С++20 одна — это условный оператор a ? b : c.*

## Вопрос 4: B (правильный ответ)
**Ссылка на теорию:** строки 23-24
*Операции позволяют писать простой и понятный код. Но на самом деле они — то же самое, что и функции.*

## Вопрос 5: C (правильный ответ)
**Ссылка на теорию:** строки 47-48
*Основное отличие от структуры в том, что поля pair всегда называются first (англ. «первый») и second (англ. «второй»)*

## Вопрос 6: B (правильный ответ)
**Ссылка на теорию:** строки 49-50
*Контейнер pair — это простой контейнер, определённый в заголовке <utility>*

## Вопрос 7: C (правильный ответ)
**Ссылка на теорию:** строки 87-90
*Для пар определены операции сравнения... Сравнение ориентируется на первые элементы пары... Вторые элементы принимаются во внимание, только если первые элементы равны*

## Вопрос 8: B (правильный ответ)
**Ссылка на теорию:** строки 133-137
*Все операции могут быть перегружены, за исключением четырёх: доступа к элементу области видимости (::), доступа к полю класса (.), тернарной (?:), доступа к полю класса через указатель (.*).*

## Вопрос 9: B (правильный ответ)
**Ссылка на теорию:** строки 151-152
*Свободная функция — это функция, находящаяся вне какого-либо класса.*

## Вопрос 10: B (правильный ответ)
**Ссылка на теорию:** строки 179-180
*Для решения этой проблемы в языке предусмотрено ключевое слово friend. Оно позволяет сообщить, что некоторая функция имеет доступ к приватным членам класса.*

## Вопрос 11: C (правильный ответ)
**Ссылка на теорию:** строки 225-226
*Полный список операций и их приоритетов представлен в таблице. Наивысший приоритет имеет операция ::*

## Вопрос 12: B (правильный ответ)
**Ссылка на теорию:** строки 296-299
*Чтобы запомнить приоритет основных операций, можно использовать мнемоническое правило PUMA: P = постфиксные и префиксные, U = унарные, M = мультипликативные, A = аддитивные.*

## Вопрос 13: B (правильный ответ)
**Ссылка на теорию:** строки 368-369
*Но существуют и такие операции, которые вычисляются справа налево. К ним относятся унарные и различные виды присваивания.*

## Вопрос 14: C (правильный ответ)
**Ссылка на теорию:** строки 410-411
*Функция возвращает ссылку на поток std::ostream&, то есть значение первого параметра.*

## Вопрос 15: B (правильный ответ)
**Ссылка на теорию:** строки 431-432
*Это возможно благодаря двум особенностям... эти операции возвращают ссылку на поток.*

## Вопрос 16: B (правильный ответ)
**Ссылка на теорию:** строки 586-587
*Чтобы отличать объявления постфиксных операций от префиксных, для них указывается дополнительный параметр типа int.*

## Вопрос 17: C (правильный ответ)
**Ссылка на теорию:** строки 566-567
*Операции не принимают параметров... они возвращают изменённую копию объекта.*

## Вопрос 18: A (правильный ответ)
**Ссылка на теорию:** строки 590-591
*Эти операции должны возвращать исходную версию объекта, поэтому мы сохраняем её в переменную old_timer*

## Вопрос 19: B (правильный ответ)
**Ссылка на теорию:** строки 693-694
*Операцию = можно переопределить только в виде функции-члена класса или структуры.*

## Вопрос 20: B (правильный ответ)
**Ссылка на теорию:** строки 834-835
*с появлением стандарта C++20 хитрить больше не нужно: в этом стандарте появляется операция spaceship (<=>)*

## Вопрос 21: C (правильный ответ)
**Ссылка на теорию:** строки 835-836
*Достаточно переопределить только её, и компилятор автоматически выведет все остальные (<, <=, >, >=).*

## Вопрос 22: B (правильный ответ)
**Ссылка на теорию:** строки 1024-1025
*Чтобы избежать подобного поведения, используется ключевое слово explicit. Оно ставится рядом с конструктором или перегрузкой приведения, запрещая им участвовать в неявных преобразованиях.*

## Вопрос 23: B (правильный ответ)
**Ссылка на теорию:** строки 916-917
*Для этого в C++ существует операция static_cast.*

## Вопрос 24: B (правильный ответ)
**Ссылка на теорию:** строки 1152-1153
*Поразрядные операции во многом похожи на логические. Главное отличие состоит в том, что они работают с отдельными битами (разрядами) значений.*

## Вопрос 25: B (правильный ответ)
**Ссылка на теорию:** строки 1189-1190
*Чтобы элементы перечисления имели одну единицу в двоичном представлении, они должны равняться степеням двойки.*

## Вопрос 26: A (правильный ответ)
**Ссылка на теорию:** строки 1303-1304
*В приведённом примере перегрузка объявлена со словом const. Это значит, что операция допускает только чтение элементов*

## Вопрос 27: B (правильный ответ)
**Ссылка на теорию:** строки 1383-1384
*Подобные объекты в C++ называются функторами... перегрузка позволяет использовать объект func аналогично функциям.*

## Вопрос 28: C (правильный ответ)
**Ссылка на теорию:** строки 1395-1396
*Можно создавать собственные пользовательские литералы, определяя новые суффиксы. Но есть одно требование — они должны начинаться с подчеркивания _.*

## Вопрос 29: B (правильный ответ)
**Ссылка на теорию:** строки 428-429
*Во-первых, ввод и вывод левоассоциативные, то есть выполняются слева направо.*

## Вопрос 30: B (правильный ответ)
**Ссылка на теорию:** строки 1139-1140
*Перегруженные логические операции работают без этой оптимизации: выражения всегда будут рассчитываться целиком.*


## Вопрос 31: A (правильный ответ)
**Ссылка на теорию:** строки 87-90
*Для пар определены операции сравнения... Сравнение ориентируется на первые элементы пары... Вторые элементы принимаются во внимание, только если первые элементы равны*
**Объяснение:** p1{10, 20} и p2{10, 15} - первые элементы равны (10), поэтому сравниваются вторые: 20 > 15, результат true (1)

## Вопрос 32: A (правильный ответ)
**Ссылка на теорию:** строки 348-352
*Приоритет инкремента и декремента выше, чем у арифметических операций... Префиксный инкремент меняет значение до того, как оно используется в выражении*
**Объяснение:** ++b выполняется первым (b становится 4), затем 5 + 8 * 4 = 5 + 32 = 37

## Вопрос 33: B (правильный ответ)
**Ссылка на теорию:** строки 730-732
*Конструктор копирования создаёт новый объект, идентичный существующему... Point point_3 = point_1; // Здесь тоже вызовется конструктор*
**Объяснение:** Синтаксис Point p2 = p1 вызывает конструктор копирования, создавая копию p1

## Вопрос 34: A (правильный ответ)
**Ссылка на теорию:** строки 590-591
*Эти операции должны возвращать исходную версию объекта, поэтому мы сохраняем её в переменную old_timer*
**Объяснение:** Постфиксный инкремент возвращает старое значение (5), затем увеличивает переменную

## Вопрос 35: A (правильный ответ)
**Ссылка на теорию:** строки 768-770
*операции сравнения по умолчанию определены для таких типов, как строки, пары и векторы. В этом случае они действуют лексикографически*
**Объяснение:** Векторы сравниваются поэлементно: 1=1, 2=2, 3<4, поэтому v1 < v2 true (1)

## Вопрос 36: C (правильный ответ)
**Ссылка на теорию:** строки 1024-1025
*Чтобы избежать подобного поведения, используется ключевое слово explicit... запрещая им участвовать в неявных преобразованиях*
**Объяснение:** explicit конструктор запрещает неявное преобразование MyClass obj = 42

## Вопрос 37: B (правильный ответ)
**Ссылка на теорию:** строки 1189-1195
*Значения enum-типа нужно задать явно как степени двойки... Флаги используются для отражения каких-либо свойств объекта*
**Объяснение:** 0 | 1 = 1, затем 1 | 4 = 5 (в двоичном: 001 | 100 = 101)

## Вопрос 38: A (правильный ответ)
**Ссылка на теорию:** строки 1347-1348
*Начиная со стандарта C++23, ей можно передавать сразу несколько индексов, записывая их через запятую*
**Объяснение:** Множественные индексы в operator[] доступны только с C++23, в более ранних версиях это ошибка

## Вопрос 39: B (правильный ответ)
**Ссылка на теорию:** строки 1395-1410
*Можно создавать собственные пользовательские литералы... Литерал, обращающий строку*
**Объяснение:** Пользовательский литерал _reverse переворачивает строку "hello" в "olleh"

## Вопрос 40: A (правильный ответ)
**Ссылка на теорию:** строки 999-1002
*Перегрузка приведения к bool... Возвращает true, если остаётся время... if (timer) { std::cout << "Время ещё есть!"s << std::endl; }*
**Объяснение:** Point{0,0} преобразуется в false (0 != 0 || 0 != 0 = false), !false = true, выводится "Zero point"

---