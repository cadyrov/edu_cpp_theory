Введение в ассоциативные контейнеры
Когда вам нужна статья в энциклопедии, вы ищете слово — название статьи. Слово — это ключ, а статья — полезное значение, которое ассоциируется с ключом и к которому ключ дает доступ. Это пример ассоциативного контейнера.
Ассоциативные контейнеры умеют выполнять важную задачу — эффективно искать нужный элемент по ключу. Часто возникает ситуация, когда ключ — это само значение. Так происходит в set, который похож на map. Казалось бы, никакой ассоциации нет — ничто ни с чем не ассоциируется. Но set всё равно относят к ассоциативным контейнерам, потому что он умеет быстро находить нужный элемент. Чтобы задать особые критерии сравнения элементов множества и искать в set по этим критериям, используйте собственный компаратор. В следующем примере множество кошек учитывает не все поля структуры Cat, а только породу. Получается, что с каждой породой кошек ассоциирована некоторая кошка этой породы:
#include <algorithm>
#include <cassert>
#include <iostream>
#include <iterator>
#include <set>
using namespace std;
struct Cat {
    string breed;
    string name;
    int age;
};
ostream& operator<<(ostream& os, const Cat& cat) {
    return os <<'{' << cat.breed << ", "s << cat.name << ", "s << cat.age << '}';
}
// Компаратор, сравнивающий породы кошек
struct CatBreedComparator {
    // Помечаем компаратор как «прозрачный», чтобы с его помощью можно было сравнивать
    // не только кошек с кошками, но и со строками, задающими породу кошек
    using is_transparent = std::true_type; 
    bool operator()(const Cat& lhs, const Cat& rhs) const {
        return lhs.breed < rhs.breed;
    }
    bool operator()(const Cat& lhs, const string& rhs_breed) const {
        return lhs.breed < rhs_breed; 
    }
    bool operator()(const string& lhs_breed, const Cat& rhs) const {
        return lhs_breed < rhs.breed;
    }
};
int main() {
    // Множество кошек. Кошки считаются эквивалентными, если их породы совпадают.
    // В такой контейнер не получится поместить двух кошек одинаковой породы.
    set<Cat, CatBreedComparator> cats;
    
    cats.insert({"siamese"s, "Tom"s, 3});
    cats.insert({"bengal"s, "Leo"s, 2});
    cats.insert({"birman"s, "Tiger"s, 5});
    // Ginger вставлен не будет, так как множество уже содержит кошку сиамской породы
    cats.insert({"siamese"s, "Ginger"s, 2});
    
    // Выводим кошек в стандартный вывод, по одной на каждой строке
    copy(cats.begin(), cats.end(), ostream_iterator<Cat>(cout, "\n"));
    
    // Кошка, эквивалентная Мурке бенгальской породы, во множестве cats есть - это Leo
    assert(cats.count({"bengal"s, "Murka"s, 6}) == 1);
    
    // Компаратор CatBreedComparator позволяет искать кошек, указывая их породу
    if (auto it = cats.find("siamese"s); it != cats.end()) {
        cout << "Found cat: "s << *it << endl; // Выведет {siamese, Tom, 3}
    }
}
Используем map для поиска слов, наиболее часто встречаемых в тексте:
// файл wordstat.cpp
#include <iostream>
#include <map>
#include <string>
#include <tuple>
using namespace std;

int main() {
    string word;
    map<string, int> counts_map;
    while (cin >> word) {
        ++counts_map[move(word)];
    }
    cout << "Слово - Количество упоминаний в тексте"s << endl;
    // выводим первые 10 слов
    for (auto [iter, i] = tuple(counts_map.begin(), 0); i < 10 && iter != counts_map.end(); ++i, ++iter) {
        cout << iter->first << " - "s << iter->second << endl;
    }
}
Для примера возьмём книгу Джеффри Чосера «Кентерберийские рассказы». Мы сохранили её в файл canterbury.txt. При запуске перенаправим содержимое этого файла в cin программы, используя в командной строке символ <:
> g++ wordstat.cpp -o wordstat -std=c++17 -O3
> ./wordstat < canterbury.txt
Слово - Количество упоминаний в тексте
a - 3025
aaron - 1
abak - 2
abasshed - 1
abate - 1
abated - 1
abateth - 1
abaundone - 2
abaundoneth - 2
abaysed - 1
Видно, сколько раз встречался артикль «a» и некоторые другие слова. Но решить мы хотели другую задачу — слова отсортированы по алфавиту, а не по частоте. Чтобы исправить это, переместим слова в вектор и применим алгоритм sort. В качестве компаратора для sort используем лямбда-функцию, сравнивающую частоты слов:
// файл wordstat.cpp
#include <algorithm>
#include <iostream>
#include <iterator>
#include <map>
#include <string>
#include <tuple>
#include <vector>
using namespace std;

vector<pair<string, int>> GetSortedWordCounts(vector<string> words) {
    map<string, int> counts_map;

    for (auto& word : words) {
        ++counts_map[move(word)];
    }

    vector<pair<string, int>> counts_vector(move_iterator(counts_map.begin()), move_iterator(counts_map.end()));
    sort(counts_vector.begin(), counts_vector.end(), [](const auto& l, const auto& r) {
        return l.second > r.second;
    });

    return counts_vector;
}

int main() {
    vector<string> words;
    string word;

    while (cin >> word) {
        words.push_back(word);
    }

    auto counts_vector = GetSortedWordCounts(move(words));

    cout << "Слово - Количество упоминаний в тексте"s << endl;
    // выводим первые 10 слов
    for (auto [iter, i] = tuple(counts_vector.begin(), 0); i < 10 && iter != counts_vector.end(); ++i, ++iter) {
        cout << iter->first << " - "s << iter->second << endl;
    }
}
Проверим вывод теперь:
Слово - Количество упоминаний в тексте
and - 8877
that - 5832
the - 5623
of - 5351
to - 4002
he - 3718
in - 3544
his - 3103
for - 3027
a - 3025
Вывод правдоподобный: наиболее встречающиеся слова, как и следовало ожидать, — предлоги, союзы, артикли, местоимения.
Пусть в тексте содержится N слов. Вспомните тему об алгоритмической сложности и попробуйте оценить предложенный выше алгоритм.
Алгоритм состоит из двух частей:
Наполнение map.
Перенос в вектор и его сортировка.
Обе части имеют одинаковую сложность — O(NlogN). Улучшить сложность этой программы как будто невозможно, ведь более быстрого алгоритма сортировки не существует. 
Теперь проанализируйте текст с помощью программы самостоятельно. Поскольку здесь исследуется текст английского поэта, вопрос тоже сформулирован по-английски: Which word is the most frequent 5-letter word in Chaucer's book?.
canterbury.txt
Ответ: The word "which" is the most frequent 5-letter word in Chaucer's book..
Ускоряем, отказываясь от сортировки
В прошлом уроке мы проанализировали книгу английского писателя 14-го века и увидели, что он, как и современные авторы, чаще всего использовал местоимения, артикли и предлоги. Казалось, мы использовали эффективный контейнер map, и улучшить производительность не получится.
В этом уроке вы увидите, как значительно ускорить эту программу, изменив всего одну строчку. Как и при любой оптимизации, вначале нужно понять, какой из этапов программы занимает большее время. Для этого используем разработанный ранее макрос LOG_DURATION:
// файл wordstat.cpp
#include "log_duration.h"
#include <algorithm>
#include <iostream>
#include <iterator>
#include <map>
#include <string>
#include <tuple>
#include <vector>
using namespace std;
vector<pair<string, int>> GetSortedWordCounts(vector<string> words) {
    map<string, int> counts_map;
    {
        LOG_DURATION("Filling"s);
        for (auto& word : words) {
            ++counts_map[move(word)];
        }
    }
    {
        LOG_DURATION("Moving & sorting"s);
        vector<pair<string, int>> counts_vector(move_iterator(counts_map.begin()), move_iterator(counts_map.end()));
        sort(counts_vector.begin(), counts_vector.end(), [](const auto& l, const auto& r) {
            return l.second > r.second;
        });

        return counts_vector;
    }
}

int main() {
    vector<string> words;
    string word;
    while (cin >> word) {
        words.push_back(word);
    }
    auto counts_vector = GetSortedWordCounts(move(words));
    cout << "Слово - Количество упоминаний в тексте"s << endl;
    // выводим первые 10 слов
    for (auto [iter, i] = tuple(counts_vector.begin(), 0); i < 10 && iter != counts_vector.end(); ++i, ++iter) {
        cout << iter->first << " - "s << iter->second << endl;
    }
}
Подадим на вход книгу Чосера и посмотрим на результат:
Filling: 59 ms
Moving & sorting: 3 ms
Слово - Количество упоминаний в тексте
and - 8877
that - 5832
the - 5623
of - 5351
to - 4002
he - 3718
in - 3544
his - 3103
for - 3027
a - 3025
Первый этап работает медленнее в десятки раз несмотря на то, что имеет такую же асимптотическую сложность, как и второй.
Множитель в первом этапе значительно больше, чем во втором. Этим объясняется медленная работа заполнения, несмотря на одинаковую теоретическую оценку асимптотической сложности. Такой эффект происходит за счёт сложного внутреннего устройства контейнера map, которое будем разбирать ближе к концу этой темы. Благодаря тому, что асимптотическая сложность одинаковая, пропорция времени не будет меняться при увеличении количества входных данных.
Чтобы улучшить производительность, нужно от чего-нибудь отказаться. Какое лишнее действие совершает функция GetSortedWordCounts?
Сортирует слова по алфавиту на этапе заполнения.
Будем оптимизировать наиболее медленный первый этап. Перепишем всего одну строку, даже одну лексему: заменим map на unordered_map. Придётся, правда, включить дополнительный заголовочный файл с таким же названием <unordered_map>.
Программа с новым контейнером выдаст следующий результат:
Filling: 15 ms
Moving & sorting: 2 ms
Слово - Количество упоминаний в тексте
and - 8877
that - 5832
the - 5623
of - 5351
to - 4002
he - 3718
in - 3544
his - 3103
for - 3027
a - 3025
Как видно, результат не изменился, а производительность значительно возросла!
Название контейнера unordered_map говорит о его особенности: отсутствии порядка. Снова распечатаем промежуточный результат — сразу после заполнения контейнера словами, но до сортировки. Для этого добавим дополнительный вывод в функцию GetSortedWordCounts:
vector<pair<string, int>> GetSortedWordCounts(vector<string> words) {
    unordered_map<string, int> counts_map;
    {
        LOG_DURATION("Filling"s);

        for (auto& word : words) {
            ++counts_map[move(word)];
        }
    }
    cout << "Содержимое counts_map:"s << endl;
    for (auto [iter, i] = tuple(counts_map.begin(), 0); i < 10 && iter != counts_map.end(); ++i, ++iter) {
        cout << iter->first << " - "s << iter->second << endl;
    }
    {
        LOG_DURATION("Moving & sorting"s);
        vector<pair<string, int>> counts_vector(move_iterator(counts_map.begin()), move_iterator(counts_map.end()));
        sort(counts_vector.begin(), counts_vector.end(), [](const auto& l, const auto& r) {
            return l.second > r.second;
        });

        return counts_vector;
    }
}
Теперь вывод выглядит так:
Filling: 16 ms
Содержимое counts_map:
y-pilt - 1
sitthen - 1
ropes - 1
sisours - 2
assise - 2
enquered - 1
iustices - 2
ferd - 1
cheeke-boon - 1
iustise - 3
Moving & sorting: 3 ms
...
Видно, что в первой части вывода слова идут вразнобой — это особенность unordered_map. Но нас она нисколько не тревожит — порядок всё равно будет изменен впоследствии, так что для нашей задачи unordered_map работает идеально.
Считать слова хорошо, а считать деньги еще приятнее. Поэтому напишем программу для кошелька. Она будет выполнять похожую задачу — считать количество купюр каждого номинала, но сделает это проще — не понадобится ни map, ни unordered_map. Эффективность алгоритма будет на высоте. Существуют купюры номиналом от 1 до 5000, поэтому хранить количества можно в векторе:
#include <cassert>
#include <iostream>
#include <vector>
using namespace std;
class MoneyBox {
public:
    void PushCoin(int value) {
        assert(value >= 0 && value <= 5000);
        ++counts_[value];
    }

    void PrintCoins(ostream& out) const {
        for (int i = 0; i < counts_.size(); ++i) {
            if (counts_[i] > 0) {
                out << i << ": "s << counts_[i] << endl;
            }
        }
    }

private:
    // создаём вектор размера 5001 для того, чтобы последний
    // индекс соответствовал максимальному номиналу 5000
    vector<int> counts_ = vector<int>(5001);
};

ostream& operator<<(ostream& out, const MoneyBox& cash) {
    cash.PrintCoins(out);
    return out;
}

int main() {
    MoneyBox cash;
    int value;
    while (cin >> value) {
        cash.PushCoin(value);
    }
    cout << cash << endl;
}
Проверим программу на таком файле:
50 200 2000 500 50 500 2000 2000 100 10 50 50 50 200 50 200 
200 2000 200 500 5000 500 2000 50 500 2000 1000 500 2000 5000 
5000 2000 200 100 1000 10 200 200 200 2000 5000 200 100 1000 
50 10 1000 5000 1000 500 200 500 2000 1000 1000 200 200 1000 
50 100 500 200 2000 100 10 100 10 2000 10 10 2000 1000 100 
50 100 2000 2000 1000 50 500 1000 5000 500 100 500 10 2000 
10 200 500 10 5000 100 200 50 100 2000 100 50 1000
Результат
10: 10
50: 13
100: 12
200: 16
500: 13
1000: 12
2000: 17
5000: 7
Как вы думаете, в чём главный недостаток такого кошелька?
Он потребляет слишком много памяти.
Да, хранит 5001 число, а использует из них только девять.
Нам повезло работать с номиналами до 5000. А если бы расчёт происходил в югославских динарах, памяти, возможно, не хватило бы!


Хеш-функции
Решая задачу в прошлом уроке, вы могли подумать, что кошелек подходит для хранения любого типа данных: int64_t легко заменить на строки, бородатых гитаристов или bool. Имея в распоряжении перечень всех возможных значений, можно было бы создать эффективный контейнер на основе вектора. Этот контейнер хранил бы количество объектов каждого вида.
Например, вместо номиналов можно использовать названия банкнот, задаваемые переменной string. Единственное, что для этого нужно — определить функцию индексации, которая по объекту выдаст номер ячейки для его хранения. Так вы можете сохранять произвольный объект:
template <typename T>
class MoneyBox {
public:
    MoneyBox(vector<T> nominals)
        : nominals_(move(nominals))
        , counts_(nominals_.size()) {
    }
    const vector<int>& GetCounts() const {
        return counts_;
    }
    int GetIndex(const T& value) const {
        return find(nominals_.begin(), nominals_.end(), value) - nominals_.begin();
    }

    void PushCoin(const T& value) {
        int pos = GetIndex(value);
        assert(pos < int(nominals_.size()));

        ++counts_[pos];
    }

    void PrintCoins(ostream& out) const {
        for (int i = 0; i < int(nominals_.size()); ++i) {
            if (counts_[i] <= 0) {
                continue;
            }
            out << nominals_[i] << " - "s << counts_[i] << endl;
        }
    }
private:
    vector<T> nominals_;
    vector<int> counts_;
};
Однако в реальных задачах не всегда заранее известен небольшой перечень всех возможных объектов, которые предстоит хранить в контейнере. Например, решая задачу о словах в произведении Чосера, вы не имели перед собой словарь среднеанглийского языка. В подобных случаях функция индексации может использовать самые разные принципы.
Для примера создадим класс автомобильного номера. Он будет содержать функцию индексации, реализованную в методе Hash:
#include <iostream>
#include <sstream>
#include <iomanip>
#include <vector>
using namespace std;

class VehiclePlate {
public:
    VehiclePlate(char l0, char l1, int digits, char l2, int region)
        : letters_{l0, l1, l2}
        , digits_(digits)
        , region_(region) {
    }

    string ToString() const {
        ostringstream out;
        out << letters_[0] << letters_[1];
        // чтобы дополнить цифровую часть номера слева нулями
        // до трёх цифр, используем подобные манипуляторы:
        // setfill задаёт символ для заполнения,
        // right задаёт выравнивание по правому краю,
        // setw задаёт минимальное желаемое количество знаков
        out << setfill('0') << right << setw(3) << digits_;
        out << letters_[2] << setw(2) << region_;

        return out.str();
    }

    int Hash() const {
        return digits_;
    }

private:
    array<char, 3> letters_;
    int digits_;
    int region_;
};

ostream& operator<<(ostream& out, VehiclePlate plate) {
    out << plate.ToString();
    return out;
}
Такая функция индексации называется хеш-функцией. В коде выше — крайне простая хеш-функция: она возвращает цифровую часть номера, полностью игнорируя буквы и регион, и присваивает номер объекту произвольного типа. Значение хеш-функции объекта называется его хешем.
Хеш-функция позволила бы преодолеть ограничение в задаче прошлого урока. Там для хранения в контейнере требовался список всех возможных элементов. Если для составного объекта (автомобильный номер) в качестве ключа использовать простой объект (число), то можно хранить объекты в векторе, эффективно вычисляя их позицию.
📖 Не путайте слова «хеш» и «кэш». Кэш (англ. cache) — это промежуточный буфер, который позволяет осуществить кэширование данных, то есть временное хранение для последующей обработки. Кэш применяется для оптимизации. Также кэшем (англ. cash) называют наличные деньги, с этим вы сталкивались в предыдущем уроке. Здесь и далее в этой теме имеем дело с хешем (англ. hash) — результатом применения хеш-функции к объекту.
Реализуем контейнер для объектов, поддерживающих индексацию. В этот раз будем определять не количество одинаковых объектов, а их наличие или отсутствие. Для этого хорошо подойдёт тип optional, позволяющий сохранить объект, когда он появится. Элемент вектора можно представлять в виде пустой корзинки, в которую в некоторый момент кладут регистрационный номер автомобиля.

#include <optional>
#include <vector>
#include <array>

...

template <typename T>
class HashableContainer {
public:
    void Insert(T elem) {
        int index = elem.Hash();

        // если вектор недостаточно велик для этого индекса,
        // то увеличим его, выделив место с запасом
        if (index >= int(elements_.size())) {
            elements_.resize(index * 2 + 1);
        }

        elements_[index] = move(elem);
    }

    void PrintAll(ostream& out) const {
        for (auto& e : elements_) {
            if (!e.has_value()) {
                continue;
            }
            out << e.value() << endl;
        }
    }

private:
    vector<optional<T>> elements_;
};
Как видно, размер вектора изначально не задан, он будет автоматически подстраиваться под помещаемые объекты.
Изучите код контейнера выше и определите, какое максимальное количество корзин может создаваться при использовании контейнера с автомобильным номером. Учитывайте, что цифровая часть номера — это число от 0 до 999.
Если в контейнер сразу положить номер 999, размер вектора станет 1999 и больше не изменится. Однако если вначале положить 500, то за 1001 размер не выйдет, какие бы номера ни клали впоследствии.
Заполнено будет не более 1000 корзинок. Получается, размер вектора максимум в два раза превышает количество номеров. Вполне допустимые издержки. Но у этой программы есть более серьёзный недостаток. Найти его можно, протестировав контейнер и номерной знак:
...
int main() {
    HashableContainer<VehiclePlate> plate_base;
    plate_base.Insert({'B','H', 840, 'E', 99});
    plate_base.Insert({'O','K', 942, 'K', 78});
    plate_base.Insert({'H','E', 968, 'C', 79});
    plate_base.Insert({'T','A', 326, 'X', 83});
    plate_base.Insert({'H','H', 831, 'P', 116});
    plate_base.Insert({'P','M', 884, 'K', 23});
    plate_base.Insert({'O','C', 34, 'P', 24});
    plate_base.Insert({'M','Y', 831, 'M', 43});
    plate_base.Insert({'K','T', 478, 'P', 49});
    plate_base.Insert({'X','P', 850, 'A', 50});

    plate_base.PrintAll(cout);
}
Запускаем и проверяем ответ:
OC034P24
TA326X83
KT478P49
MY831M43
BH840E99
XP850A50
PM884K23
OK942K78
HE968C79
Один из номеров пропал.
Куда пропал номер НН831Р116?
Цифровая часть совпала с другим номером, и он перезаписал его.
Устройство unordered_map и unordered_set
В этом уроке разберемся, что позволило контейнеру unordered_map работать в разы быстрее, чем его «коллега» map. Вы увидите, как использовать его для своих классов, заменив собственный контейнер из прошлого урока на стандартный.
Для начала обратимся к документации. Ранее вы использовали методы unordered_map::operator[] и unordered_map::insert. Согласно сайту cppreference.com, сложность этих методов в среднем действительно лучше, чем у map. Она оценивается как O(1), если хеш-функция имеет константную сложность.
Но в худшем случае возникает O(N), где N — количество элементов в контейнере. Чтобы понять, какой случай будет худшим, а какой средним, нужно разобраться, как работает unordered_map и как получилось добиться такой удивительной средней сложности O(1).
В устройстве unordered_map и unordered_set лежат идеи, похожие на те, что вы применили при решении задачи в прошлом уроке. Эти контейнеры хранят объекты в корзинках и используют хеш-функцию, чтобы определить, в какой корзинке разместить объект. В unordered_map и unordered_set реализованы алгоритмы для определения количества корзин и разрешения коллизий.
Главное отличие unordered_set от контейнера, который вы разрабатывали в задаче, — он не использует отдельную корзинку для каждого возможного значения хеш-функции. Благодаря этому хеши объектов могут быть очень большими, а количество выделенных корзинок всё равно будет невелико. Заботиться о том, чтобы объекты располагались компактно в отведенных для них корзинках, не нужно: контейнер сам организует размещение объектов по корзинкам.
В хорошем случае коллизий мало или нет вовсе. Каждая корзинка хранит максимум одно значение, добавление очень быстрое — вычисляем хеш объекта, быстро находим по индексу корзинку и добавляем. Проверка наличия и печать всех элементов будет такой же быстрой. Но хороший случай вероятен только при хорошей хеш-функции. При некоторых условиях он практически гарантирован.
Заменим контейнер из предыдущего урока на unordered_set:
#include <unordered_set>
// реализация class VehiclePlate из предыдущего урока
int main() {
    unordered_set<VehiclePlate> plate_base;

    plate_base.insert({'B', 'H', 840, 'E', 99});
    plate_base.insert({'O', 'K', 942, 'K', 78});
    plate_base.insert({'O', 'K', 942, 'K', 78});
    plate_base.insert({'O', 'K', 942, 'K', 78});
    plate_base.insert({'O', 'K', 942, 'K', 78});
    plate_base.insert({'H', 'E', 968, 'C', 79});
    plate_base.insert({'T', 'A', 326, 'X', 83});
    plate_base.insert({'H', 'H', 831, 'P', 116});
    plate_base.insert({'A', 'P', 831, 'Y', 99});
    plate_base.insert({'P', 'M', 884, 'K', 23});
    plate_base.insert({'O', 'C', 34, 'P', 24});
    plate_base.insert({'M', 'Y', 831, 'M', 43});
    plate_base.insert({'B', 'P', 831, 'M', 79});
    plate_base.insert({'K', 'T', 478, 'P', 49});
    plate_base.insert({'X', 'P', 850, 'A', 50});

    for (auto& plate : plate_base) {
        cout << plate << endl;
    }
}
При попытке собрать и запустить эту программу получим такое сообщение: error: static assertion failed: hash function must be invocable with an argument of key type static_assert(__is_invocable<const _H1&, const _Key&>{}.
Эта ошибка показывает, что контейнер не нашёл хеш-функцию для класса. Мы определили хеш-функцию в методе Hash, но не сказали контейнеру, что именно её нужно использовать для хеширования.
Чтобы сообщить unordered_set и unordered_map, как именно вычислять хеш произвольного объекта, нужно создать специальный класс — хешер и указать его в качестве шаблонного параметра контейнера. К хешеру предъявляется только одно требование: объект этого класса должен быть вызываемым — например, переопределять оператор «круглые скобки». Вызов этого объекта должен возвращать число типа size_t (этот тип используется в unordered_set и unordered_map для хеширования).
Проще всего понять, как реализовать хешер, на примере:
...

class VehiclePlateHasher {
public:
    size_t operator()(const VehiclePlate& plate) const {
        return static_cast<size_t>(plate.Hash());
    }
};
int main() {
    // явно указываем хешер шаблонным параметром
    unordered_set<VehiclePlate, VehiclePlateHasher> plate_base;

    plate_base.insert({'B', 'H', 840, 'E', 99});
    plate_base.insert({'O', 'K', 942, 'K', 78});
    plate_base.insert({'O', 'K', 942, 'K', 78});
    plate_base.insert({'O', 'K', 942, 'K', 78});
    plate_base.insert({'O', 'K', 942, 'K', 78});
    plate_base.insert({'H', 'E', 968, 'C', 79});
    plate_base.insert({'T', 'A', 326, 'X', 83});
    plate_base.insert({'H', 'H', 831, 'P', 116});
    plate_base.insert({'A', 'P', 831, 'Y', 99});
    plate_base.insert({'P', 'M', 884, 'K', 23});
    plate_base.insert({'O', 'C', 34, 'P', 24});
    plate_base.insert({'M', 'Y', 831, 'M', 43});
    plate_base.insert({'B', 'P', 831, 'M', 79});
    plate_base.insert({'K', 'T', 478, 'P', 49});
    plate_base.insert({'X', 'P', 850, 'A', 50});

    for (auto& plate : plate_base) {
        cout << plate << endl;
    }
}
В стандартной библиотеке уже определены хешеры для стандартных объектов: строк, чисел, указателей, optional и некоторых других. Эти хешеры реализованы в шаблонном классе hash.
Скомпилируем заново. Ошибка поменялась, теперь компилятору не нравится отсутствие операции сравнения: error: no match for 'operator==' (operand types are 'const VehiclePlate' and 'const VehiclePlate'). Вы уже разработали эту операцию в задании прошлого урока. В этом уроке реализуем его, используя операцию сравнения объектов tuple из стандартной библиотеки:
#include <tuple>
class VehiclePlate {
private:
    auto AsTuple() const {
        return tie(letters_, digits_, region_);
    }

public:
    bool operator==(const VehiclePlate& other) const {
        return AsTuple() == other.AsTuple();
    }
...
};
Ура, программа скомпилировалась! Проверяем результат:
KT478P49
TA326X83
XP850A50
OK942K78
HE968C79
BH840E99
PM884K23
HH831P116
AP831Y99
MY831M43
BP831M79
OC034P24
Результат правильный, но порядок вывода отличается от того, который был в нашем контейнере. Трудно понять почему. Проверим, подчиняется ли этот порядок какому-нибудь закону. Для этого переложим все номера в другой unordered_set и выведем его содержимое:
int main() {
    unordered_set<VehiclePlate, VehiclePlateHasher> plate_base;
    cout << "Первый контейнер:"s << endl;
    for (auto& plate : plate_base) {
        cout << plate << endl;
    }

    cout << "Второй контейнер:"s << endl;
    unordered_set<VehiclePlate, VehiclePlateHasher> plate_base2(plate_base.begin(), plate_base.end());
    for (auto& plate : plate_base2) {
        cout << plate << endl;
    }
}
Проверяем результат работы программы:
Первый контейнер:
KT478P49
TA326X83
XP850A50
OK942K78
HE968C79
BH840E99
PM884K23
HH831P116
AP831Y99
MY831M43
BP831M79
OC034P24
Второй контейнер:
BP831M79
MY831M43
AP831Y99
HH831P116
PM884K23
OC034P24
BH840E99
HE968C79
OK942K78
XP850A50
TA326X83
KT478P49
Оба контейнера содержат одинаковые элементы, но выдают их в разном порядке, значит, порядок unordered_set действительно произвольный, он не определяется содержимым. Заметим, что элементы одной корзинки вывелись рядом, однако это тоже может зависеть от реализации unordered_set.
Аналогично устроен контейнер unordered_map, которым можно смело заменять map, если порядок элементов не важен. Как и в unordered_set, в этом контейнере требуется, чтобы ключи удовлетворяли двум условиям:
имели хешер — класс, вычисляющий хеш-функцию. Тип хешера указывается третьим параметром шаблона unordered_map и вторым параметром шаблона unordered_set;
имели возможность сравнения операцией operator==.
В случае unordered_map эти условия должны быть соблюдены для ключей, а значения могут быть произвольными.
Если не хотите определять operator==, можно поменять компаратор, задаваемый шаблонным параметром после хешера. Компаратор похож на хешер и тоже использует operator() для выполнения действия. В отличие от хешера, он не вычисляет характеристику одного объекта, а определяет понятие равенства.
Компаратор можно менять в обычных map и set. Для этих контейнеров равенства недостаточно, они должны определять, какой элемент больше, а какой меньше. Компаратор по умолчанию в них — std::less. Он использует operator<. Если хотите использовать свой класс в set или в качестве ключа в map, достаточно определить для элементов этого типа операцию сравнения <. В случае с VehiclePlate можно определить операцию сравнения, используя уже готовый метод AsTuple:
class VehiclePlate {
private:
    auto AsTuple() const {
        return tie(letters_, digits_, region_);
    }
public:
    bool operator<(const VehiclePlate& other) const {
        return AsTuple() < other.AsTuple();
    }
...
};
📖 Компаратор обязан удовлетворять некоторым свойствам, иначе контейнер будет работать некорректно, что может привести к неопределенному поведению. Например, проверка на равенство, которая используется в unordered_set, должна обладать симметричностью, то есть условия a == b и b == a для произвольных a и b должны быть истинными или ложными одновременно. Операция сравнения для map, напротив, симметричностью обладать не может, так как невозможно, чтобы оба элемента были меньше друг друга.
Хорошие и плохие хеш-функции
Мы рассмотрели уже две хеш-функции для автомобильных номеров. Одна — простая — учитывала только цифровую часть. Другая — её вы написали сами — учитывала весь номер, но предварительно конвертировала его в строку. В этом уроке выясним, можно ли утверждать, что одна из них лучше другой, и разберёмся, что такое хорошая хеш-функция. Вы увидите: unordered_map может быть эффективным, только если выбранная хеш-функция хороша.
В этом уроке нам понадобится генератор случайных номеров:
class PlateGenerator {
    char GenerateChar() {
        uniform_int_distribution<short> char_gen{0, static_cast<short>(possible_chars_.size() - 1)};
        return possible_chars_[char_gen(engine_)];
    }

    int GenerateNumber() {
        uniform_int_distribution<short> num_gen{0, 999};
        return num_gen(engine_);
    }

    int GenerateRegion() {
        uniform_int_distribution<short> region_gen{0, static_cast<short>(possible_regions_.size() - 1)};
        return possible_regions_[region_gen(engine_)];
    }

public:
    VehiclePlate Generate() {
        return VehiclePlate(GenerateChar(), GenerateChar(), GenerateNumber(), GenerateChar(), GenerateRegion());
    }

private:
    mt19937 engine_;

    // допустимые значения сохраним в static переменных
    // они объявлены inline, чтобы их определение не надо было выносить вне класса
    inline static const array possible_regions_
        = {1,  2,  102, 3,   4,   5,   6,   7,   8,  9,   10,  11,  12, 13,  113, 14,  15, 16,  116, 17, 18,
           19, 20, 21,  121, 22,  23,  93,  123, 24, 84,  88,  124, 25, 125, 26,  27,  28, 29,  30,  31, 32,
           33, 34, 35,  36,  136, 37,  38,  85,  39, 91,  40,  41,  82, 42,  142, 43,  44, 45,  46,  47, 48,
           49, 50, 90,  150, 190, 51,  52,  152, 53, 54,  154, 55,  56, 57,  58,  59,  81, 159, 60,  61, 161,
           62, 63, 163, 64,  164, 65,  66,  96,  67, 68,  69,  70,  71, 72,  73,  173, 74, 174, 75,  80, 76,
           77, 97, 99,  177, 199, 197, 777, 78,  98, 178, 79,  83,  86, 87,  89,  94,  95};

    // постфикс s у литерала тут недопустим, он приведёт к неопределённому поведению
    inline static const string_view possible_chars_ = "ABCEHKMNOPTXY"sv;
};
Протестируем генератор номеров, выведя десять случайных:
int main() {
    static const int N = 10;
    PlateGenerator plate_gen;

    for (int i = 0; i < N; ++i) {
        cout << plate_gen.Generate() << endl;
    }
}
Проверяем:
BT905B173
HO221X87
NC278N11
YY996Y95
YY970P17
ET798M13
XB421A16
MY878T59
XH035T159
KO681Y22
Номера выглядят как случайные. Протестируем с помощью этого генератора различные хеш-функции. Начнём с простой, учитывающей только цифровую часть:
class VehiclePlate {
private:
    auto AsTuple() const {
        return tie(letters_, digits_, region_);
    }
public:
    bool operator==(const VehiclePlate& other) const {
        return AsTuple() == other.AsTuple();
    }

    bool operator<(const VehiclePlate& other) const {
        return AsTuple() < other.AsTuple();
    }

    VehiclePlate(char l0, char l1, int digits, char l2, int region)
        : letters_{l0, l1, l2}
        , digits_(digits)
        , region_(region) {
    }

    string ToString() const {
        ostringstream out;
        out << letters_[0] << letters_[1];
        out << setfill('0') << right << setw(3) << digits_;
        out << letters_[2] << setw(2) << region_;

        return out.str();
    }

    const array<char, 3>& GetLetters() const {
        return letters_;
    }

    int GetDigits() const {
        return digits_;
    }

    int GetRegion() const {
        return region_;
    }

private:
    array<char, 3> letters_;
    int digits_;
    int region_;
};

struct PlateHasherTrivial {
    size_t operator()(const VehiclePlate& plate) const {
        return static_cast<size_t>(plate.GetDigits());
    }
};
Для проверки эффективности контейнера с такой хеш-функцией добавим в него 50 000 случайных номеров и столько же поищем. Будем сравнивать unordered_set и обычный set. Чтобы поставить контейнеры в равное положение, сначала генерируем случайные номера и сохраним их в вектор:
#include "log_duration.h"
#include <algorithm>
#include <iterator>
#include <set>
#include <unordered_set>

...

int main() {
    static const int N = 50'000;

    PlateGenerator generator;
    vector<VehiclePlate> fill_vector;
    vector<VehiclePlate> find_vector;

    generate_n(back_inserter(fill_vector), N, [&]() {
        return generator.Generate();
    });
    generate_n(back_inserter(find_vector), N, [&]() {
        return generator.Generate();
    });

    int found;
    {
        LOG_DURATION("unordered_set");
        unordered_set<VehiclePlate, PlateHasherTrivial> container;
        for (auto& p : fill_vector) {
            container.insert(p);
        }
        found = count_if(find_vector.begin(), find_vector.end(), [&](const VehiclePlate& plate) {
            return container.count(plate) > 0;
        });
    }
    cout << "Найдено повторов (1): "s << found << endl;

    {
        LOG_DURATION("set");
        set<VehiclePlate> container;
        for (auto& p : fill_vector) {
            container.insert(p);
        }
        found = count_if(find_vector.begin(), find_vector.end(), [&](const VehiclePlate& plate) {
            return container.count(plate) > 0;
        });
    }
    cout << "Найдено повторов (2): "s << found << endl;
}
Соберём программу с оптимизацией и проверим результат:
unordered_set: 371 ms
Найдено повторов (1): 9
set: 52 ms
Найдено повторов (2): 9
Оба алгоритма выдали одинаковый ответ, но unordered_set, вопреки теоретической оценке сложности, оказался вовсе не быстрее, а, наоборот, примерно в семь раз медленнее.
Возникает много коллизий, unordered_set не может работать эффективно при таких условиях.
Мы подобрали неудачную хеш-функцию, она провоцирует коллизии. Хорошо, что это всего лишь коллизии номеров в контейнере, а не машин на дорогах! Однако результат не лучший.
Хеш-функция может принимать всего 1000 разных значений. Это значит, что будет задействовано примерно 1000 корзин. Так как номеров 50 000, на каждую корзину приходится по 50 номеров. Это очень большое количество коллизий. Вот почему желательно, чтобы хеш-функция учитывала все данные.

Модифицируем хеш-функцию, чтобы она учитывала не только цифровую часть, но и код региона:
struct PlateHasherRegion {
    size_t operator()(const VehiclePlate& plate) const {
        return static_cast<size_t>(plate.GetDigits() + plate.GetRegion() * 1000);
    }
};
unordered_set<VehiclePlate, PlateHasherRegion> container;
Умножая регион на 1000 и прибавляя цифровую часть, мы как бы объединяем два числа в одно, получая одно пятизначное или шестизначное число.

Проверяем результат:
unordered_set: 19 ms
Найдено повторов (1): 9
set: 58 ms
Найдено повторов (2): 9
Скорость увеличилась многократно, и теперь неупорядоченный контейнер заметно выигрывает у своего «коллеги» set. Но увеличим размер ещё, пускай количество номеров станет равно миллиону.
Попробуйте предугадать, насколько эффективно unordered_set сможет справиться с миллионом. Помните, что количество кодов региона — 122. Как много коллизий можно ожидать?
Имеем 122 кода региона и 1000 цифровых частей. Всего получится 122 000 различных хешей, которые могут определять различные корзины. При распределении миллиона номеров получится по восемь-девять объектов в каждой корзине.

Запустим программу и проверим эффективность контейнеров:
unordered_set: 2055 ms
Найдено повторов (1): 3791
set: 2455 ms
Найдено повторов (2): 3791
Неупорядоченный контейнер по-прежнему выигрывает, но уже не так сильно, как хотелось бы. Теперь представьте, что контейнер обрабатывает данные с камеры, установленной в Санкт-Петербурге. Подавляющее количество автомобильных номеров будут иметь коды регионов 78, 98, 178. Количество коллизий тогда будет существенно больше, а контейнер — менее эффективным.
Хорошо, последняя попытка. Возьмём хешер, который вы реализовали в прошлом уроке. Он использует строковое представление номера, а значит, учитывает все его данные. Ваша реализация могла выглядеть так:
struct PlateHasherString {
    size_t operator()(const VehiclePlate& plate) const {
        return hasher(plate.ToString());
    }

    hash<string> hasher;
};

...
unordered_set<VehiclePlate, PlateHasherString> container;
На этот раз эффективность должна быть на высоте. Проверим это:
unordered_set: 2651 ms
Найдено повторов (1): 3791
set: 2462 ms
Найдено повторов (2): 3791
Однако нет, эффективность даже ухудшилась. Теперь контейнер проигрывает и set.
Хеш-функция учитывает все данные, а значит, коллизий будет минимальное количество. На этот раз причина в другом: мы выбрали медленную хеш-функцию и теперь вынуждены использовать промежуточный поток, а также операции со string при каждом добавлении и поиске номера. set не требует вычисления строкового представления номера и работает быстрее.
Искусство хеш-функций
Как вы увидели в прошлом уроке, неупорядоченный контейнер сильно зависит от хеш-функции. Если хешер плохой, то контейнер будет работать неэффективно — даже хуже, чем его «коллега» set или map. И у хеш-функции есть минимум две причины быть плохой:
она может учитывать не все данные объекта, провоцируя коллизии,
она может медленно вычисляться.
Решая задачу, вы научились строить совершенную хеш-функцию, значения которой никогда не совпадают для разных объектов. Подумаем, всегда ли это возможно. Попробуем захешировать структуру, задающую фрагмент файла позициями начала и конца фрагмента:
#include <cstdint>

struct Fragment {
    uint64_t begin;
    uint64_t end;
};
Поля структуры имеют размер 64 бита, а значит, могут принимать 2⁶⁴ различных значений. Вся структура содержит два таких поля, а значит, может иметь 2¹²⁸ различных значений. Результат хеш-функции представлен числом типа size_t, занимающим обычно 64 бита. Чтобы посчитать количество всевозможных хешей, возведем двойку в степень 64. Получим, что количество различных хешей гораздо меньше, чем количество различных значений структуры Fragment. Это значит, что как бы мы не реализовывали хеш-функцию, всегда будут возможны коллизии — различные объекты Fragment, имеющие одинаковые хеши. Подобное относится и к хешированию string, которое мы неявно использовали, когда применяли unordered_set для подсчёта частот слов в произведении Чосера.
📖 Хеширование еще называют необратимым шифрованием. Шифрованием — потому что оно кодирует данные. Необратимым — потому что восстанавливать по коду исходные данные не нужно и, скорее всего, невозможно. Представьте, что регистрируетесь на каком-либо интернет-ресурсе. Если он сделан профессионально, он не будет сохранять ваш пароль. Пароль должен немедленно уничтожаться, сводя возможность утечки на нет. Профессионально сделанный сайт запомнит только некоторый хеш вашего пароля. Этого достаточно для проверки его правильности, но недостаточно для восстановления. Отсюда следует, что непременно существуют другие пароли, по которым можно войти в систему наравне с вашим. Количество хешей меньше, чем количество паролей. Разные пароли неизбежно имеют одинаковые хеши.
Поскольку реализовать совершенный хешер для Fragment невозможно, реализуем несовершенный:
struct FragmentHasher {
    size_t operator() (const Fragment& f) const {
        return static_cast<size_t>(f.begin + f.end);
    }
};
Как вы думаете, в каком из следующих случаев возникнет коллизия двух фрагментов?
Когда каждый фрагмент имеет одинаковый отступ от начала и конца файла
Как видим, коллизии могут возникать во вполне естественных случаях. Изменим эту функцию, чтобы её вычисление оставалось быстрым, но коллизии были менее вероятны:
struct FragmentHasher {
    static const uint64_t N;
    size_t operator() (const Fragment& f) const {
        return static_cast<size_t>(f.begin * N + f.end);
    }
};
По некоторым статистическим соображениям обычно в качестве N выбирают простое число, например 37. Для обычных целей будет вполне достаточно такой хеш-функции, но её минус в том, что есть простой алгоритм, позволяющий находить коллизии:
int main() {
    FragmentHasher hasher;
    Fragment f1{10, 1000};
    Fragment f2{10 + 1, 1000 - 37 * 1};
    Fragment f3{10 + 2, 1000 - 37 * 2};
    Fragment f4{10 + 3, 1000 - 37 * 3};

    cout << "f1 hash - "s << hasher(f1) << endl;
    cout << "f2 hash - "s << hasher(f2) << endl;
    cout << "f3 hash - "s << hasher(f3) << endl;
    cout << "f4 hash - "s << hasher(f4) << endl;
}
Результат программы:
f1 hash - 1370
f2 hash - 1370
f3 hash - 1370
f4 hash - 1370
Более совершенные хеш-функции, используемые в криптографии, имеют собственные названия: MD5, SHA-512, BLAKE3. Алгоритм поиска коллизий для них крайне сложный и требует больших вычислительных ресурсов. Маловероятно, что коллизии будут возникать естественным образом или будут подобраны злоумышленниками.
📖 Функция MD5 не считается криптографически стойкой, и алгоритм поиска коллизий известен. Чтобы усложнить их поиск, добавляют соль — некоторую фиксированную секретную строку, которую приписывают к данным до хеширования.
Криптографические хеш-функции вычисляются достаточно медленно. В криптографических задачах это иногда даже считается плюсом, но на практике их лучше не использовать без необходимости. Как правило, бывает достаточно хеш-функции из приведенного примера с умножением на простое число. Рассмотрим структуру, состоящую из трёх полей и задающую окружность на плоскости:
struct Circle {
    double x;
    double y;
    double r;
};
Можно вычислить хеш каждого из трех полей структуры, используя хешер std::hash<double>, а затем объединить их, умножив на число 37. Одну компоненту нужно умножать на 37, а вторую на 37²:
struct CircleHasher {
    size_t operator() (const Circle& circle) const {
        size_t h_x = d_hasher_(circle.x);
        size_t h_y = d_hasher_(circle.y);
        size_t h_r = d_hasher_(circle.r);
        
        return h_x + h_y * 37 + h_r * (37 * 37);
    }

private:
    std::hash<double> d_hasher_;
};
Такая хеш-функция будет обладать хорошими статистическими свойствами, обеспечивая равномерное заполнение корзинок. Если полей больше, можно складывать их хеши, умножая на новые степени числа 37: на 37³, 37⁴, 37⁵ и т. д. Только учтите — разные параметры хешируемых данных должны обязательно умножаться на разные степени простого числа. Если степень у двух параметров получится одинаковой, статистические свойства хеш-функции ухудшатся.
Выхода за пределы допустимого диапазона size_t при этом можно не бояться — на качестве хеш-функции это не отразится. Так можно хешировать произвольные типы данных, объединяя поля, которые могут иметь самые разные типы. Даже не обязательно, чтобы их количество было заранее известно. Приведем пример — реализуем хешер для vector<int>:
struct IntVectorHasher {
    size_t operator() (const vector<int>& vec) const {
        size_t res = 0;
        for (int num : vec) {
            res = res * 37 + static_cast<size_t>(num);
        }
        return res;
    }
};
Хеш-функция перемешивает данные, делая их неузнаваемыми. И если для обычной функции понятность и предсказуемость результата — это плюс, то для хеш-функции — большой минус. Она должна запутать данные как можно сильнее. Если при этом происходит что-нибудь необратимое и непонятное, прекрасно — значит, коллизии будут возникать реже. Однако в практических примерах, не связанных с криптографией, на первом месте остаётся производительность.
Транспортный справочник — продумываем проект
Формулировка задания
В этом задании нужно реализовать систему хранения остановок и транспортных маршрутов и обработку запросов к этой системе. Сначала на вход подаются запросы на создание базы данных, затем — запросы к самой базе.
Расширяя функциональность программы, вы будете иметь дело с собственной архитектурой кода и почувствуете, какие именно проектировочные решения мешают его расширять.
Разбейте задачу на файлы. Реализуйте чтение в отдельном модуле, который будет отвечать за ввод и вывод данных. Сам транспортный справочник разместите в отдельном классе. Он не должен работать с вводом и выводом. Также создайте структуры для хранения информации об остановке и об автобусном маршруте.
Формат ввода базы данных
В первой строке стандартного потока ввода содержится число N — количество запросов на обновление базы данных, затем — по одному на строке — вводятся сами запросы. Запросы бывают двух типов.
Stop X: latitude, longitude
Добавляет информацию об остановке с названием X и координатами latitude (широта) и longitude (долгота) на земной поверхности. Название остановки может состоять из нескольких слов. Используйте двоеточие как признак окончания названия остановки.
Широта задаётся в градусах от -90.0 (Южный полюс) до +90.0 (Северный полюс). Положительные широты расположены севернее экватора, отрицательные — южнее. Долгота задаётся в градусах от -180.0 до +180.0, положительные значения соответствуют восточной долготе, а отрицательные — западной.
Нулевой меридиан проходит через Гринвичскую королевскую обсерваторию в Лондоне, а координаты Останкинской телебашни равны 55.8199081 северной широты и 37.6116028 восточной долготы. Широта и долгота разделяются запятой, за которой следует пробел.
Гарантируется, что остановка X определена не более чем в одном запросе Stop.
Bus X: описание маршрута
Запрос на добавление автобусного маршрута X. Название маршрута может состоять из нескольких слов и отделяется от описания двоеточием. Описание маршрута может задаваться в одном из двух форматов:
stop1 - stop2 - ... - stopN: автобус следует от stop1 до stopN и обратно с указанными промежуточными остановками.
Маршрут, заданный остановками A, B, C, D. Автобус проходит через остановки: A, B, C, D, C, B, A
stop1 > stop2 > ... > stopN > stop1: кольцевой маршрут с конечной stop1.
Кольцевой маршрут, заданный остановками A, B, C, D, A
По сути первая версия описания маршрута эквивалентна stop1 > stop2 > ... > stopN-1 > stopN > stopN-1 > ... > stop2 > stop1.
На рисунке показаны шесть остановок: A, B, C, D, E, F и два автобусных маршрута: кольцевой A>C>D>B>A и обычный E-B-D-F.
Маршруты A>C>D>B>A и E-B-D-F
Гарантируется, что каждая из остановок маршрута определена в некотором запросе Stop, а сам маршрут X определён не более чем в одном запросе Bus.
Формат запросов к базе данных
Запросы к базе данных подаются в cin после запросов на создание базы. В первой строке вводится количество запросов N, затем — по одному в строке — вводятся сами запросы. В этом задании поддерживаются запросы одного типа.
Bus X: R stops on route, U unique stops, L route length
Где:
X — название маршрута. Оно совпадает с названием, переданным в запрос Bus на ввод данных.
R — количество остановок в маршруте автобуса от stop1 до stop1 включительно.
U — количество уникальных остановок, на которых останавливается автобус. Одинаковыми считаются остановки, имеющие одинаковые названия.
L — длина маршрута в метрах. В этом задании для простоты считается, что автобус проезжает путь между двумя соседними остановками по кратчайшему расстоянию по земной поверхности. Для вычисления расстояния между двумя точками используйте функцию ComputeDistance из заготовки кода.
Величину расстояния, а также другие вещественные числа в последующих частях задачи выводите с шестью значащими цифрами, то есть после манипулятора setprecision(6).
Если маршрут X не найден, выведите Bus X: not found.
Ограничения
Код должен быть аккуратным, эффективным, структурированным и выполнять свою задачу. В конце спринта код транспортного справочника будет проходить ревью.
Разместите код программы в следующих исходных файлах:
transport_catalogue.h, transport_catalogue.cpp — класс транспортного справочника;
geo.h — функции для работы с географическими координатами;
input_reader.h, input_reader.cpp — чтение запросов на заполнение базы;
stat_reader.h, stat_reader.cpp — чтение запросов на вывод и сам вывод;
main.cpp — точка входа.
Класс транспортного справочника назовите TransportCatalogue. Он должен иметь методы для выполнения следующих задач:
добавление маршрута в базу,
добавление остановки в базу,
поиск маршрута по имени,
поиск остановки по имени,
получение информации о маршруте.
Методы классаTransportCatalogue не должны выполнять никакого ввода-вывода. В будущих версиях программы формат входных и выходных данных программы будет изменён. Отделение логики от ввода-вывода позволит легко изменить формат входных и выходных данных, не затрагивая логику приложения.
Эффективность
При разработке следует уделять внимание эффективности кода. Придерживайтесь ограничений, перечисленных ниже.
Сложность методов и функций должна быть оптимальной:
чтение запроса производится за время O(N), где N— количество символов в нём,
добавление остановки и маршрута производится со сложностью амортизированная O(K) в среднем, где K — длина названия,
нахождение остановки или маршрута по их названию в среднем — амортизированная O(K), где K — длина названия,
получение информации о маршруте производится со сложностью амортизированнаяO(1) в среднем.
Используйте, где возможно, перемещение строк и других больших объектов вместо копирования.
Не храните несколько копий одних и тех же данных. Например, информация об остановке не должна дублироваться в маршрутах, которые проходят через эту остановку. Придумайте, как в качестве ключей ассоциативных контейнеров вместо string использовать string_view, ссылающихся на название маршрута или остановки.
Как будет тестироваться ваша программа
Допустимые символы в названиях маршрутов и остановок — латинские буквы, цифры и пробелы. Названия не могут быть пустыми, начинаться на пробелы или заканчиваться ими.
Гарантируется, что тренажер будет подавать только корректные входные данные, которые соответствуют описанному формату.
Пример
Ввод
10
Stop Tolstopaltsevo: 55.611087, 37.208290
Stop Marushkino: 55.595884, 37.209755
Bus 256: Biryulyovo Zapadnoye > Biryusinka > Universam > Biryulyovo Tovarnaya > Biryulyovo Passazhirskaya > Biryulyovo Zapadnoye
Bus 750: Tolstopaltsevo - Marushkino - Rasskazovka
Stop Rasskazovka: 55.632761, 37.333324
Stop Biryulyovo Zapadnoye: 55.574371, 37.651700
Stop Biryusinka: 55.581065, 37.648390
Stop Universam: 55.587655, 37.645687
Stop Biryulyovo Tovarnaya: 55.592028, 37.653656
Stop Biryulyovo Passazhirskaya: 55.580999, 37.659164
3
Bus 256
Bus 750
Bus 751


Вывод
Bus 256: 6 stops on route, 5 unique stops, 4371.02 route length
Bus 750: 5 stops on route, 3 unique stops, 20939.5 route length
Bus 751: not found
Подсказки
В классе транспортного справочника понадобятся индексы для поиска автобусов и остановок по имени. Рекомендуется в качестве значений использовать константные указатели: const Bus* и const Stop*, где Bus и Stop — название структур для маршрута и остановки соответственно.
Предпочитайте unordered_set и unordered_map упорядоченным контейнерам, чтобы достичь требуемой вычислительной сложности операций вставки и поиска.
Сами остановки и автобусы удобно хранить в deque, чтобы ссылки и указатели на них не инвалидировались при добавлении.
Читайте cin построчно методом std::getline.
Обратите внимание, что в маршруте может фигурировать остановка, объявленная после этого маршрута. Рекомендуется сохранить запросы, и вначале обработать все запросы остановок, а затем, все запросы маршрутов.

Лучшие практики работы с ассоциативными контейнерами в C++17

Выбор типа контейнера

ХОРОШО:
- Используй map/set когда нужен отсортированный порядок элементов
- Используй unordered_map/unordered_set для максимальной производительности поиска
- Применяй multimap/multiset для ключей с дубликатами
- Выбирай flat_map/flat_set (из boost или std::experimental) для экономии памяти с небольшими контейнерами

ПЛОХО:
- Использовать map когда порядок не важен - теряешь производительность
- Применять unordered_map без хорошей хеш-функции
- Забывать про возможность дубликатов при выборе контейнера

Пример неэффективного выбора:
```cpp
// ПЛОХО: map для простого поиска без нужды в сортировке
map<string, int> wordCount;

// ХОРОШО: unordered_map для быстрого поиска
unordered_map<string, int> wordCount;
```

Работа с хеш-функциями

ХОРОШО:
- Комбинируй поля через умножение на простые числа (37, 41, 43...)
- Используй std::hash для стандартных типов
- Проверяй качество хеш-функции на реальных данных
- Применяй inline для небольших хешеров

ПЛОХО:
- Использовать слишком простые хеш-функции (только одно поле)
- Складывать хеши без весов
- Создавать медленные хеш-функции со строковыми операциями
- Игнорировать переполнение в хеш-функциях

Пример качественного хешера:
```cpp
// ХОРОШО: полный хешер для структуры
struct PersonHasher {
    size_t operator()(const Person& p) const {
        size_t h1 = std::hash<string>{}(p.name);
        size_t h2 = std::hash<int>{}(p.age);
        size_t h3 = std::hash<string>{}(p.email);
        return h1 ^ (h2 << 1) ^ (h3 << 2);
    }
};

// ПЛОХО: игнорирует большую часть данных
struct PersonHasherBad {
    size_t operator()(const Person& p) const {
        return std::hash<int>{}(p.age); // только возраст!
    }
};
```

Эффективность и семантика перемещения

ХОРОШО:
- Используй emplace для создания объектов на месте
- Применяй move-семантику при вставке больших объектов
- Резервируй место в unordered_контейнерах через reserve()
- Используй структурированные привязки (C++17) для итерирования

ПЛОХО:
- Копировать большие объекты при вставке
- Забывать про emplace_hint для оптимизации вставки
- Игнорировать возможности reserve()

```cpp
// ХОРОШО: эффективная вставка
unordered_map<string, vector<int>> data;
data.reserve(1000); // резервируем место
data.emplace("key", vector<int>{1, 2, 3}); // создаем на месте

// Эффективная итерация (C++17)
for (const auto& [key, value] : data) {
    // работаем с key и value
}

// ПЛОХО: лишние копирования
string key = "key";
vector<int> value = {1, 2, 3};
data[key] = value; // две копии!
```

Безопасность и корректность

ХОРОШО:
- Проверяй результаты find() на end()
- Используй at() для безопасного доступа к элементам
- Применяй const_iterator где возможно
- Помни о валидности итераторов после изменений

ПЛОХО:
- Использовать operator[] без проверки существования ключа
- Модифицировать ключи во время итерирования
- Полагаться на порядок в unordered_контейнерах

```cpp
// ХОРОШО: безопасный поиск
auto it = myMap.find(key);
if (it != myMap.end()) {
    cout << it->second;
}

// Или еще лучше (C++17)
if (auto it = myMap.find(key); it != myMap.end()) {
    cout << it->second;
}

// ПЛОХО: может создать элемент случайно
cout << myMap[key]; // создаст элемент если ключа нет!
```

Компараторы и пользовательские типы

ХОРОШО:
- Реализуй is_transparent для гетерогенного поиска
- Соблюдай строгое слабое упорядочивание для компараторов
- Используй tie() для лексикографического сравнения
- Определяй operator== вместе с хешером

ПЛОХО:
- Создавать несимметричные компараторы
- Забывать про транзитивность сравнения
- Игнорировать требования к operator== для unordered_контейнеров

```cpp
// ХОРОШО: прозрачный компаратор
struct StringComparator {
    using is_transparent = void;
    
    bool operator()(const string& a, const string& b) const {
        return a < b;
    }
    
    bool operator()(const string& a, string_view b) const {
        return a < b;
    }
    
    bool operator()(string_view a, const string& b) const {
        return a < b;
    }
};

// Позволяет искать по string_view в set<string>
set<string, StringComparator> strings;
strings.find("hello"sv); // эффективно, без создания string
```

Работа с памятью и производительность

ХОРОШО:
- Используй string_view как ключи когда возможно
- Применяй пулы объектов для часто создаваемых элементов
- Мониторь load_factor в unordered_контейнерах
- Используй node_handle (C++17) для перемещения элементов между контейнерами

ПЛОХО:
- Создавать временные строки для поиска
- Игнорировать фрагментацию памяти при частых вставках/удалениях
- Превышать оптимальный load_factor (обычно < 1.0)

```cpp
// ХОРОШО: перемещение узлов между контейнерами (C++17)
auto node = source.extract(key);
if (!node.empty()) {
    destination.insert(std::move(node));
}

// ХОРОШО: использование string_view для поиска
unordered_map<string, int> data;
string_view key = "some_key";
auto it = data.find(string(key)); // временный string только для поиска
```

Обработка ошибок

ХОРОШО:
- Проверяй успешность операций вставки
- Используй try_emplace (C++17) для условной вставки
- Обрабатывай исключения при работе с пользовательскими типами

ПЛОХО:
- Игнорировать возможность неуспешной вставки
- Полагаться на undefined behavior при обращении к несуществующим элементам

```cpp
// ХОРОШО: проверка успешности вставки
auto [iterator, inserted] = myMap.try_emplace(key, value);
if (inserted) {
    cout << "Element inserted successfully";
} else {
    cout << "Element already exists";
}

// ХОРОШО: безопасное обновление или вставка
myMap.insert_or_assign(key, newValue);
```
