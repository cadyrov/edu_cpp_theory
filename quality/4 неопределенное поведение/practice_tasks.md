# Практические задания по неопределенному поведению в C++

## Задание 1: Безопасный доступ к контейнерам

**Описание:**
Реализуйте класс `SafeVector`, который обеспечивает безопасный доступ к элементам vector без неопределенного поведения.

**Требования:**
- Метод `at(index)` должен выбрасывать исключение при выходе за границы
- Оператор `[]` должен возвращать значение по умолчанию при выходе за границы  
- Метод `safe_back()` должен работать с пустым вектором
- Метод `safe_front()` должен работать с пустым вектором

**Базовый код:**
```cpp
template<typename T>
class SafeVector {
private:
    std::vector<T> data;
    T default_value;
    
public:
    SafeVector(const T& def_val = T{}) : default_value(def_val) {}
    
    // TODO: Реализовать безопасные методы
};
```

**Тесты:**
1. Создание пустого SafeVector и вызов safe_back()
2. Доступ по индексу за пределами вектора через operator[]
3. Доступ по индексу за пределами вектора через at() (должно выбросить исключение)
4. Добавление элементов и проверка корректного доступа
5. Вызов safe_front() на пустом векторе
6. Проверка operator[] с отрицательным индексом
7. Проверка at() с большим положительным индексом
8. Проверка размера и вместимости
9. Тест с пользовательским типом данных
10. Тест с различными значениями по умолчанию

---

## Задание 2: Безопасная арифметика

**Описание:**
Создайте класс `SafeInt`, который предотвращает переполнение целых чисел и неопределенное поведение в арифметических операциях.

**Требования:**
- Операции должны проверять переполнение перед выполнением
- При переполнении выбрасывать исключение `std::overflow_error`
- Поддержать операции +, -, *, /, %
- Поддержать операции сравнения
- Запретить деление на ноль

**Базовый код:**
```cpp
class SafeInt {
private:
    int value;
    
    void check_overflow(long long result) {
        if (result > std::numeric_limits<int>::max() || 
            result < std::numeric_limits<int>::min()) {
            throw std::overflow_error("Integer overflow");
        }
    }
    
public:
    SafeInt(int val = 0) : value(val) {}
    
    // TODO: Реализовать безопасные операции
};
```

**Тесты:**
1. Сложение без переполнения
2. Сложение с переполнением (должно выбросить исключение)
3. Вычитание с переполнением
4. Умножение больших чисел
5. Деление на ноль (должно выбросить исключение)
6. Остаток от деления на ноль
7. Операции с INT_MAX
8. Операции с INT_MIN
9. Сравнение значений
10. Цепочка операций без переполнения

---

## Задание 3: RAII-обёртка для C-ресурсов

**Описание:**
Создайте RAII-класс для безопасной работы с FILE* из стандартной библиотеки C.

**Требования:**
- Автоматическое закрытие файла в деструкторе
- Проверка успешности открытия файла
- Запрет копирования, разрешение перемещения
- Безопасные методы для работы с файлом
- Обработка ошибок при работе с файлом

**Базовый код:**
```cpp
class FileRAII {
private:
    FILE* file;
    std::string filename;
    
public:
    explicit FileRAII(const std::string& name, const std::string& mode = "r") {
        // TODO: Реализовать конструктор
    }
    
    ~FileRAII() {
        // TODO: Реализовать деструктор
    }
    
    // TODO: Реализовать Rule of Five
    // TODO: Добавить методы для работы с файлом
};
```

**Тесты:**
1. Открытие существующего файла для чтения
2. Открытие несуществующего файла (должно выбросить исключение)
3. Создание нового файла для записи
4. Проверка запрета копирования
5. Проверка корректности перемещения
6. Чтение данных из файла
7. Запись данных в файл
8. Проверка автоматического закрытия файла
9. Работа с двумя файлами одновременно
10. Обработка ошибок при записи на заполненный диск

---

## Задание 4: Потокобезопасный счётчик

**Описание:**
Реализуйте потокобезопасный счётчик, который предотвращает гонки данных и неопределенное поведение в многопоточной среде.

**Требования:**
- Атомарные операции инкремента и декремента
- Безопасное получение текущего значения
- Операции должны быть lock-free где возможно
- Поддержка пользовательских шагов изменения
- Защита от переполнения

**Базовый код:**
```cpp
class ThreadSafeCounter {
private:
    std::atomic<int> value;
    std::atomic<int> max_value;
    
public:
    ThreadSafeCounter(int initial = 0, int max_val = std::numeric_limits<int>::max()) 
        : value(initial), max_value(max_val) {}
    
    // TODO: Реализовать потокобезопасные методы
};
```

**Тесты:**
1. Инкремент из одного потока
2. Параллельный инкремент из нескольких потоков
3. Смешанные операции инкремента и декремента
4. Проверка защиты от переполнения
5. Получение значения во время изменений
6. Большое количество потоков (стресс-тест)
7. Пользовательские шаги изменения
8. Операции с отрицательными значениями
9. Сброс счётчика до нуля
10. Проверка производительности lock-free операций

---

## Задание 5: Умный указатель с подсчётом ссылок

**Описание:**
Создайте упрощённую версию `shared_ptr`, которая безопасно управляет временем жизни объектов и предотвращает утечки памяти.

**Требования:**
- Подсчёт ссылок для управления памятью
- Потокобезопасный подсчёт ссылок
- Правильная семантика копирования и перемещения
- Поддержка пользовательских deleter'ов
- Защита от циклических ссылок (хотя бы базовая)

**Базовый код:**
```cpp
template<typename T>
class shared_ptr {
private:
    T* ptr;
    std::atomic<size_t>* ref_count;
    
public:
    explicit shared_ptr(T* p = nullptr) {
        // TODO: Реализовать конструктор
    }
    
    // TODO: Реализовать копирование, перемещение, деструктор
    // TODO: Реализовать операторы * и ->
    // TODO: Реализовать reset, get, use_count
};
```

**Тесты:**
1. Создание умного указателя с объектом
2. Копирование указателей и проверка счётчика ссылок
3. Автоматическое удаление при обнулении всех ссылок
4. Перемещение указателей
5. Работа с массивами объектов
6. Пользовательский deleter
7. Многопоточный доступ к одному объекту
8. Проверка на nullptr
9. Сброс указателя с помощью reset()
10. Проверка отсутствия утечек памяти

---

## Задание 6: Безопасная работа с итераторами

**Описание:**
Создайте класс `SafeContainer`, который предотвращает неопределенное поведение при работе с итераторами во время модификации контейнера.

**Требования:**
- Контейнер должен отслеживать активные итераторы
- При модификации контейнера итераторы должны инвалидироваться безопасно
- Использование инвалидированного итератора должно выбрасывать исключение
- Поддержка range-based for без UB
- Безопасное удаление элементов во время итерации

**Базовый код:**
```cpp
template<typename T>
class SafeContainer {
private:
    std::vector<T> data;
    mutable std::set<void*> active_iterators;
    mutable std::mutex iterator_mutex;
    
    void invalidate_iterators() {
        // TODO: Реализовать инвалидацию итераторов
    }
    
public:
    class iterator {
        // TODO: Реализовать безопасный итератор
    };
    
    // TODO: Реализовать методы контейнера
};
```

**Тесты:**
1. Обычная итерация без модификации
2. Модификация контейнера во время итерации
3. Использование инвалидированного итератора
4. Множественные итераторы на одном контейнере
5. Range-based for с модификацией
6. Удаление элементов через итератор
7. Вставка элементов во время итерации
8. Проверка производительности
9. Многопоточная работа с итераторами
10. Проверка корректности инвалидации

---

## Задание 7: Обнаружение переполнения буфера

**Описание:**
Создайте класс `GuardedBuffer`, который обнаруживает и предотвращает переполнение буфера (buffer overflow).

**Требования:**
- Добавление защитных значений (canary) до и после буфера
- Проверка целостности при каждом доступе
- Защита от записи за пределы буфера
- Детектирование попыток переполнения
- Логирование подозрительных операций

**Базовый код:**
```cpp
class GuardedBuffer {
private:
    static const uint32_t CANARY_VALUE = 0xDEADBEEF;
    uint32_t front_canary;
    std::vector<char> buffer;
    uint32_t back_canary;
    
    void check_integrity() const {
        // TODO: Проверить canary значения
    }
    
public:
    GuardedBuffer(size_t size) : front_canary(CANARY_VALUE), 
                                 buffer(size), 
                                 back_canary(CANARY_VALUE) {}
    
    // TODO: Реализовать безопасные методы доступа
};
```

**Тесты:**
1. Нормальная запись в пределах буфера
2. Попытка записи за пределы буфера
3. Чтение из буфера после записи
4. Проверка обнаружения повреждения canary
5. Копирование данных в буфер
6. Работа с бинарными данными
7. Проверка границ при частичной записи
8. Множественные операции записи
9. Проверка после освобождения памяти
10. Стресс-тест с случайными данными

---

## Задание 8: Безопасная строковая обработка

**Описание:**
Создайте класс `SecureString`, который предотвращает переполнение буфера и другие проблемы безопасности при работе со строками.

**Требования:**
- Защита от переполнения при конкатенации
- Безопасное форматирование строк
- Предотвращение использования после освобождения
- Очистка чувствительных данных при уничтожении
- Защита от инъекций в строковых операциях

**Базовый код:**
```cpp
class SecureString {
private:
    std::unique_ptr<char[]> data;
    size_t length;
    size_t capacity;
    bool is_sensitive;
    
    void secure_clear() {
        // TODO: Безопасная очистка памяти
    }
    
public:
    SecureString(size_t initial_capacity = 64, bool sensitive = false) {
        // TODO: Реализовать конструктор
    }
    
    ~SecureString() {
        // TODO: Безопасное уничтожение
    }
    
    // TODO: Реализовать безопасные строковые операции
};
```

**Тесты:**
1. Создание и инициализация строки
2. Безопасная конкатенация без переполнения
3. Попытка переполнения при конкатенации
4. Форматирование строки с проверкой размера
5. Работа с чувствительными данными
6. Проверка очистки памяти после уничтожения
7. Копирование и перемещение строк
8. Поиск подстроки без выхода за границы
9. Замена подстроки с проверкой размера
10. Валидация входных данных на инъекции

---

## Задание 9: Детектор утечек памяти

**Описание:**
Создайте простой детектор утечек памяти, который отслеживает выделение и освобождение памяти в программе.

**Требования:**
- Перехват вызовов new/delete
- Ведение реестра выделенных блоков
- Отчёт об утечках при завершении программы
- Информация о месте выделения памяти
- Защита от двойного освобождения

**Базовый код:**
```cpp
class MemoryTracker {
private:
    struct AllocationInfo {
        size_t size;
        const char* file;
        int line;
        std::chrono::time_point<std::chrono::steady_clock> timestamp;
    };
    
    static std::unordered_map<void*, AllocationInfo> allocations;
    static std::mutex tracker_mutex;
    static bool tracking_enabled;
    
public:
    static void* track_allocation(size_t size, const char* file, int line);
    static void track_deallocation(void* ptr);
    static void print_leaks();
    // TODO: Реализовать методы отслеживания
};

// TODO: Макросы для замены new/delete
```

**Тесты:**
1. Выделение и корректное освобождение памяти
2. Обнаружение простой утечки памяти
3. Обнаружение двойного освобождения
4. Работа с массивами объектов
5. Множественные аллокации и деаллокации
6. Информация о месте утечки
7. Статистика использования памяти
8. Работа в многопоточной среде
9. Большое количество мелких аллокаций
10. Интеграция с умными указателями

---

## Задание 10: Комплексная система безопасности

**Описание:**
Создайте комплексную систему, объединяющую несколько механизмов предотвращения неопределенного поведения.

**Требования:**
- Безопасный контейнер с проверкой границ
- Умное управление памятью
- Потокобезопасность
- Обнаружение и логирование подозрительных операций
- Интеграция с инструментами анализа

**Базовый код:**
```cpp
template<typename T>
class SecureContainer {
private:
    // Компоненты системы безопасности
    class BoundsChecker;
    class MemoryManager;
    class ThreadSafety;
    class SecurityLogger;
    
    std::unique_ptr<BoundsChecker> bounds_checker;
    std::unique_ptr<MemoryManager> memory_manager;
    std::unique_ptr<ThreadSafety> thread_safety;
    std::unique_ptr<SecurityLogger> logger;
    
public:
    SecureContainer() {
        // TODO: Инициализация компонентов безопасности
    }
    
    // TODO: Реализовать безопасный интерфейс контейнера
    // TODO: Интегрировать все механизмы защиты
};
```

**Тесты:**
1. Базовые операции с контейнером
2. Проверка защиты от выхода за границы
3. Многопоточный доступ к контейнеру
4. Обнаружение попыток несанкционированного доступа
5. Логирование подозрительных операций
6. Интеграция с внешними системами мониторинга
7. Производительность с включенной защитой
8. Стресс-тест безопасности
9. Восстановление после обнаружения атаки
10. Комплексный тест всех механизмов защиты

Каждое задание должно быть реализовано с полным покрытием тестами и документацией по использованию. 