Знакомство с неопределенным поведением
Из предыдущих уроков вы знаете, что некоторые операции в C++ приводят к неопределенному поведению, или undefined behavior. Причём это вызвано не ошибками компилятора или стандартной библиотеки. Такое поведение описано в стандарте языка. При этом с программой может происходить что угодно: от корректной работы до аварийного завершения или зависания.
Возникает вопрос, зачем в языке программирования такая странная конструкция, усложняющая жизнь разработчикам. Ответ прост: производительность. Неопределённое поведение позволяет улучшить производительность программы, причём двумя способами.
Во-первых, неопределённое поведение разрешает убирать из программы некоторые накладные расходы. Во-вторых, разрешает выполнять оптимизации кода, которые в противном случае были бы невозможны.
В этом уроке вы узнаете, как неопределённое поведение позволяет избегать накладных расходов.
В качестве примера рассмотрим два способа доступа к элементу контейнера std::vector по его индексу:
оператор [],
метод at.
Метод at проверяет, не выходит ли индекс элемента за границы массива, и выбрасывает исключение out_of_range при попытке обратиться к несуществующему элементу:
#include <iostream>
#include <string_view>
#include <vector>

using namespace std;

int main() {
    vector v{1, 2, 3, 4};
    try {
        cout << v.at(10) << endl;
    } catch (const exception& e) {
        cout << "Exception: "sv << e.what() << endl;
    }
}
Запустим программу и увидим сообщение о пойманном исключении:
Exception: vector::_M_range_check: __n (which is 10) >= this->size() (which is 4)
Текст сообщения может быть другим в вашей версии компилятора. Но при обращении за границы контейнера точно выбросится исключение.
В отличие от метода at(), оператор [] контейнера vector не проверяет выход индекса за границы массива, а напрямую обращается к ячейке памяти по адресу start+index, где start — адрес массива в динамической памяти, а index — индекс элемента.
Если индекс находится внутри массива, всё в порядке:
Но если индекс выходит за пределы массива, то в памяти по адресу start+index может быть всё что угодно. Например, по этому адресу может располагаться область памяти, недоступная нашей программе.
Когда выполняется не чтение, а запись за пределы массива, программа может испортить содержимое другого объекта, которому посчастливилось оказаться в той области памяти. Стандарт C++ в подобных случаях вводит понятие неопределённого поведения. Если программа нарушает правила языка, на её поведение не накладывается никаких ограничений.
В описании vector::operator[] говорится о неопределенном поведении при выходе индекса за пределы массива. Это позволило авторам стандартной библиотеки избавиться от накладных расходов на проверки и реализовать максимально быстрый доступ к элементу динамического массива.
Чтобы убедиться в этом, используйте онлайн-сервис Compiler Explorer. Там вы увидите, какой ассемблерный код сгенерируется из заданного кода на C++.
Рассмотрим две функции, которые принимают по ссылке vector и возвращают некоторый элемент этого массива. Только одна использует оператор [], а другая — метод at:
#include <vector>

int TestVectorIndexingOperator(std::vector<int>& v) {
    return v[3];
}

int TestVectorAt(std::vector<int>& v) {
    return v.at(3);
}
Сгенерированный код для ассемблера x86-64 функции, которая использует оператор []:
TestVectorIndexingOperator(std::vector<int, std::allocator<int> >&):
        // В регистре %rdi — первый аргумент функции — адрес, по которому располагается vector<int>
        movq    (%rdi), %rax    // Загружаем в регистр rax адрес массива элементов контейнера vector
        movl    12(%rax), %eax  // Загружаем в регистр eax значение элемента с индексом 3 (12/sizeof(int))
        ret                     // Выходим из функции. В регистре eax значение элемента массива
Код второй функции:
.LC0:
        .string "vector::_M_range_check: __n (which is %zu) >= this->size() (which is %zu)"
TestVectorAt(std::vector<int, std::allocator<int> >&):
        // В регистре rdi — первый аргумент функции — адрес, по которому располагается vector<int>
        // Загружаем в регистр rdx адрес первого элемента массива
        movq    (%rdi), %rdx
        // Загружаем в регистр rax адрес конца массива (указатель end)
        movq    8(%rdi), %rax
        // Проверяем, что массив содержит более трёх элементов
        subq    %rdx, %rax
        cmpq    $12, %rax
        jbe     .L8            // Если нет, переходим на метку .L8 
        movl    12(%rdx), %eax // Загружаем в регистр eax значение элемента с индексом 3
        ret                    // Выходим из функции. Результат возвращается в регистре eax
.L8:
        // Выбрасываем исключение out_of_range
        pushq   %rdx
        sarq    $2, %rax
        movl    $3, %esi
        movl    $.LC0, %edi
        movq    %rax, %rdx
        xorl    %eax, %eax
        call    std::__throw_out_of_range_fmt(char const*, ...)
Даже если вы не знакомы с языком ассемблера, увидите, что второй вариант функции занимает значительно больше кода и, скорее всего, будет медленнее.
Индекс массива вышел за границы контейнера, и случилось неопределённое поведение оператора []. Это позволило избавиться от накладных расходов на проверку индекса и максимально быстро обращаться к элементам массива.
Вы можете поэкспериментировать с генерируемым кодом на сайте Compiler Explorer: https://godbolt.org/z/r541Kx.
За скорость доступа надо платить. Задача программиста — гарантировать, что при работе с оператором [] будут использованы только допустимые значения индексов.
Посмотрим на другие примеры, когда неопределённое поведение избавляет программу от накладных расходов.
Повторный вызов оператора delete с одним и тем же значением указателя. Без неопределённого поведения понадобилось бы проверить валидность удаляемого указателя. А это дорого:
int main() {
    int *p = new int(42);
    delete p;
    delete p; // Неопределённое поведение: повторное удаление ранее удалённого объекта
}
Вызов непарной версии оператора delete: удаление массива как одиночного объекта и наоборот. Неопределённое поведение позволяет уменьшить объем служебной информации, которая нужна для хранения объектов и массивов в куче:
int main() {
    int *p = new int(42);
    delete[] p; // Неопределённое поведение: одиночный объект удаляется как массив
}
При работе программы в многопоточном режиме часто случаются ситуации неопределенного поведения. Один из примеров — состояние гонки. Так называется ситуация, когда два разных потока не синхронизовавшись должным образом выполняют действия с одной и той же ячейкой памяти: чтения или записи. Гонка возникает, когда хотя бы одно из этих действий — запись. Рассмотрим пример:
#include <future>
#include <iostream>
#include <string_view>

using namespace std;

int main() {
    int i = 0;
    auto f = async([&i] {
        // Неопределённое поведение: чтение и запись переменной
        // производится в разных потоках без синхронизации
        ++i;
    });

    // Неопределённое поведение: чтение и запись переменной
    // производится в разных потоках без синхронизации
    ++i; 
    f.get();
    cout << "i: "sv << i << endl;
}
Вместо этого программист сам должен синхронизировать доступ в нужных местах. Например, используя mutex:
#include <future>
#include <iostream>
#include <mutex>
#include <string_view>

using namespace std;

int main() {
    int i = 0;
    mutex m;
    auto f = async([&i, &m] {
        lock_guard lk{m};
        ++i;
    });

    {
        lock_guard lk{m};
        ++i; 
    }
    f.get();
    cout << "i: "sv << i << endl;
}
Выполнение оптимизаций
В предыдущем уроке вы узнали, как неопределённое поведение позволяет убирать накладные расходы, и убедились, что без него это было бы невозможно. Теперь вы увидите, как неопределённое поведение помогает компилятору делать некоторые оптимизации.
Рассмотрим операцию сложения двух целых чисел. В C++ при операциях над типами int и int32_t переполнение приводит к неопределенному поведению. То есть если результат выйдет за пределы диапазона [INT_MIN, INT_MAX], поведение программы станет неопределённым.
При сложении целых чисел без знака, например, unsigned int или uint32_t, переполнение строго определено: результат сложения берется по модулю 2
N
, где N — количество битов в данном типе. То есть если прибавить к значению UINT_MAX единицу, гарантируется, что результат будет равен нулю. Такое поведение напоминает циферблат электронных часов, у которых следом за 23:59:59 наступает 00:00:00.
Теперь вспомним, что при возникновении неопределённого поведения программа способна делать всё что угодно. Компилятор может использовать свободу, чтобы сгенерировать оптимальный код.
Компилятор предполагает, что программист написал код без неопределённого поведения. Примерно как при использовании оператора [] для доступа к элементу vector: компилятор верит, что индекс элемента имеет допустимое значение.
Какое поведение этой программы будет допустимым? Выберите несколько вариантов ответа.
#include <climits>
#include <iomanip>
#include <iostream>

bool TestSigned(int n) {
    return n < n + 1;
}

bool TestUnsigned(unsigned int n) {
    return n < n + 1;
}

using namespace std;
int main() {
    cout << boolalpha;
    cout << TestSigned(INT_MAX) << endl;
    cout << TestUnsigned(UINT_MAX) << endl;
}
В программе есть неопределённое поведение при вычислении INT_MAX + 1 внутри функции TestSigned. Поэтому ожидать можно всего что угодно

В зависимости от вашего компилятора и опций компиляции результаты работы программы могут отличаться. Программа, собранная компилятором Microsoft Visual C++ 2019, выводит:
false
false
Та же программа, собранная компилятором gcc 10.1:
true
false
Эти различия объяснимы — при переполнении целого числа со знаком неопределённое поведение разрешает программе вести себя как угодно.
Взглянем на ассемблерный код функций TestSigned и TestUnsigned, сгенерированный компилятором gcc. Для этого используем Compiler Explorer:
TestSigned(int):
        movl    $1, %eax // Записываем в регистр eax результат, равный 1 (значение true)
        ret

TestUnsigned(unsigned int):
        // проверяем, равен ли аргумент функции, переданный в регистре edi,
        // значению UINT_MAX (в двоичном представлении совпадает со значением -1)
        cmpl    $-1, %edi
        // Если да, записываем единицы во все разряды регистра al, иначе нули
        setne   %al
        // выходим из функции
        ret
Разберёмся, почему компилятор сгенерировал такой разный код для функций с одинаковым телом:
return n < n + 1; 
Когда n имеет тип int, компилятор может размышлять так:
Если значение n меньше максимально возможного целого числа, сумма n+1 будет помещаться в диапазон типа int. В таком случае n всегда будет меньше, чем n+1. Поэтому функция должна вернуть true.
Если значение n равно максимально возможному целому числу, сумма n+1 приведёт к переполнению знакового целого, а это неопределённое поведение. В таком случае программа может сделать всё что угодно. Например, отформатировать диск. Или вернуть true.
В результате компилятор gcc создаёт функцию, которая при любых входных значениях возвращает значение true.
К такому же результату компилятор может прийти, рассчитывая, что программист пишет код без определенного поведения. Ведь в такой программе ситуация, где параметр n равен максимально возможному целому числу, невозможна. Остаётся только вариант, когда функция всегда возвращает true.
В случае беззнакового числа n компилятор также рассматривает две ситуации:
Когда n меньше наибольшего беззнакового целого числа, сумма n+1 будет не больше максимального беззнакового числа. Тогда выражение n < n + 1 будет равно true.
Когда n равно наибольшему беззнаковому числу, сумма n+1 будет определённой и равна нулю. В таком случае выражение n < n + 1 будет иметь значение false.
Поэтому функция TestUnsigned получилась  большего размера и, как показывают замеры времени, чуть дольше работает. Чтобы убедиться, используйте онлайн-сервис Quick Bench. Он позволяет измерить относительное время работы кода на C++. Ссылка на сравнение времени выполнения функций TestSigned и TestUnsigned: https://quick-bench.com/q/FhuBkdyrQw4QH2y0H1O9DzDb_EI.
Другие компиляторы могут придерживаться иных стратегий оптимизаций. Например, Visual C++ 2019 генерирует примерно одинаковый код для обеих функций:
n$ = 8
bool TestSigned(int) PROC                         ; TestSigned, COMDAT
        lea     eax, DWORD PTR [rcx+1] // помещаем в eax значение n+1
        cmp     ecx, eax // сравниваем n и n+1
        setl    al // если n<n+1, в регистре AL будет значение 255
        ret     0
bool TestSigned(int) ENDP                         ; TestSigned

n$ = 8
bool TestUnsigned(unsigned int) PROC                   ; TestUnsigned, COMDAT
        lea     eax, DWORD PTR [rcx+1] // Помещаем в eax значение n+1
        cmp     ecx, eax // Сравниваем n и n+1
        setb    al  // если n<n+1, в регистре AL будет значение 255
        ret     0
bool TestUnsigned(unsigned int) ENDP                   ; TestUnsigned
Код, сгенерированный Visual C++, сложил INT_MAX (значение 0x7FFFFFFF) c единицей и  получил число 0x80000000, равное значению INT_MIN. В таком случае выражение  n<n+1 принимает значение false.
Теперь разница в работе функции TestSigned, скомпилированной разными компиляторами, становится объяснимой. При параметре n, равном INT_MAX, проявляется неопределённое поведение, и программа ведёт себя произвольно. Компилятор g++ максимально эксплуатирует неопределённое поведение, генерируя код, который всегда возвращает true.
При этом оба компилятора ведут себя вполне законно. Область определения функции TestSigned, то есть значения аргумента, где значение функции определено, — полуинтервал [INT_MIN, INT_MAX). Значение INT_MAX находится вне области определения, и на нём функция имеет право вести себя как угодно.
Даже если программа собирается компилятором одного производителя, неопределённого поведения следует избегать. Ведь когда обновите компилятор или измените параметры компиляции, неопределённое поведение может проявить себя самым неожиданным образом.
В этом уроке вы узнали, как неопределённое поведение помогает компилятору генерировать оптимальный код. Но задача программиста — не допускать неопределённого поведения.
Неожиданные последствия неопределённого поведения
В предыдущем уроке вы познакомились с положительными аспектами неопределённого поведения и с тем, как оно помогает компилятору генерировать оптимальный код. В этом уроке вы узнаете, как неопределённое поведение осложняет жизнь программистам.
Рассмотрим программу, которая определяет, считается ли небесное тело планетой:
#include <iostream>
#include <string_view>

using namespace std;

const int NUM_PLANETS = 9;
const string_view PLANETS[] = {
    "Mercury"sv, "Venus"sv, "Earth"sv,
    "Mars"sv, "Jupiter"sv, "Saturn"sv,
    "Uranus"sv, "Neptune"sv, "Pluto"sv,
};

bool IsPlanet(string_view name) {
    for (int i = 0; i < NUM_PLANETS; ++i) {
        if (PLANETS[i] == name) {
            return true;
        }
    }
    return false;
}

void Test(string_view name) {
    cout << name << " is " << (IsPlanet(name) ? ""sv : "NOT "sv) << "a planet"sv << endl;
}

int main() {
    Test("Earth"sv);
    Test("Jupiter"sv);
    Test("Pluto"sv);
    Test("Moon"sv);
}
Запустим программу и увидим, что Земля, Юпитер и Плутон — планеты, а Луна — нет:
Earth is a planet
Jupiter is a planet
Pluto is a planet
Moon is NOT a planet
Показав программу своим друзьям, узнаём, что Плутон с 2006 исключён из списка планет и теперь считается карликовой планетой. Недолго думая, исправим ошибку:
const string_view PLANETS[] = {
    "Mercury"sv, "Venus"sv, "Earth"sv,
    "Mars"sv, "Jupiter"sv, "Saturn"sv,
    "Uranus"sv, "Neptune"sv,
};
Запустим программу и убедимся, что программа по-прежнему работает:
Earth is a planet
Jupiter is a planet
Pluto is NOT a planet
Moon is NOT a planet
Довольные собой, опубликуем код программы на GitHub, чтобы поделиться ей с сообществом. Вскоре один из пользователей сообщает, что программа работает неверно. Более того, она считает планетой не только Плутон, но и Луну:
Earth is a planet
Jupiter is a planet
Pluto is a planet
Moon is a planet
Несколько раз проверяем на своём компьютере — программа работает как часы. Тратим много времени на переписку с пользователем и выясняем, что проблема проявляется при сборке компилятором gcc 10.1 с ключом оптимизации -O2 и не проявляется при сборке компиляторами Visual Studio 2019 и Clang 10.0.
Проблема в том, что в программе появилось неопределенное поведение. Взглянем ещё раз на код, где внесены изменения:
const int NUM_PLANETS = 9;
const string_view PLANETS[] = {
    "Mercury"sv, "Venus"sv, "Earth"sv,
    "Mars"sv, "Jupiter"sv, "Saturn"sv,
    "Uranus"sv, "Neptune"sv,
};

bool IsPlanet(string_view name) {
    for (int i = 0; i < NUM_PLANETS; ++i) {
        if (PLANETS[i] == name) {
            return true;
        }
    }
    return false;
}
Из массива планет убран Плутон, однако константа NUM_PLANETS по-прежнему равна девяти.
Компилятор gcc анализирует поток выполнения программы и видит, что переменная i принимает значения от 0 до 8 включительно. Эта же переменная использована, чтобы обратиться к элементам массива PLANETS. В нём 8 элементов.
Компилятор видит, что функция IsPlanet возвращает true при значениях i, находящихся в диапазоне от 0 до 7. Когда значение i равно 8, возникает неопределенное поведение. В итоге функция IsPlanet либо возвращает true, либо в ней происходит неопределённое поведение.
При оптимизации компилятор может исключить второй вариант развития событий и генерирует код, всегда возвращающий true. Проверьте на сервисе Compiler Explorer по ссылке: https://godbolt.org/z/5qxTbe
IsPlanet(std::basic_string_view<char, std::char_traits<char> >):
        movl    $1, %eax // В регистре eax — результат функции 1, соответствующий значению true
        ret
Компилятор в ходе оптимизации функции исключил цикл поиска названия планеты и оставил возврат значения true.
Можно было бы ожидать, что программа, дойдя до элемента с индексом 8, попытается обратиться к элементу за пределами массива. Мусор в этой области памяти программа интерпретирует как объект string_view. Сравнив его с параметром name, программа, вероятно, вернет false. Если судить по коду, сгенерированному компилятором clang, так и происходит. Создаётся иллюзия, что программа работает правильно.
Действительно, за неопределённым поведением может скрываться всё что угодно. Даже такие, казалось бы, неочевидные вещи, как выкидывание всего кода функции.
Идиоматический C++ и неопределённое поведение
В прошлом уроке вы увидели, как неопределённое поведение в программе может привести к очень неожиданным результатам. Отчасти проблема была вызвана тем, что код определения планеты вряд ли можно считать хорошим примером современного C++.
bool IsPlanet(string_view name) {
    for (int i = 0; i < NUM_PLANETS; ++i) {
        if (PLANETS[i] == name) {
            return true;
        }
    }
    return false;
}
Здесь массив PLANETS и константа NUM_PLANETS — разные объекты. Такой стиль написания кода, скорее, характерен для C, а не C++. В C++ эту задачу можно решить проще.
Во-первых, вы можете использовать функцию std::size для определения размера массива и отказаться от константы NUM_PLANETS:
bool IsPlanet(string_view name) {
    for (size_t i = 0; i < std::size(PLANETS); ++i) {
        if (PLANETS[i] == name) {
            return true;
        }
    }
    return false;
}
Во-вторых, для поиска планеты не важен индекс элемента в массиве, поэтому цикл получится упростить, используя range-based for:
bool IsPlanet(string_view name) {
    for (auto planet_name : PLANETS) {
        if (planet_name == name) {
            return true;
        }
    }
    return false;
}
В этом цикле шанс ошибиться с индексами уже исключён. Можно пойти дальше и избавиться от написания цикла вручную, заменив его на подходящий здесь алгоритм std::find:
#include <algorithm>
...
bool IsPlanet(string_view name) {
    return find(begin(PLANETS), end(PLANETS), name) != end(PLANETS);
}
Если ваш компилятор поддерживает C++20, примените алгоритм std::ranges::find — это сделает код ещё компактнее:
#include <algorithm>
...
using namespace std;
bool IsPlanet(string_view name) {
    return ranges::find(PLANETS, name) != end(PLANETS);
}
Идиоматический код на C++ стал более лаконичным, легче читается и меньше подвержен случайным ошибкам, которые приводят к неопределенному поведению.
Рассмотрим еще один пример, когда неопределённое поведение интересно себя проявляет: программа, управляющая домашней сигнализацией. Уровень реакции сигнализации на внешний раздражитель можно настраивать, используя указатель alarm. Он имеет тип void (*)(), что означает «указатель на функцию без параметров, возвращает void». Указатель alarm объявлен в безымянном пространстве имён, чтобы ограничить его область видимости текущим файлом:
#include <iostream>

using namespace std;

// Указатель на функцию без параметров, которая возвращает void
using Alarm = void (*)();

namespace {
// Поведение сигнализации определяется значением указателя alarm
Alarm alarm = nullptr;
}  // namespace
Для установки агрессивного уровня реагирования служит функция SetHostileAlarm. Она присваивает указателю alarm адрес функции, выпускающей велоцираптора:
// Выпустить велоцираптора
void HostileAlarm() {
    cout << "Attack with velociraptor"sv << endl;
}

// Настраиваем сигнализацию на выпуск велоцираптора
void SetHostileAlarm() {
    cout << "Hostile alarm set" << endl;
    alarm = HostileAlarm;
}
Остается протестировать работу программы, вызвав функцию Test. Она, в свою очередь, вызовет функцию, на которую ссылается указатель alarm:
void Test() {
    // Вызываем функцию, на которую ссылается указатель alarm
    alarm();
    cout << "Test succeeded"sv << endl;
}

int main() {
    Test();
}

Указатель alarm при запуске программы инициализируется значением nullptr, но функция SetHostileAlarm, настраивающая этот указатель, в программе не вызывается. Поэтому вызов функции с использованием нулевого указателя alarm приводит к неопределенному поведению. И это в прямом смысле может привести к нападению велоцираптора в программе, собранной компилятором Clang 10.0 с флагом компиляции -O2, который включает оптимизации скорости выполнения:
Attack with velociraptor
Test succeeded
Функция HostileAlarm была вызвана без предварительного вызова SetHostileAlarm, о чём свидетельствует отсутствие сообщения “Hostile alarm set”. Ссылка на онлайн-компилятор wandbox.org, где вы можете в этом убедиться: https://wandbox.org/permlink/xb70ZYQxyqtHbN5V.
Такое поведение кажется странным. Но попробуем найти ему рациональное объяснение. Функция main вызывает функцию Test, в которой по указателю alarm вызывается текущий обработчик сигнализации. Так как указатель не проверяется на nullptr перед вызовом, компилятор считает, что он ненулевой. Ведь иначе это привело бы к неопределённому поведению. А неопределённое поведение компилятор вправе исключить из рассмотрения.
Далее компилятор оптимизирует код, пытаясь заменить вызов обработчика по указателю на прямой вызов функции. Он видит, что единственное место в программе, где этому указателю присваивается ненулевое значение — функция SetHostileAlarm, и это значение — адрес функции HostileAlarm. Здесь компилятору помогает то, что указатель alarm объявлен в безымянном пространстве имён — присвоить ему значение может только код в текущей единице трансляции.
Так как указатель alarm может ссылаться только на функцию HostileAlarm, компилятор генерирует код, который вызывает данную функцию, не используя указатель alarm. При этом не имеет значения, что свои выводы компилятор сделал на основе функции SetHostileAlarm, которая не вызывается вообще. Неопределённое поведение это позволяет. В других компиляторах неопределённое поведение может проявлять себя иначе. Единственно правильное решение в этой ситуации — устранить его причины.
Во-первых, следует проверить значение указателя alarm на равенство nullptr перед вызовом функции:
void Test() {
    if (alarm != nullptr) {
        alarm();
    }
    cout << "Test succeeded"sv << endl;
}
Во-вторых, вы можете объявить тип Alarm с использованием std::function. std::function выбрасывает исключение std::bad_function_call, если функция не была инициализирована. Кроме того, std::function позволяет хранить любой объект, который можно вызвать, включая лямбда-функции и методы классов:
#include <functional>
using namespace std;
using Alarm = function<void()>;
...
void Test() {
    alarm();
    cout << "Test succeeded"sv << endl;
}
Неопределённое поведение может поджидать и когда пишете исключительно идиоматичный код на C++. Рассмотрим программу, которая создаёт сетку из точек. Она начнёт с одной точки, затем создаст её дубликат со смещением по горизонтали. Продублирует эту пару точек, чтобы получить четыре, а потом проделает то же самое с четырьмя.

#include <iostream>
#include <vector>

using namespace std;

struct Point {
    int x, y;
    Point(int x, int y)
        : x(x)
        , y(y) {
    }
};

void DuplicateAlongX(vector<Point>& v, int offset) {
    for (const auto& p : v) {
        v.emplace_back(p.x + offset, p.y);
    }
}

int main() {
    vector points = {Point(0, 0)};

    DuplicateAlongX(points, 1);
    DuplicateAlongX(points, 2);
    DuplicateAlongX(points, 4);

    for (const auto& p : points) {
        cout << '{' << p.x << ", "sv << p.y << "} "sv;
    }
}
Запустим программу и увидим набор из восьми точек:
{0, 0} {1, 0} {2, 0} {3, 0} {4, 0} {5, 0} {6, 0} {7, 0}
Теперь проделаем то же самое с рядами точек, продублировав их со смещением по вертикали:

Добавим функцию DuplicateAlongY, дублирующую точки со смещением вдоль оси Y:
void DuplicateAlongY(vector<Point>& v, int offset) {
    for (const auto& p : v) {
        v.emplace_back(p.x, p.y + offset);
    }
}

int main() {
    vector points = {Point(0, 0)};

    DuplicateAlongX(points, 1);
    DuplicateAlongX(points, 2);
    DuplicateAlongX(points, 4);

    // Дублируем точки по оси Y
    DuplicateAlongY(points, 1);
    DuplicateAlongY(points, 2);
    DuplicateAlongY(points, 4);

    int n = 0;
    for (const auto& p : points) {
        cout << '{' << p.x << ", "sv << p.y << "} "sv;
        ++n;
        if (n == 8) {
            cout << endl;
            n = 0;
        }
    }
}
Запустим программу, ожидая увидеть стройную сетку 8*8, однако результат будет совсем не тот:
{0, 0} {1, 0} {2, 0} {3, 0} {4, 0} {5, 0} {6, 0} {7, 0} 
{0, 1} {1, 1} {2, 1} {3, 1} {4, 1} {5, 1} {6, 1} {7, 1} 
{0, 2} {1411111800, 32649} {2, 2} {3, 2} {4, 2} {5, 2} {6, 2} {7, 2} 
{0, 3} {1, 3} {2, 3} {3, 3} {4, 3} {5, 3} {6, 3} {7, 3} 
{0, 4} {1, 4} {2, 4} {3, 4} {4, 4} {5, 4} {6, 4} {7, 4} 
{0, 5} {1, 5} {2, 5} {3, 5} {4, 5} {5, 5} {6, 5} {7, 5} 
{0, 6} {1411111800, 32653} {2, 6} {3, 6} {4, 6} {5, 6} {6, 6} {7, 6} 
{0, 7} {1, 7} {2, 7} {3, 7} {4, 7} {5, 7} {6, 7} {7, 7}
В чём может быть причина такого странного поведения программы?
void DuplicateAlongX(vector<Point>& v, int offset) {
    for (const auto& p : v) {
        v.emplace_back(p.x + offset, p.y);
    }
}

void DuplicateAlongY(vector<Point>& v, int offset) {
    for (const auto& p : v) {
        v.emplace_back(p.x, p.y + offset);
    }
}
Ошибка в вычислениях координат точек.
Баг в компиляторе.
Баг в реализации класса vector.
Правильный ответ
Проблема вызвана модификацией вектора в цикле range-based for.
Верно. Сейчас разберём подробнее.
Проблема функций DuplicateAlongX и DuplicateAlongY в том, что они изменяют вектор точек в процессе итерирования по нему. Чтобы лучше понять, что происходит, нужно рассмотреть, как цикл range-based for устроен внутри:
   for (const auto& p : v) {
        v.emplace_back(p.x, p.y + offset);
    }
Для этого обратимся к документации на cpp reference. Компилятор преобразует цикл в эквивалент следующего кода:
{
    auto __begin = v.begin() ;
    auto __end = v.end() ;
    for ( ; __begin != __end; ++__begin) {
        const auto& p = *__begin;
        v.emplace_back(p.x, p.y + offset);
    }
}
То есть это обычный цикл for, у которого компилятор сохраняет итераторы на начало и конец диапазона, вектора v. На каждой итерации цикла выполняется вставка точки в конец вектора. Для этого используется emplace_back. Затем итератор на начало увеличивается до тех пор, пока не сравняется с конечным итератором.
Вы уже знаете, что вектор при нехватке места в текущем массиве производит переаллокацию, то есть выделяет в памяти новый массив большего размера и переносит туда все элементы. Представим, что произойдёт, если переаллокация случится в процессе работы данного цикла. Итераторы begin и end продолжат бежать по той области памяти, которая уже возвращена обратно в кучу. Когда размер вектора равен его вместимости, вызов методов push_back и emplace_back делает недействительными все итераторы на элементы вектора. При их использовании происходит неопределённое поведение.
Возможно, вы захотите использовать метод reserve, чтобы избавиться от переаллокации и зарезервировать в векторе место, вдвое превышающее его текущий размер:
.void DuplicateAlongX(vector<Point>& v, int offset) {
    v.reserve(v.size() * 2);
    for (const auto& p : v) {
        v.emplace_back(p.x + offset, p.y);
    }
}

void DuplicateAlongY(vector<Point>& v, int offset) {
    v.reserve(v.size() * 2);
    for (const auto& p : v) {
        v.emplace_back(p.x, p.y + offset);
    }
}
Запустите программу и увидите, что вывод ровно тот, что нужен:
{0, 0} {1, 0} {2, 0} {3, 0} {4, 0} {5, 0} {6, 0} {7, 0} 
{0, 1} {1, 1} {2, 1} {3, 1} {4, 1} {5, 1} {6, 1} {7, 1} 
{0, 2} {1, 2} {2, 2} {3, 2} {4, 2} {5, 2} {6, 2} {7, 2} 
{0, 3} {1, 3} {2, 3} {3, 3} {4, 3} {5, 3} {6, 3} {7, 3} 
{0, 4} {1, 4} {2, 4} {3, 4} {4, 4} {5, 4} {6, 4} {7, 4} 
{0, 5} {1, 5} {2, 5} {3, 5} {4, 5} {5, 5} {6, 5} {7, 5} 
{0, 6} {1, 6} {2, 6} {3, 6} {4, 6} {5, 6} {6, 6} {7, 6} 
{0, 7} {1, 7} {2, 7} {3, 7} {4, 7} {5, 7} {6, 7} {7, 7}
Можно ли считать, что проблема с кодом исправлена?
Проблема исправлена.
Правильный ответ
Проблема осталась.
Тысяча чертей!
Чтобы разобраться, что не так, надо внимательнее прочитать описание метода emplace_back.
If the new size() is greater than capacity() then all iterators and references (including the past-the-end iterator) are invalidated. Otherwise only the past-the-end iterator is invalidated.
Если новый размер вектора больше, чем вместимость, все итераторы и ссылки, включая end-итератор, становятся недействительными. В противном случае недействительным становится только end-итератор.
Из этого замечания следует, что итератор, который возвращается из метода end, всегда инвалидируется при вызове emplace_back. А это именно тот итератор, который получен при инициализации range-based цикла for. Сравнение с таким итератором — неопределённое поведение.
В данном случае компилятор и стандартная библиотека не использовали неопределённое поведение, чтобы результат программы стал неожиданным. Но это может измениться в следующих версиях компилятора или при переходе на другой компилятор.
Здесь не получится написать реализацию функций DuplicateAlong с использованием цикла range-based for. Следует выбрать обычный цикл, использующий индексы:
void DuplicateAlongX(vector<Point>& v, int offset) {
    // reserve по-прежнему нужен, чтобы избежать переаллокации
    v.reserve(v.size() * 2);
    const size_t old_size = v.size();
    for (size_t i = 0; i != old_size; ++i) {
        auto& p = v[i];
        v.emplace_back(p.x + offset, p.y);
    }
}

void DuplicateAlongY(vector<Point>& v, int offset) {
    v.reserve(v.size() * 2);
    const size_t old_size = v.size();
    for (size_t i = 0; i != old_size; ++i) {
        auto& p = v[i];
        v.emplace_back(p.x, p.y + offset);
    }
}
Идиоматический C++ помогает избежать многих проблем с неопределённым поведением. Но иногда этого недостаточно. И даже если программа работает правильно во всех ваших компиляторах, нельзя делать вывод, что в ней нет неопределённого поведения.
Чтобы его обнаружить, используются специальные инструменты. О них — в следующем уроке.
Инструменты для обнаружения неопределённого поведения
В предыдущих уроках вы увидели интересные и необычные проявления неопределённого поведения. В этом вы познакомитесь с доступными инструментами, которые помогают обнаруживать его в программах.
Статический анализатор Clang-tidy
Первый инструмент — статический анализатор Clang-tidy. Он, как компилятор, анализирует код и выдает предупреждения о реальных и потенциальных ошибках, таких как:
неопределённое поведение,
ошибки copy-paste,
некорректное использование библиотечных функций,
использование устаревших языковых конструкций или библиотечных функций.
Утилита Clang-Tidy входит в состав проекта LLVM вместе с компилятором Clang. Загрузить Clang для распространённых операционных систем можно на странице проекта: releases.llvm.org/download.html.
Рассмотрим работу статического анализатора на примере программы, проверяющей, считается ли небесное тело планетой. Создайте в каталоге с исходным кодом программы файл с именем .clang-tidy и следующим содержимым:
---
Checks:          '*,-llvm-*,-llvmlibc-*,-google-build-using-namespace,-modernize-use-trailing-return-type'
В этом файле задаются настройки, которые распространяются на все файлы в каталоге и его подкаталогах. Параметр Checks — строка, где через запятую перечислены имена включённых проверок. Символ * в имени проверки означает «любые символы». Например, llvm-* включает все проверки, имена которых начинаются с llvm-, а * включает проверки с любыми именами. Символ - перед именем проверки означает, что её надо исключить.
В конфигурационном файле выше включены все проверки (опция *), кроме тех, перед которыми стоит -:
проверки, относящиеся к сборке проекта LLVM — диагностика llvm-* и llvmlibc-*;
предупреждение об использовании директивы using namespace — диагностика google-build-using-namespace;
предложение заменить объявление функций на альтернативную форму записи — диагностика modernize-use-trailing-return-type.
Создайте в этом каталоге файл planets.cpp со следующим содержимым:
#include <iostream>
#include <string_view>

using namespace std;

const int NUM_PLANETS = 8;
const string_view PLANETS[] = {
    "Mercury"sv, "Venus"sv, "Earth"sv,
    "Mars"sv, "Jupiter"sv, "Saturn"sv,
    "Uranus"sv, "Neptune"sv,
};

bool IsPlanet(string_view name) {
    for (int i = 0; i < NUM_PLANETS; ++i) {
        if (PLANETS[i] == name) {
            return true;
        }
    }
    return false;
}

void Test(string_view name) {
    cout << name << " is " << (IsPlanet(name) ? ""sv : "NOT "sv) << "a planet"sv << endl;
}

int main() {
    Test("Earth"sv);
    Test("Jupiter"sv);
    Test("Pluto"sv);
    Test("Moon"sv);
} 
Вызовите в консоли команду clang-tidy. Передайте ей имя анализируемого файла, а следом за разделителем "--" — настройку, включающую поддержку стандарта C++17. Она нужна для использования string_view.
clang-tidy planets.cpp -- -std=c++17
Утилита clang-tidy выведет предупреждения о коде:
planets.cpp:7:7: warning: do not declare C-style arrays, use std::array<> instead [cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays]
const string_view PLANETS[] = {
      ^
C:\Users\Alexey\source\repos\practicum-malov\sprint13\ub\planets\planets.cpp:14:5: warning: use range-based for loop instead [modernize-loop-convert]
    for (int i = 0; i < NUM_PLANETS; ++i) {
    ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        (auto i : PLANETS)
C:\Users\Alexey\source\repos\practicum-malov\sprint13\ub\planets\planets.cpp:15:13: warning: do not use array subscript when the index is not an integer constant expression; use gsl::at() instead [cppcoreguidelines-pro-bounds-constant-array-index]
        if (PLANETS[i] == name) {
            ^
Первое предупреждение “do not declare C-style arrays, use std::array<> instead” рекомендует вместо объявления массива фиксированного размера в стиле языка C использовать класс std::array. В отличие от C-массивов, объекты std::array могут быть переданы в функцию по значению и возвращены из неё. Также они предоставляют больше проверок в отладочном режиме работы. Кроме того, у std::array есть метод size(), возвращающий размер массива.
Предупреждение “use range-based for loop instead” рекомендует использовать range-версию цикла for. Если бы количество элементов массива PLANETS и константа NUM_PLANETS различались, это бы привело к неопределённому поведению при работе программы, а в range-версии цикла for такую ошибку допустить не получится.
Третье предупреждение “do not use array subscript when the index is not an integer constant expression; use gsl::at()” советует не обращаться к элементам массива по неконстантному индексу, так как это может привести к выходу за пределы массива. Предлагается использовать вспомогательную функцию gsl::at из библиотеки Guidelines Support Library.
Три предупреждения о массиве PLANETS не свидетельствуют напрямую о наличии неопределённого поведения. Но рекомендуют обратить внимание на потенциально опасные конструкции в коде.
Последуем первым двум советам: заменим C-массив на std::array, а цикл for — на подходящий здесь алгоритм std::find:
#include <algorithm>
#include <array>
#include <iostream>
#include <string_view>

using namespace std;

const array PLANETS{
    "Mercury"sv, "Venus"sv, "Earth"sv,
    "Mars"sv, "Jupiter"sv, "Saturn"sv,
    "Uranus"sv, "Neptune"sv,
};

bool IsPlanet(string_view name) {
    return find(begin(PLANETS), end(PLANETS), name) != end(PLANETS);
}

void Test(string_view name) {
    cout << name << " is " << (IsPlanet(name) ? ""sv : "NOT "sv) << "a planet"sv << endl;
}

int main() {
    Test("Earth"sv);
    Test("Jupiter"sv);
    Test("Pluto"sv);
    Test("Moon"sv);
}
Повторный прогон анализатора пройдёт без замечаний.
Статический анализатор позволил не только устранить неопределённое поведение в программе, но и упростить код — сделать его более идиоматическим. Используйте подобные инструменты регулярно — так вы обнаружите потенциально опасные места на раннем этапе.
Отладочный режим стандартной библиотеки
С этим инструментом вы уже успели познакомиться в этом курсе. Чтобы включить отладочный режим, нужно добавить следующие опции командной строки:
libstdc++: -D_GLIBCXX_DEBUG (обычно компилятор gcc)
libc++: -D_LIBCPP_DEBUG=1 (обычно компилятор clang)
Компилятор Visual C++: -D_ITERATOR_DEBUG_LEVEL=2
Проверим работу отладочного режима стандартной библиотеки на примере программы, заполняющей сетку из точек:
#include <iostream>
#include <vector>

using namespace std;

struct Point {
    int x, y;
    Point(int x, int y)
        : x(x)
        , y(y) {
    }
};

void DuplicateAlongX(vector<Point>& v, int offset) {
    for (const auto& p : v) {
        v.emplace_back(p.x + offset, p.y);
    }
}

void DuplicateAlongY(vector<Point>& v, int offset) {
    for (const auto& p : v) {
        v.emplace_back(p.x, p.y + offset);
    }
}

int main() {
    vector points = {Point(0, 0)};

    DuplicateAlongX(points, 1);
    DuplicateAlongX(points, 2);
    DuplicateAlongX(points, 4);

    DuplicateAlongY(points, 1);
    DuplicateAlongY(points, 2);
    DuplicateAlongY(points, 4);

    int n = 0;
    for (const auto& p : points) {
        cout << '{' << p.x << ", "sv << p.y << "} "sv;
        ++n;
        if (n == 8) {
            cout << endl;
            n = 0;
        }
    }
}
Теперь, если во время работы программы попытаться выполнить инкремент невалидного итератора, в консоль будет выведена ошибка. Программа аварийно завершит работу:
Error: attempt to increment a singular iterator.

Objects involved in the operation:
    iterator       type = __gnu_debug::_Safe_iterator<__gnu_cxx::__normal_iterator<Point*, std::__cxx1998::vector<Point, std::allocator<Point> > >, std::__debug::vector<Point, std::allocator<Point> > > (mutable iterator);
      state = singular;
      references sequence with type 'std::__debug::vector<Point, std::allocator<Point> >' @ 0x000000000065FD80
    }
Undefined behavior sanitizer
Undefined behavior sanitizer — это специальный режим работы компилятора, который добавляет в скомпилированный код дополнительные проверки. Они обнаруживают различные виды неопределенного поведения во время работы программы. Например:
использование нулевого указателя или указателя с неправильным выравниванием;
переполнение в операциях над целыми числами со знаком;
целочисленное деление на ноль.
Как и отладочный режим стандартной библиотеки, санитайзер обнаруживает ошибки во время работы программы. Но такие проверки охватывают код всей программы, а не только код стандартной библиотеки.
В ОС Windows такую опцию компилятор gcc пока не поддерживает. Но есть одноименная опция командной строки для компилятора clang. Посмотрим, как это работает. Для примера возьмем программу, в которой при сложении возникало переполнение целого числа:
#include <climits>
#include <iomanip>
#include <iostream>

bool TestSigned(int n) {
    return n < n + 1;
}

bool TestUnsigned(unsigned int n) {
    return n < n + 1;
}

using namespace std;
int main() {
    cout << boolalpha;
    cout << TestSigned(INT_MAX) << endl;
    cout << TestUnsigned(UINT_MAX) << endl;
}
Соберём её со включенным UB-санитайзером:
g++ -fsanitize=undefined -std=c++17 overflow.cpp
Вместо g++ можно использовать компилятор clang с теми же опциями командной строки. При запуске программы обнаружится неопределённое поведение:
overflow.cpp:6:18: runtime error: signed integer overflow: 2147483647 + 1 cannot be represented in type 'int'
SUMMARY: UndefinedBehaviorSanitizer: undefined-behavior overflow.cpp:6:18 in
Санитайзер поможет обнаружить неопределённое поведение и в программе, которая выпускает велоцираптора при срабатывании сигнализации:
#include <iostream>

using namespace std;

// Указатель на функцию без параметров, которая возвращает void
using Alarm = void (*)();

namespace {
// Поведение сигнализации определяется значением указателя alarm
Alarm alarm = nullptr;
}  // namespace

// Выпустить велоцираптора
void HostileAlarm() {
    cout << "Attack with velociraptor"sv << endl;
}

// Настраиваем сигнализацию на выпуск велоцираптора
void SetHostileAlarm() {
    cout << "Hostile alarm set" << endl;
    alarm = HostileAlarm;
}

void Test() {
    // Вызываем функцию, на которую ссылается указатель alarm
    alarm();
    cout << "Test succeeded"sv << endl;
}

int main() {
    Test();
}
Сборка программы под санитайзером:
clang++ alarm.cpp -O2 -std=c++17 -fsanitize=undefined
Запуск программы:
UndefinedBehaviorSanitizer:DEADLYSIGNAL
==22==ERROR: UndefinedBehaviorSanitizer: SEGV on unknown address 0x00000000a7a0 (pc 0x000000425b93 bp 0x0000004279e0 sp 0x7fffa4174370 T22)
==22==The signal is caused by a READ memory access.
    #0 0x425b93  (/home/jail/prog.exe+0x425b93)
    #1 0x425cfd  (/home/jail/prog.exe+0x425cfd)
    #2 0x7ff16b23882f  (/lib/x86_64-linux-gnu/libc.so.6+0x2082f)
    #3 0x403b48  (/home/jail/prog.exe+0x403b48)

UndefinedBehaviorSanitizer can not provide additional info.
SUMMARY: UndefinedBehaviorSanitizer: SEGV (/home/jail/prog.exe+0x425b93) 
==22==ABORTING
Вот как заранее обнаружить и предотвратить неопределённое поведение.

