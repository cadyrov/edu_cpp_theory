Отношения между классами
Визуализация класса
Один из способов визуализации структуры программы — диаграмма классов. Диаграмма визуализирует классы и интерфейсы, из которых состоит программа или её часть, свойства и методы классов, а также связи между компонентами программы. Используемые в этой теме обозначения основываются на упрощённой нотации универсального языка моделирования UML.
Класс обозначается прямоугольником, содержащим имя класса, его методы и поля. Перед именем публичного метода и поля класса может ставиться символ +, а приватного — символ -. Тип полей, аргументов и возвращаемых значений указывается после двоеточия. Указатели, ссылки, а также тип void для краткости записи можно опустить.
Приватная часть класса, часть публичных методов или все публичные методы, несущественные на данной схеме, могут быть пропущены:

Стандартные классы вроде string, vector, а также несущественные для диаграммы классы обычно на ней не отображаются.
Перечислимые типы отображаются похожим на класс образом, с той лишь разницей, что перед именем класса записывают слово enumeration.
Композиция (Composition)
Композиция — один из самых простых способов создать новый тип данных, используя функционал уже имеющихся. При композиции мы получаем новый, более сложный тип, состоящий из одного или нескольких более простых объектов.
Особенности:
Один объект является частью другого, составного объекта.
Часть в один момент времени может принадлежать только одному составному объекту.
Составной объект управляет своими частями. В частности, когда объект удаляется, его части должны быть также удалены.
Часть не знает о существовании объекта, который ею владеет.
В C++ мы обычно используем композицию, когда объявляем структуру или класс.
Примеры композиции:
Точка на плоскости состоит из двух чисел, хранящихся её координаты.
Окружность состоит из точки, задающей координаты центра, и числа, задающего радиус.
Осьминог состоит из головы и нескольких щупалец.
Класс рациональных чисел состоит из двух целых чисел — числителя и знаменателя.
// Книга - пример композиции экземпляров string и int.
class Book {
    ...
private:
    string title_;
    string author_;
    string isbn_; // ISBN - уникальный номер книжного издания
    int publication_year_; // Год публикации
};

// Человек - ещё один пример композиции экземпляров string и int
class Person {
private:
    string name_;
    string address_;
    int birth_year_;
};
Композиция позволяет с легкостью создавать сложные объекты из более простых. Однажды разработав и протестировав класс, мы можем многократно использовать его как надежный «кирпичик» в составе более крупных компонентов нашей программы. Классы стандартной библиотеки C++ являются хорошим примером таких «кирпичиков».
На диаграмме классов композиция обозначается соединительной линией с закрашенным ромбом, исходящим от составного объекта. Со стороны включаемого объекта наконечника может и не быть.

Ограничений на количество включений простого объекта в состав более сложного нет. В приведённом примере Circle содержит один экземпляр Point, а Triangle — три. Чтобы подчеркнуть множественный характер связи, на конце стрелки может указываться количество экземпляров.
Составной класс, как правило, прячет свои члены-данные от доступа извне и управляет ими. Это позволяет сохранить состояние объекта согласованным. На следующей диаграмме представлен класс AlarmClock, который состоит из часов (Clock), звукового устройства (Beeper) и времени включения звукового сигнала. Пользователи Будильника не имеют доступа к содержащимся в нём полям clock_ и beeper_. Благодаря этому сигнал пробуждения прозвучит в тот момент, когда текущее время, предоставляемое часами, станет равно значению поля alarm_time_.

То, что класс Beeper не знает об объектах, в которых он содержится, дает возможность использовать Beeper не только в будильнике, но и, например, в игрушечной полицейской машине. Только в этом случае звуковой сигнал будет включен не по достижении определённого времени, а сразу при включении игрушки.
При разрушении составного объекта удаляются и входящие в его состав объекты. Например, при удалении папки должны быть удалены все содержащиеся в ней файлы.
Агрегация (Aggregation)
Агрегация — тоже пример отношений часть-целое, и реализуется она, подобно композиции, с использованием структур или классов. Различия между композицией и агрегацией в основном семантические.
Особенности агрегации:
Часть является частью Целого.
Часть в один и тот же момент времени может принадлежать более чем одному Целому.
Целое не управляет своими частями. При удалении Целого Часть продолжает существовать.
Часть не знает о существовании Целого.
Транзитивность — связи между агрегированными объектами не имеют циклов, то есть ни один из объектов не является прямой или косвенной частью самого себя.
При композиции мы добавляем части к целому, используя обычные переменные-члены. А когда класс использует динамическое выделение памяти, применяем указатели. При этом часть не может существовать без целого. В качестве примера композиции классов, использующих динамическое выделение памяти, можно привести классы Осьминог и Односвязный список. При разрушении Осьминога происходит удаление его Щупалец, а при разрушении односвязного списка удаляются его узлы.
При агрегации мы также используем переменные-члены класса, только в этом случае они будут ссылками или указателями на объекты, созданные и существующие за пределами класса. Адреса объектов передаются классу-агрегату снаружи через параметры конструктора либо через параметры методов. При этом Часть может существовать отдельно от Целого.
Примером агрегации можно назвать отношение итератора и узла односвязного списка. Итератор хранит указатель на узел односвязного списка, которым владеет другой объект, а именно односвязный список. Разрушение итератора не влияет на узел. Узел ничего не знает о существовании итератора. Агрегацией в односвязном списке также будет связь текущего узла списка со следующим за ним:
template <typename T>
class SingleLinkedList {
    struct Node {
        ...
        T value{};
        Node* node_ = nullptr;
    };
public:
    class Iterator {
        ...
    private:
        // Итератор хранит адрес узла списка, но не владеет им
        Node* node_;
    };
};
Объект-агрегат обычно скрывает свои части от доступа извне. Например, итератор не имеет публичных методов для доступа к узлам списка, хотя в своем операторе разыменования возвращает ссылку на значение узла списка. Так внешний код не может получить доступ к служебным полям узла списка в обход итератора.
Так как Агрегат не единственный владелец своих частей, он должен быть готов к тому, что к его частям могут иметь доступ и другие объекты.
На схемах агрегация обозначается как композиция с той лишь разницей, что ромбик, расположенный на стороне объекта-агрегата, не закрашивается:

Еще один пример агрегации — отношение между Автобусом и Человеком. Автобус перевозит людей, но они не его составная часть. После разрушения автобуса с человеком ничего не происходит.

Агрегация позволяет одному объекту делегировать часть работы другому, переданному извне, объекту. Например, чтобы добавить в вашу поисковую систему логирование поисковых запросов, не нужно в ней реализовывать код логирования, ведь основная задача поисковой системы — поиск. Вместо этого логирование лучше поручить отдельному классу Logger. Ссылку на Logger нужно передать в конструктор класса SearchServer, чтобы он сохранил её в одном из своих полей.

Теперь при поиске документов поисковая система может использовать Logger для ведения логов поисковых запросов. Товарищ майор одобряет.
Зависимость (Dependency)
При композиции и агрегации Целое оказывается связанным с Частью в течение длительного времени — поля Целого хранят Часть по значению, ссылке или указателю.
В жизни потребность в каком-либо объекте нам часто нужна лишь для выполнения некоторой задачи: мы вызываем такси, чтобы доехать до нужного места, берём нож, чтобы сделать бутерброд, прибегаем к услугам парикмахера, чтобы подстричься. После выполнения задачи потребность в объекте исчезает до следующего раза. И правда, незачем держать при себе парикмахера до конца своей жизни.
Такого рода отношение называется зависимостью, или отношением «‎Клиент-Поставщик». У Клиента возникает зависимость от Поставщика при решении некоторой задачи. Зависимость возникает в любом из следующих случаев:
Поставщик создаётся внутри метода Клиента.
Поставщик передается в метод Клиента по значению, ссылке или указателю.
Метод клиента возвращает Поставщика.
Во всех упомянутых ситуациях зависимость от Поставщика существует лишь на протяжении вызова метода Клиента — в локальных переменных, параметрах функций и временных объектах.
Также Поставщик ничего не знает про Клиента:
// Поставщик. Предоставляет функционал, нужный Клиенту
class Supplier { 
public:
    void DoSomething();
    ...
};

// Клиент. Использует функционал, предоставляемый ему Поставщиком
class Client {
public:
    // Зависимость передается через параметр метода
    void DependentMethod1(Supplier& supplier) {
        supplier.DoSomething();
    }

    // Клиент создает экземпляр Поставщика и использует его
    void DependentMethod2() {
        Supplier supplier;
        supplier.DoSomething();
    }

    // Клиент возвращает Поставщика
    Supplier DependentMethod3() {
        return Supplier{};
    }

    // Этот метод не зависит от Поставщика
    void IndependentMethod() {
        cout << "Hello"s << endl;
    }
};
Примером зависимости может служить отношение односвязного списка и его итератора — односвязный список не хранит внутри себя итератор, однако возвращает его и принимает в качестве параметра методов, таких как Insert или Erase.
Еще один пример — загрузка и сохранение объектов в потоки ввода и вывода:
class Document {
public:
    // output используется только для записи документа
    void SaveToStream(ostream& output) const {
        output << title_ << endl;
        output << text_ << endl;
    }
    // input используется только для чтения документа
    void LoadFromStream(istream& input) {
        getline(input, title_);
        text_.clear();
        string line;
        while (getline(input, line)) {
            if (!text_.empty()) {
                text_ += '\n'; // Добавляем символ перевода строки перед каждой строкой, кроме первой
            }
            text_ += line;
        }
    }
private:
    string title_;
    string text_;
};
Класс Document зависит от классов ostream и istream только во время вызова методов SaveToStream и LoadFromStream. Это значит, что на протяжении жизни Документа его можно сохранять в разные потоки вывода или загружать из разных потоков ввода. Точь-в-точь как для печати одного и того же документа вы используете разные листы бумаги. Обратной зависимости ostream и istream от документа нет.
На схемах зависимость изображается пунктирной стрелкой, идущей от Клиента к Поставщику. Чтобы конкретизировать, какой вид зависимости используется, на стрелке дополнительно может указываться одно из следующих слов:
create. Метод Клиента создаёт экземпляр Поставщика и использует его, не передавая наружу.
return. Клиент возвращает экземпляр Поставщика. При этом клиент может создавать Поставщика самостоятельно или делегировать создание другому объекту.
use. Клиент использует зависимость, переданную ему через параметр метода. Для этого он вызывает методы переданных ему параметров или передаёт их дальше в качестве параметров.

Класс Прямоугольник использует переданный ему Холст (Canvas), чтобы нарисовать на нём своё изображение, вызывая методы MoveTo и LineTo. Так можно многократно с разными параметрами вызывать метод Draw у одного и того же прямоугольника, получая изображение прямоугольника на разных холстах.
Поисковая система возвращает экземпляры Document. Такой тип зависимости обозначается словом "return":

Зависимость — наиболее слабая связь между классами среди рассмотренных отношений. Эта слабость даёт наибольшую гибкость — каждый вызов метода Клиента может иметь дело с новым Поставщиком. За эту гибкость приходится платить — зависимость транзитивна. Она распространяется на всех пользователей Клиента — они должны уметь создать Поставщика перед тем как передать его Клиенту в качестве параметра и знать, что делать с Поставщиком, которого им вернул Клиент. При композиции и агрегации зависимость не распространяется, так как Целое скрывает свои Части в приватной области.
На схеме показан класс Приложение, включающий в себя Поисковую Систему. Приложение неявно зависит от класса Document, так как используемый Приложением метод SearchServer::FindTopDocuments возвращает вектор документов.

Для приложения эта транзитивная зависимость от документа означает следующее:
Приложение должно уметь работать с документами, которые оно получает от поисковой системы.
Изменения в классе Document окажут влияние не только на SearchServer, но и на Application. Зависимые классы может потребоваться доработать и заново протестировать.
Введение в наследование
Рассмотрим программу, которая имеет дело с сущностями Программист и Рабочий, представленными классами Programmer и Worker соответственно. Программисты владеют языками программирования, а рабочие — специальностями. И те и другие обладают именем, возрастом и полом:
#pragma once
#include <unordered_set>
#include <string>

enum class ProgrammingLanguage { CPP, JAVA, PYTHON, PHP };

enum class Gender { MALE, FEMALE };

// Программист. Знает несколько языков программирования
class Programmer {
public:
    Programmer(const std::string& name, int age, Gender gender);

    const std::string& GetName() const;
    int GetAge() const;
    Gender GetGender() const;

    void AddProgrammingLanguage(ProgrammingLanguage language);
    bool CanProgram(ProgrammingLanguage language) const;

private:
    std::string name_;
    int age_;
    Gender gender_;
    std::unordered_set<ProgrammingLanguage> programming_languages_;
};

enum class WorkerSpeciality { BLACKSMITH, CARPENTER, WOOD_CHOPPER, ENGINEER, PLUMBER };

// Рабочий. Владеет несколькими специальностями
class Worker {
public:
    Worker(const std::string& name, int age, Gender gender);

    const std::string& GetName() const;
    int GetAge() const;
    Gender GetGender() const;

    void AddSpeciality(WorkerSpeciality speciality);
    bool HasSpeciality(WorkerSpeciality speciality) const;

private:
    std::string name_;
    int age_;
    Gender gender_;
    std::unordered_set<WorkerSpeciality> specialities_;
};
В этом примере Programmer и Worker имеют одинаковый набор данных и методов, которые есть у людей вне зависимости от их рода деятельности: имя, возраст, пол. В то же время представленные классы имеют специфичные для конкретных профессий данные и методы: программист владеет языками программирования, а рабочий — одной или несколькими специализациями.
При попытке установить, как друг с другом связаны Программист и Рабочий, выяснится, что знакомые вам виды отношений им не подходят. Эти классы друг с другом никак не связаны. Кроме того, есть потребность добавить ещё одну сущность, обобщающую Программистов и Рабочих. И такая сущность — класс Person.
Здесь мы сталкиваемся с новым видом отношений между классами — «является». И рабочий, и программист «являются» людьми. Всё, что верно для людей, верно и для рабочих, и для программистов. У людей есть имя, пол и возраст. Рабочий и программист сохраняют эти свойства, добавляя к ним свои данные и методы.
В C++ и многих других языках программирования для выражения отношения «является» используется наследование. Механизм наследования создаёт новый класс не с нуля, а на основе уже существующего класса. Новый класс сохраняет данные и поведение родительского класса. За счёт этого обеспечивается повторное использование кода. Наследование вводит следующие концепции:
Класс-родитель (класс-предок, родительский класс, предок, суперкласс, родитель) — класс, от которого наследуются другие классы.
Класс-потомок (класс-наследник, дочерний класс, потомок, подкласс) — класс, определённый через наследование.
Базовый класс — класс, находящийся на вершине иерархии наследования, то есть не определённый через наследование. Любой небазовый класс является классом-потомком.
Иерархия наследования (иерархия классов) — структура, отражающая связи родителей и потомков. В простейшем случае представляет из себя дерево, узлами которого будут классы.
Чтобы объявить класс-наследник в C++, нужно через двоеточие указать имя базового класса:
struct Point {
    double x = 0;
    double y = 0;
};

enum class Color { BLACK, RED, GREEN, BLUE };

class Shape {
public:
    Color GetColor() const;
    void SetColor(Color color);

private:
    Color color_ = Color::BLACK;
};

class Circle : public Shape {
public:
    Point GetCenter() const;
    void SetCenter(Point center);
    double GetRadius() const;
    void SetRadius(double radius);

private:
    Point center_;
    double radius_ = 1.0;
};
В примере выше объявляется класс Circle, который наследуется от класса Shape (фигура). Ключевое слово public перед именем родительского класса означает публичное наследование. При публичном наследовании публичные методы родительского класса остаются публичными методами наследника. Такой тип наследования выражает отношение «Является» между классами Circle и Shape. Окружность является фигурой.
int main() {
    Circle c;
    c.SetColor(Color::RED);
    c.SetRadius(2);
}
Публичное наследование ещё называется «наследованием интерфейса». Окружность унаследовала от Фигуры методы GetColor и SetColor, составляющие интерфейс фигуры. При этом родительский класс моделирует более общее, абстрактное понятие, а класс-наследник — более конкретное.
При создании экземпляра класса-наследника в программе создается один объект, содержащий данные и методы, специфичные как для этого класса, так и для его родителей.
Графическое представление иерархий наследования
Графически наследование обозначается в виде стрелки с треугольным наконечником, направленной от наследника к базовому классу. Иногда встречается форма записи, при которой соединительная линия содержит надпись "Extends". На следующем рисунке показаны различные иерархии наследования.

В визуальном представлении иерархии наследования значение имеет направление стрелок, а не расположение классов относительно друг друга. На следующем рисунке изображены два разных представления одной и той же иерархии наследования. Верхняя иерархия воспринимается легче, так как в ней элементы упорядочены по глубине наследования.

Передача параметров конструктору родительского класса
Жизненный цикл объекта начинается с вызова его конструктора, который выполняет необходимую инициализацию объекта. Конструирование дочернего класса происходит чуть сложнее: сначала выполняется конструктор класса-родителя, чтобы проинициализировать часть, относящуюся к родительскому классу. Если у родительского класса есть предок, перед вызовом конструктора родительского класса выполняется конструктор предка. Например, при инициализации Кошки сначала выполнится конструктор Животного, затем Млекопитающего, а следом за ним — Кошки.
Для этого компилятор перед вызовом конструктора наследника сам вызывает конструктор по умолчанию класса-родителя. Если в родительском классе есть параметризованный конструктор, наследник может вызвать его в списке инициализации своего конструктора. Более того, это единственный способ создать класс-наследник класса, не имеющего конструктор по умолчанию.
Ниже приведён класс Shape, имеющий параметризованный конструктор. Из-за этого в классе отсутствует конструктор по умолчанию:
struct Point {
    double x = 0;
    double y = 0;
};

enum class Color { BLACK, RED, GREEN, BLUE };

class Shape {
public:
    explicit Shape(Color color)
        : color_(color) {
    }

    Color GetColor() const {
        return color_;
    }

private:
    Color color_;
};
Унаследованный от Shape класс Circle должен явно вызвать параметризованный конструктор родителя, передав ему нужное значение цвета:
class Circle : public Shape {
public:
    Circle(Color color, Point center, double radius)
        : Shape(color)  // Передаём цвет конструктору родительского класса
        , center_(center)
        , radius_(radius) {
    }

    Point GetCenter() const {
        return center_;
    }
    void SetCenter(Point center) {
        center_ = center;
    }

    double GetRadius() const {
        return radius_;
    }
    void SetRadius(double radius) {
        radius_ = radius;
    }

private:
    Point center_;
    double radius_;
};

int main() {
    // Красная окружность с центром в точке {1, 2} радиусом 5
    Circle c{Color::RED, {1, 2}, 5};
}
Полиморфизм
В прошлом уроке вы узнали о наследовании — механизме, который позволяет производному классу сохранять данные и поведение родительского класса. Наиболее распространённая форма наследования — это публичное наследование, его ещё называют наследованием интерфейса.
В жизни мы часто используем устройства, использующие стандартные интерфейсы:  электрические розетки, разъемы USB и HDMI. При этом один и тот же интерфейс позволяет подключать совершенно непохожие друг на друга устройства. Например, USB позволяет подключить к компьютеру как флэш-накопитель, так и мышь и веб-камеру.
В этом уроке вы научитесь использовать полиморфизм — один из важнейших механизмов объектно-ориентированного программирования, который позволяет работать через один интерфейс со множеством реализаций.
Приведение типа вверх по иерархии класса
При публичном наследовании между классом-наследником и классом-родителем возникает отношение «является». При этом ссылки и указатели на дочерний класс могут неявно преобразовываться к ссылкам и указателям на родительский класс. Это позволяет наследнику сохранять интерфейс родителя — везде, где ожидается ссылка или указатель на родительский класс, можно использовать класс-наследник.
Рассмотрим эту возможность на примере иерархии классов Person и Worker:
class Person {
public:
    Person(const string& name, int age)
        : name_(name)
        , age_(age) {
    }

    int GetAge() const { return age_; }
    const string& GetName() const { return name_; }
    void Dance() const {
        cout << name_ << " is dancing"s << endl;
    }

private:
    string name_;
    int age_;
};

enum class WorkerSpeciality { BLACKSMITH, CARPENTER, WOOD_CHOPPER, ENGINEER, PLUMBER };

class Worker : public Person {
public:
    Worker(const string& name, int age, WorkerSpeciality speciality)
        : Person(name, age)
        , speciality_(speciality) {
    }
    void Work() {
        cout << GetName() << " is working"s << endl;
    }

private:
    WorkerSpeciality speciality_;
};
Совершеннолетний человек может прийти в ночной клуб, чтобы потанцевать:
void VisitNightClub(const Person& person) {
    if (person.GetAge() >= 18) {
        person.Dance();
    } else {
        cout << person.GetName() << " is too young to visit night clubs"s << endl;
    }
}
Функция VisitNightClub зависит от общего типа Person и может принимать не только экземпляры класса Person, но и других классов, публично унаследованных от него. Таким образом, наследование способствует повторному использованию кода:
int main() {
    Person boy("Harry Potter"s, 11);
    VisitNightClub(boy);

    Worker worker("Mario"s, 40, WorkerSpeciality::PLUMBER);
    VisitNightClub(worker);
}
Harry Potter is too young to visit night clubs
Mario is dancing
Публичное наследование позволяет приводить тип ссылок и указателей, ссылающихся на экземпляры классов-наследников, вверх по иерархии классов и тем самым одинаково работать с наследниками через указатели и ссылки на родительский класс.
Благодаря этому можно в одном контейнере хранить указатели типа Person*, которые в действительности могут ссылаться на любой из его наследников:
int main() {
    Person boy("Harry Potter"s, 11);
    Worker worker("Mario"s, 40, WorkerSpeciality::PLUMBER);
    vector<const Person*> people{&boy, &worker};

    for (const Person* person : people) {
        VisitNightClub(*person);
    }
}
В этом примере вектор указателей people можно сравнить с очередью посетителей в ночной клуб. В ней могут стоять разные люди вне зависимости от их профессиональной деятельности. Единственный критерий допуска для них — совершеннолетие.
Рассмотрим, за счёт чего происходит преобразование типа ссылок и указателей вверх по иерархии классов. Внутри блока данных класса-наследника содержится порция данных класса-родителя. Например, в начале блока данных класса Worker может находиться блок данных его родителя, класса Person.

Благодаря одинаковому расположению полей name_ и age_ в самом классе Person и в его наследниках, функция VisitNigthClub может работать с Person и его наследниками через ссылку на базовый класс.
Виртуальные методы. Полиморфизм
Наследование позволяет наследникам не только использовать методы класса родителя, но и заменять их поведение на собственное.
Рассмотрим эту возможность на следующем примере: сделаем, чтобы Рабочий во время танца от восторга выкрикивал «Оп-па!». При этом обычные экземпляры Person должны танцевать по-старому.
Метод класса-родителя, который может быть переопределен в классах-наследниках, в C++ должен быть объявлен виртуальным. Для этого используют ключевое слово virtual:
class Person {
public:
    ...    
    // Реализация виртуального метода может быть переопределена в классах-наследниках
    virtual void Dance() const { 
        cout << name_ << " is dancing"s << endl;
    }

private:
    string name_;
    int age_;
};
В классе-наследнике переопределяемый виртуальный метод объявляется со спецификатором override. При необходимости внутри метода класса-наследника можно вызвать реализацию метода родительского класса, написав перед именем вызываемого метода ИмяКлассаРодителя::. В нашем случае прежде чем выкрикнуть «Оп-па!», рабочий вызывает реализацию метода Dance класса Person, чтобы рабочий станцевал как обычный человек:
class Worker : public Person {
public:
    ...
    // Метод Dance переопределяет (override) реализацию базового класса
    void Dance() const override {
        // Сначала вызываем метод Dance родительского класса
        Person::Dance();
        // Добавляем дополнительное поведение
        cout << "Oppa!"s << endl;
    }

private:
    WorkerSpeciality speciality_;
};
Благодаря тому, что метод Dance виртуальный, при его вызове даже с использованием ссылки на базовый класс будет вызвана реализация класса наследника:
int main() {
    Person person("Ivan Ivanov"s, 30);
    VisitNightClub(person);

    Worker worker("Mario"s, 40, WorkerSpeciality::PLUMBER);
    VisitNightClub(worker);
}
Теперь в ночном клубе Person и Worker будут танцевать по-разному:
Ivan Ivanov is dancing
Mario is dancing
Oppa!
Возможность работы с разными реализациями через один и тот же интерфейс называется полиморфизм. В данном случае речь идет о полиморфизме времени выполнения: реализация вызываемого метода выбирается во время работы программы. С другим вариантом полиморфизма — полиморфизмом времени компиляции — вы познакомились раньше, когда проходили шаблоны и перегрузку функций и операторов.
Чтобы полиморфизм времени выполнения корректно работал, метод родительского класса, который можно переопределить в наследниках, должен быть объявлен виртуальным. Только в этом случае компилятор будет знать, что у этого метода возможны несколько реализаций в классах наследниках. Тогда компилятор поместит в объект дополнительную информацию, которая позволит во время выполнения вызвать верную реализацию метода.
Не менее важно в методе наследника указывать спецификатор override у переопределяемого метода. Во-первых, при чтении кода будет видно, что данный метод переопределяет метод класса-родителя. Во-вторых, override требует, чтобы в одном из родительских классов был виртуальный метод с идентичной сигнатурой. Это позволяет обнаружить ошибку, описанную далее.
Если метод Person::Dance не объявить виртуальным, метод Dance класса Worker лишь скроет одноименный метод родителя:
class Person {
public:
    ...    
    // Метод Dance умышленно объявлен невиртуальным
    void Dance() const { 
        cout << name_ << " is dancing"s << endl;
    }
};

class Worker : public Person {
public:
    ...
    // Метод Dance класса Worker замещает собой невиртуальный метод Dance родительского класса
    void Dance() const {
        Person::Dance();
        cout << "Oppa!"s << endl;
    }
};
Результат вызова невиртуального метода Dance у одного и того же объекта будет зависеть от типа ссылки или указателя на объект, которые используются для вызова метода.
void VisitNightClub(const Person& person) {
    if (person.GetAge() >= 18) {
        // Компилятор вызовет метод Person::Dance, так как он не виртуальный
        person.Dance();
    } else {
        cout << person.GetName() << " is too young to visit night club"s << endl;
    }
}

int main() {
    Worker worker("Mario"s, 40, WorkerSpeciality::PLUMBER);
    // Здесь будет вызван метод Worker::Dance, так он вызывается у переменной типа Worker
    worker.Dance();

    VisitNightClub(worker);
}
Внутри функции VisitNightClub переменная person будет ссылкой на Person, поэтому будет вызван метод Person::Dance. Внутри функции main компилятор знает реальный тип переменной worker, поэтому будет вызван метод Worker::Dance:
Mario is dancing
Oppa!
Mario is dancing
Эту ошибку можно обнаружить во время компиляции, указав спецификатор override у метода Worker::Dance. В этом случае компилятор выдал бы ошибку при попытке переопределить невиртуальный метод.
По умолчанию в C++ методы класса невиртуальные, так как их вызов проще и быстрее вызова виртуальных методов. Кроме того, объект без виртуальных методов занимает меньше места в памяти. Это соответствует философии C++: «Вы не платите за те функции языка, которые не используете».
Подведем итоги.
Объявляйте метод родительского класса виртуальным, если нужно дать подклассам переопределять реализацию этого метода. В дочерних классах используйте спецификатор override, когда метод переопределяет реализацию родителя.
Если возможность переопределения метода в подклассах не требуется, не объявляйте метод виртуальным, а в классах-наследниках не объявляйте методов с таким же именем.
Метод класса, который объявлен виртуальным в родительском классе, остается виртуальным и во всех его наследниках.
Наследование — детали
Публичные данные и методы класса формируют его интерфейс и доступны как самому классу, так и коду за его пределами. Приватные данные и методы формируют реализацию класса и доступны внутри самого класса. При этом члены-данные класса часто объявляются приватными, что позволяет поддерживать состояние класса в согласованном виде — никто, кроме самого класса, не может изменить его состояние и нарушить согласованность данных.
Так приватная область класса оказывается скрытой от всего внешнего мира, включая наследников. В ряде случаев это может оказаться неудобным.
Вы уже умеете обращаться со спецификаторами доступа public и private, которые разграничивают права доступа к данным и методам класса. В этом уроке вы познакомитесь со спецификатором доступа protected. Благодаря ему дочерние классы смогут обращаться к данным и методам своего родителя.
Также вы узнаете об особенностях работы деструкторов в иерархии классов и научитесь правильно выполнять полиморфное удаление объектов.
Защищенные члены класса
Рассмотрим уже знакомую иерархию классов Person и Worker. Добавим в класс Person приватное поле satisfaction_, хранящее уровень удовлетворенности. Во время танца уровень удовлетворенности будет увеличиваться:
class Person {
public:
    ...
    int GetAge() const { return age_; }
    int GetSatisfaction() const { return satisfaction_; }
    // Танец поднимает настроение
    virtual void Dance() {
        ++satisfaction_;
    }
private:
    int satisfaction_; // Уровень удовлетворения
    int age_;
};
От заказчика поступили следующие требования:
Рабочие в возрасте от 30 до 40 лет должны во время танца восклицать «Оп-па!», а их уровень удовлетворения должен увеличиваться на два пункта вместо одного.
Работа уменьшает уровень удовлетворения рабочего на один пункт.
Пользователи класса Person имеют доступ к значению удовлетворенности только на чтение.
Чтобы реализовать требования заказчика, классу Worker нужен доступ к полю satisfaction_ своего родителя. Можно было бы объявить класс Worker другом класса Person, но это даст Рабочему доступ ко всем приватным полям Человека, а не только к satisfaction_. Кроме того, придется каждый раз вносить изменения в класс Person, если другие его наследники тоже захотят изменять уровень удовлетворенности.
В C++ есть ещё один спецификатор доступа, protected , который обретает смысл при использовании наследования. Данные и методы, объявленные с этим спецификатором, становятся доступны не только самому классу, но и его наследникам. Остальной код к ним доступа не имеет.
Если поле Person::satisfaction_ объявить защищенным, оно станет доступно дочернему классу Worker:

class Person {
    ...
protected:
    int satisfaction_; // Уровень удовлетворения теперь доступен наследникам класса Person
private:
    int age_;
};

class Worker : public Person {
public:
    void Dance() override {
        // Рабочий сперва просто танцует, как обычный человек
        Person::Dance();

        // Рабочий в возрасте от 30 до 40 во время танца получает 
        // дополнительную порцию удовлетворения
        if (const int age = GetAge(); age > 30 && age < 40) {
            cout << "Oppa!" << endl;
            ++satisfaction_;
        }
    }

    void Work() {
        // Работа понижает уровень удовлетворённости
        --satisfaction_;
    }
};
Сделав поле satisfaction_ защищенным, мы слегка нарушаем инкапсуляцию класса Person — к состоянию Человека кроме него самого теперь имеют доступ его наследники. Если в будущем вы захотите от этого поля избавиться или изменить его тип, потребуется внести изменения во все подклассы, которые с этим полем напрямую взаимодействуют.
На диаграмме классов защищенные данные и методы помечаются символом #:

Если вы не единственный пользователь класса Person, лучше сделать члены-данные базового класса приватными и для доступа к состоянию использовать защищённые set-методы. Так будет легче защитить код дочерних классов от возможных изменений базового класса:
class Person {
public:
    ...
    int GetSatisfaction() const { return satisfaction_; }
protected:
    int SetSatisfaction(int value) { satisfaction_ = value; }
private:
    int satisfaction_;
    int age_;
};

class Worker : public Person {
public:
    void Dance() override {
        Person::Dance();
        if (const int age = GetAge(); age > 30 && age < 40) {
            cout << "Oppa!" << endl;
            SetSatisfaction(GetSatisfaction() + 1);
        }
    }
    void Work() {
        SetSatisfaction(GetSatisfaction() - 1);
    }
};
Защищенный конструктор
Особое применение в C++ имеет защищенный конструктор. Он будет доступен лишь классам-наследникам, поэтому, используя его, создать экземпляр класса не получится. Если объявить конструкторы родительского класса защищёнными, можно запретить создание экземпляров данного класса и вместо этого создавать экземпляры его классов-наследников.
Например, нет особого смысла создавать в программе экземпляры класса Shape, ведь этот класс — слишком абстрактная сущность. Объявив конструктор Shape защищенным, сможете создавать в программе только экземпляры конкретных фигур, таких как окружности и прямоугольники:
class Shape {
public:
    ...
protected:
    // Этот конструктор доступен только классам-наследникам
    explicit Shape(Color color)
        : color_(color) {
    }
private:
    Color color_;
    ...
};

class Circle : public Shape {
public:
    Circle(double radius, Color color)
        : Shape(color)
        , radius_(radius) {
    }
    ...
private:
    double radius_;
    ...
};

int main() {
    Shape shape(Color::RED); // Ошибка компиляции - конструктор Shape недоступен
    Circle circle(10.0, Color::RED); // OK - экземпляр Circle имеет публичный конструктор
}
Деструкторы и наследование
В C++ для удаления объектов, которые созданы в динамической памяти с использованием оператора new, служит оператор delete. Помимо освобождения памяти, занимаемой объектом, он предварительно выполняет вызов деструктора удаляемого объекта:
Circle* circle = new Circle(Color::RED);
delete circle;
При публичном наследовании указатели и ссылки на дочерние классы могут приводиться к указателям и ссылкам на класс-родитель. Это даёт возможность единообразно взаимодействовать с подклассами, используя ссылку или указатель на их общего родителя:
// Функция DoSomething может обработать вектор указателей на любые фигуры
void DoSomething(const vector<Shape*>& shapes);

int main() {
    Circle* circle = new Circle(10, Color::RED);
    Rectangle* rectangle = new Rectangle(10, 20, Color::BLUE);
    vector<Shape*> shapes = {circle, rectangle};

    DoSomething(shapes);

    delete circle;
    delete rectangle;
}
Что произойдет, если попытаться удалить экземпляр класса-наследника, передав оператору delete указатель на базовый класс?
Shape* shape = new Circle(10, Color::RED);
delete shape; // Что произойдёт?
Когда оператор delete удаляет экземпляр класса-наследника через указатель на родительский класс, деструктор родителя должен быть виртуальным. Иначе оператор delete вызовет неопределённое поведение:
class Shape {
public:
    ...
    // Помечаем деструктор виртуальным. Компилятор сам сгенерирует тело деструктора
    virtual ~Shape() = default;
    /*
    virtual ~Shape() {
        // Также можно написать тело деструктора вручную
    }
    */
    ...
};

class Circle : public Shape { ... };

int main() {
    Shape* shape = new Circle(10, Color::RED);
    delete shape; // OK, так как деструктор Shape виртуальный
}
По умолчанию деструкторы, как и методы класса, невиртуальные. Это нужно, чтобы минимизировать накладные расходы при разрушении объекта или свести их к нулю, когда полями объекта будут типы с тривиальным деструктором. Тривиальный деструктор — деструктор, который не выполняет никаких действий.
Практически всегда сто́ит объявлять деструктор базового класса публичным и виртуальным. Так вы избежите проблем при удалении его наследников через указатель на базовый класс. Например когда в контейнере хранятся умные указатели на базовый класс иерархии:
class Shape {
public:
    virtual ~Shape() = default;
    ...
};

class Circle : public Shape { ... };
class Rectangle : public Shape { ... };

int main() {
    vector<unique_ptr<Shape>> shapes;
    shapes.emplace_back(make_unique<Circle>(10.0, Color::RED));
    shapes.emplace_back(make_unique<Rectangle>(10.0, 20.0, Color::BLUE));
    // Деструкторы unique_ptr корректно удалят фигуры через указатель на класс Shape
}
Если родительский класс не предназначен для полиморфного удаления и его экземпляры не будут создаваться напрямую, можно избежать накладных расходов, объявив деструктор родительского класса защищенным и не виртуальным. Так наследники этого класса будут защищены от полиморфного удаления через указатель на базовый класс.
Например, можно ввести класс PersonObserver , который человек использует для уведомления об изменении своего состояния. Класс Person не владеет своим наблюдателем, поэтому деструктор PersonObserver можно сделать защищенным не виртуальным:
class Person;

// Наблюдатель за состоянием человека
class PersonObserver {
public:
    // Этот метод вызывается, когда меняется состояние удовлетворённости человека
    virtual void OnSatisfactionChanged(Person& /*person*/, int /*old_value*/, int /*new_value*/) {
        // Реализация метода базового класса ничего не делает
    }

protected:
    // Класс PersonObserver не предназначен для удаления напрямую
    ~PersonObserver() = default;
};

class Person {
public:
    Person(const string& name, int age)
        : name_(name)
        , age_(age) {
    }

    int GetSatisfaction() const {
        return satisfaction_;
    }

    string GetName() const {
        return name_;
    }

    void SetObserver(PersonObserver* observer) {
        observer_ = observer;
    }

    virtual void Dance() {
        SetSatisfaction(satisfaction_ + 1);
    }

protected:
    void SetSatisfaction(int value) {
        if (satisfaction_ != value) {
            int old_satisfaction = satisfaction_;
            satisfaction_ = value;
            // Если у человека есть наблюдатель, сообщаем ему об изменении удовлетворённости
            if (observer_) {
                observer_->OnSatisfactionChanged(*this, old_satisfaction, satisfaction_);
            }
        }
    }

private:
    string name_;
    PersonObserver* observer_ = nullptr;
    int satisfaction_ = 100;
    int age_;
};
Сам PersonObserver не выполняет никаких действий при изменении удовлетворенности человека. Это просто основа для создания подклассов. Они и будут выполнять конкретные действия.

Так, например, класс Spy может выводить в cout сообщения об изменении удовлетворенности человека:
// Шпион
class Spy : public PersonObserver {
public:
    void OnSatisfactionChanged(Person& person, int old_value, int new_value) override {
        cout << person.GetName() << "'s satisfaction has changed from "s << old_value << " to "s << new_value << endl;
    }
};
Назначив шпиона наблюдателем, будем в курсе состояния человека:
int main() {
    Person person{"Ivan"s, 10};

    Spy spy;
    person.SetObserver(&spy);

    person.Dance();
}
Ivan's satisfaction has changed from 100 to 101
Если потребуется выполнить иные действия при изменении удовлетворенности человека, не нужно будет вносить изменения в класс Person. Достаточно создать новый класс-наследник PersonObserver и назначить его наблюдателем:
// Надсмотрщик за удовлетворённостью
class SatisfactionSupervisor : public PersonObserver {
public:
    void OnSatisfactionChanged(Person& person, int old_value, int new_value) {
        // Если уровень удовлетворённости упал слишком низко,
        // можно поднять его, вызвав person.Dance()
    }
};
Если класс не предназначен для наследования, можно объявить его финальным, используя ключевое слово final:
// Класс рациональных чисел самодостаточен и не предназначен для наследования
class Rational final {
    /* Деструктор можно не объявлять, так как Rational не выделяет динамическую память */
    ...
};

// Шаблонный класс SimpleVector также является самодостаточным классом и объявлен финальным
template <typename T>
class SimpleVector final {
public:
    // Объявляем деструктор публичным невиртуальным
    ~SimpleVector() {
        ...
    }
    ...
};

// Этот код не скомпилируется, так как класс Rational финальный
// class MyRational : public Rational { ... };
Подведем итоги.
Деструктор базового класса надо объявлять либо публичным виртуальным, либо защищенным невиртуальным. Это зависит от того, требуется ли полиморфное удаление классов-наследников через указатель на базовый класс.
Если класс не предназначен для наследования, не объявляйте в нём деструктор вообще, либо объявите публичным невиртуальным. Сам класс желательно объявить финальным.
Абстрактные классы. Разработка SVG-библиотеки
Класс Shape, который вы разработали раньше, в действительности представляет собой абстрактную сущность:
нет однозначного способа вычислить площадь Фигуры;
нет однозначного способа нарисовать Фигуру;
нет смысла создавать в программе экземпляры класса Фигура. Практическую пользу несут лишь конкретные фигуры вроде Окружностей и Прямоугольников.
Вы обошли эти трудности, возвращая 0 в качестве площади фигуры и строку "Shape" в качестве типа фигуры. Однако при этом есть риск забыть переопределить в подклассе виртуальный метод базового класса:
struct Point {
    double x, y;
};

class Shape {
public:
    virtual const string& GetType() const { return type_; }
    virtual double GetArea() const { return 0; }
private:
    static const string type_;
};
const string Shape::type_ = "Shape"s;

class Triangle : public Shape {
public:
    Triangle(Point p1, Point p2, Point p3);
    const string& GetType() const override { return type_; }
private:
    Point p1_, p2_, p3_;
    static const string type_;
};
const string Triangle::type_ = "Triangle"s;
В примере выше в классе Triangle не переопределен метод GetArea, поэтому метод вычисления площади будет возвращать 0, используя реализацию класса Shape:
int main() {
    Triangle t{{0, 0}, {10, 0}, {0, 10}};
    cout << t.GetArea() << endl; // Будет выведено 0.0
}
Виртуальные функции, для которых в данном классе нельзя дать осмысленное определение и которые должны быть переопределены в подклассах, можно объявить чисто виртуальными. Для этого напишите = 0 в объявлении функции:
class Shape {
public:
    virtual double GetArea() const = 0;
    virtual const string& GetType() const = 0;
    // Остальные методы Shape
};
Теперь при попытке создать экземпляр Triangle, не переопределив в нем метод GetArea, появится сообщение об ошибке:
prog.cc: In function 'int main()':
prog.cc:31:14: error: cannot declare variable 't' to be of abstract type 'Triangle'
   31 |     Triangle t{{0, 0}, {10, 0}, {0, 10}};
      |              ^
prog.cc:20:7: note:   because the following virtual functions are pure within 'Triangle':
   20 | class Triangle : public Shape {
      |       ^~~~~~~~
prog.cc:13:20: note:     'virtual double Shape::GetArea() const'
   13 |     virtual double GetArea() const = 0;
      |                    ^~~~~~~
Эта проблема обнаружится еще на стадии компиляции. Чтобы её устранить, надо реализовать недостающие чисто виртуальные методы.
В C++ класс, где объявлен хотя бы один чисто виртуальный метод, называется абстрактным. Абстрактным будет и класс, который не реализует хотя бы один чисто виртуальный метод своего родителя.
Абстрактные классы не предполагают создание своих экземпляров и предназначены для использования в качестве родительских или базовых классов.
Класс, не содержащий чисто виртуальных методов, называется конкретным. В программе можно создавать лишь экземпляры конкретных классов.
На диаграммах чисто виртуальные методы и абстрактные классы могут дополнительно выделяться курсивным шрифтом:

Абстрактные классы часто применяются при реализации паттерна проектирования «Шаблонный метод». В этом случае базовый абстрактный класс содержит метод, который задает каркас или шаблон алгоритма, состоящего из нескольких шагов. Конкретные подклассы должны переопределить чисто виртуальные методы, соответствующие определенным шагам этого алгоритма. Так базовый класс задаёт количество шагов и их порядок, а подклассы определяют детали реализации этих шагов.
Для примера рассмотрим класс CaffeineBeverage, который задает алгоритм приготовления кофейного напитка:
// Базовый класс, описывающий каркас приготовления абстрактного напитка с кофеином
class CaffeineBeverage {
public:
    // Шаблонный метод приготовления напитка
    void Prepare() {
        BoilWater();
        Brew();
        PourInCup();
        AddCondiments();
    }

    // Деструктор базового класса объявляем публичным виртуальным
    virtual ~CaffeineBeverage() = default;

private:
    void BoilWater() {
        cout << "Boiling water"sv << endl;  // Кипятим воду
    }
    void PourInCup() {
        cout << "Pouring into a cup"sv << endl;  // Наливаем в чашку
    }

    virtual void Brew() = 0;  // Завариваем

    virtual void AddCondiments() {  // Добавляем дополнения к напитку
        // Подклассы могут переопределить этот метод
    }
};
Метод Prepare задаёт шаблон алгоритма (отсюда паттерн и получил своё название) приготовления напитка:
Вскипятить воду.
Заварить напиток.
Перелить в чашку.
Добавить дополнения к напитку.
Первый и третий шаги класс CaffeineBeverage реализует самостоятельно и даёт своим подклассам возможность переопределить второй и четвёртый шаг. При этом метод Brew объявлен чисто виртуальным, то есть обязательным для реализации в подклассах, а метод AddCondiments может быть переопределен по мере необходимости.
Так как эти методы приватные, они недоступны для вызова подклассами напрямую. Но остаётся возможность их переопределить. Итак, только класс CaffeineBeverage может вызвать методы Brew и AddCondiments, при этом оставив своим подклассам возможность их переопределения.
Дочерние классы Coffee, Tea и Chifir реализуют шаги приготовления кофе, чая и чифиря соответственно:
// Описывает шаги, специфичные для приготовления кофе
class Coffee : public CaffeineBeverage {
    void Brew() override {
        cout << "Dripping coffee through filter"sv << endl;  // Процеживаем кофе сквозь фильтр
    }
    void AddCondiments() override {
        cout << "Adding sugar and milk"sv << endl;  // Добавляем сахар и молоко
    }
};

// Описывает шаги, специфичные для приготовления чая
class Tea : public CaffeineBeverage {
    void Brew() override {
        cout << "Steeping the tea bag"sv << endl;  // Погружаем чайный пакетик
    }

    void AddCondiments() override {
        cout << "Adding lemon"sv << endl;  // Добавляем лимон
    }
};

// Реализует шаги, специфичные для приготовления чифиря
class Chifir : public CaffeineBeverage {
    void Brew() override {
        cout << "Put 5 to 8 tea bags"sv << endl;
    }
    // Метод AddCondiments не переопределяем - не положено
};
Теперь, когда дочерние классы реализуют чисто виртуальные методы своего родителя, различные типы напитков можно готовить единообразно:
// Функция может готовить любые напитки, по рецепту, задаваемому классом CaffeineBeverage
void PrepareBeverages(const vector<unique_ptr<CaffeineBeverage>>& beverages) {
    for (const auto& beverage : beverages) {
        beverage->Prepare();
        cout << "-----"sv << endl;
    }
}

int main() {
    // Составляем набор напитков
    vector<unique_ptr<CaffeineBeverage>> beverages;
    beverages.emplace_back(make_unique<Tea>());
    beverages.emplace_back(make_unique<Coffee>());
    beverages.emplace_back(make_unique<Chifir>());

    // И готовим их
    PrepareBeverages(beverages);
}
Boiling water
Steeping the tea bag
Pouring into a cup
Adding lemon
-----
Boiling water
Dripping coffee through filter
Pouring into a cup
Adding sugar and milk
-----
Boiling water
Put 5 to 8 tea bags
Pouring into a cup
-----
Закрепите новые знания на практике и разработайте первую часть библиотеки для вывода SVG изображений.
Интерфейсы
Предельный случай абстрактного класса в C++ — это интерфейс, класс без членов-данных. Все его методы — чисто виртуальные.
Интерфейс не имеет ни состояния, ни поведения, поэтому на первый взгляд он может показаться бесполезным. На деле же это совсем не так. Интерфейс задает набор методов, которые должны быть у объекта, чтобы с ним взаимодействовать. Фактически интерфейс описывает протокол для работы с объектом, не конкретизируя, какой это должен быть объект.
В качестве аналогии интерфейса из реального мира можно привести интерфейс USB для подключения различных периферийных устройств к вычислительной технике. Требования к разъемам и протоколам передачи данных стандартизованы, что позволяет соединять друг с другом устройства разных производителей. В отсутствие стандартизации мы оказались бы в ситуации, когда устройства разных производителей несовместимы.
Рассмотрим для примера два интерфейса: Graphics и Drawable. Интерфейс Graphics объявляет набор методов для рисования графических примитивов, таких как отрезки прямых, кривые и эллипсы. Интерфейс Drawable объявляет метод Draw для рисования объекта на графическом устройстве, реализующем интерфейс Graphics:
// Интерфейс Graphics предоставляет методы для рисования графических примитивов
class Graphics {
public:
    virtual void MoveTo(Point p) = 0;
    virtual void LineTo(Point p) = 0;
    virtual void DrawEllipse(Point left_top, Point right_bottom) = 0;
    virtual void SetColor(Color color) = 0;
    // Прочие методы рисования графических примитивов
    // ...
};

// Интерфейс Drawable задаёт объекты, которые можно нарисовать с помощью Graphics
class Drawable {
public:
    virtual void Draw(Graphics& g) const = 0;
};
Интерфейсы Drawable и Graphics можно сравнить с «материнским» и «‎отцовским» разъёмами стандарта USB. В любое устройство с «материнским» разъёмом можно вставить устройство с «‎отцовским» разъёмом. Точно так же любой объект, реализующий интерфейс Drawable, сможет рисовать своё изображение на любом объекте, реализующем интерфейс Graphics.
На диаграмме классов интерфейсы отображаются подобно классам, с уточняющей пометкой <<Interface>>.

Про класс X, унаследованный от интерфейса Y, говорят: класс X реализует интерфейс Y.
Класс, наследующийся от Drawable, должен реализовать метод Draw, чтобы, используя переданный интерфейс Graphics, нарисовать своё изображение. Если этого не сделать, класс-наследник будет абстрактным. Иногда это то, что нужно. Например, объявив Фигуру объектом, который можно нарисовать, и не реализовав в ней метод Draw, потребуем от всех конкретных классов-наследников Фигуры реализовать этот метод:
// Класс Shape наследуется от Drawable, но не реализует метод Draw.
// Это должны будут сделать подклассы Shape
class Shape : public Drawable {
public:
    ...
    Color GetColor() const { return color_; }
    void SetColor(Color color) { color_ = color; }
private:
    Color color_;
};
На диаграмме классов отношение между интерфейсом и реализующим его классом обозначается пунктирной линией с треугольным наконечником, направленным к интерфейсу. Почти как при наследовании, только линия пунктирная:

Как видно из диаграммы, реализовывать интерфейс Drawable могут не только фигуры, но и любые другие классы. Например, котики:
class Rectangle : public Shape {
public:
    ...
    void Draw(Graphics& g) const override {
        g.SetColor(GetColor());
        g.MoveTo(left_top_);
        g.LineTo({left_top_.x + width_, left_top.y});
        g.LineTo({left_top_.x + width_, left_top.y + height_});
        g.LineTo({left_top_.x, left_top.y + height_});
        g.LineTo(left_top_);
    }
private:
    Point left_top_;
    double width_;
    double height_;
};

class Circle : public Shape {
public:
    ...
    void Draw(Graphics& g) const override {
        g.SetColor(GetColor());
        g.DrawEllipse(
            {center_.x - radius_, center_.y - radius_}, 
            {center_.x + radius_, center_.y + radius_});
    }
private:
    Point center_;
    double radius_;
};

// Котики тоже могут реализовывать интерфейс Drawable
class Cat : public Drawable {
public:
    void Draw(Graphics& g) const override {
        // Рисуем кота при помощи методов, доступных в интерфейсе Graphics
    }
};
Теперь, когда объекты умеют рисовать себя, используя интерфейс Graphics, можно создать функцию для рисования картины (picture) на графическом устройстве. Картину можно задать в виде вектора указателей на объекты, реализующие интерфейс Drawable:
void DrawPicture(const vector<const Drawable*>& picture, Graphics& g) {
    for (const Drawable* drawable : picture) {
        drawable->Draw(g);
    }
};
Интерфейс Graphics может иметь несколько реализаций, например:
BitmapGraphics — класс, позволяющий рисовать на растровом изображении в памяти компьютера. Полученное растровое изображение впоследствии можно сохранить в файл на диске.
Printer — класс для вывода изображения на принтер. Сначала изображение строится в памяти компьютера, а затем выводится на печать вызовом отдельного метода Print.

// Растровое изображение в памяти компьютера
class Bitmap {
public:
    Bitmap(int width, int height);
    ... 
};

// Класс для рисования на растровом изображении в памяти компьютера
class BitmapGraphics : public Graphics {
public:
    explicit BitmapGraphics(Bitmap& bitmap)
        : bitmap_(bitmap) {
    }

    /* Реализация методов Graphics */

private:
    Bitmap& bitmap_;
    /* прочие данные */
};

// Сохраняем растровое изображение в файл
void SaveToFile(const Bitmap& bmp, const string& file_name) { ... }

// Позволяет выводить изображение на принтер
class Printer : public Graphics {
public:
    ...
    // Реализация методов Graphics. Выполняет построение изображения в памяти компьютера
    void MoveTo(Point p) override { ... }
    void LineTo(Point p) override { ... }
    void DrawEllipse(Point left_top, Point right_bottom) { ... }
    void SetColor(Color color) { ... }

    // Выводит изображение, построенное в памяти, на печать
    void Print() { ... }
private:
    /* Данные, необходимые для хранения изображения в памяти и вывода его на печать */  
};
Далее остается сформировать картину из имеющихся фигур, напечатать на принтере и сохранить в файл:
int main() {
    // Создаём "картину" из Drawable объектов
    Circle circle{...};
    Rectangle rectangle{...};
    Cat cat{...};
    vector<const Drawable*> picture = {&circle, &rectangle, &cat};
    
    // Печатаем "картину" на принтере
    Printer printer;
    DrawPicture(picture, printer);
    printer.Print();

    // Рисуем "картину" на растровом изображении и сохраняем в файл
    Bitmap bmp(1024, 768);
    BitmapGraphics bitmapGraphics(bmp);
    DrawPicture(picture, bitmapGraphics);
    SaveToFile(bmp, "picture.png"s);
}
Проанализируем получившееся решение.
Введённый интерфейс Graphics позволил абстрагироваться от различий между рисованием на растровом изображении и выводом изображения на принтер. Код, который использует интерфейс Graphics, может рисовать, используя любые объекты, которые реализуют этот интерфейс. Создав классы, реализующие методы интерфейса Graphics с применением распространённых графических библиотек, таких как OpenGL, Direct3D, Vulkan или Metal, код сможет использовать функциональность этих библиотек, но не привязываться ни к одной из них.
Интерфейс Drawable позволил унифицировать рисование объектов. Любой объект, который поддерживает этот интерфейс, можно нарисовать на любом графическом устройстве, реализующем интерфейc Graphics.
Интерфейсы помогают наладить взаимодействие между объектами, у которых минимум информации друг о друге. Это позволяет создавать гибкие архитектуры. Работая с ними, можно заменять одни части программы без модификации других.
Помогают интерфейсы и при написании модульных тестов. Класс, который зависит от передаваемого извне интерфейса или абстрактного класса, легче протестировать, чем класс, зависящий от конкретных классов:
// Интерфейс, от которого зависит тестируемый класс
class Service {
public:
    virtual int DoSomething(int param) = 0;
protected:
    ~Service() = default;
};

// Класс, который требуется протестировать
class MyClass {
public:
    MyClass(Service& service)
        : service_(service) {
    }
    // Метод Run использует service_
    void Run() {
        ...
        int value = service_.DoSomething(42);
        ...
    }
private:
    Service& service_;
};

// Реализация сервиса. Может зависеть от других объектов
class RealService : public Service { ... };
Здесь класс MyClass зависит от некоторого объекта, реализующего интерфейс Service. RealService — класс, реализующий интерфейс Service, который может быть сложным сам по себе, требовать каких-то внешних зависимостей или предварительной настройки. Поэтому тестирование класса MyClass совместно с RealService может быть затруднено. Решение: создать Mock-объект (англ. mock — пародировать) — легковесный класс, который «прикидывается» Service-ом, реализуя интерфейс Service упрощенным способом, и в тестах использовать его вместо RealService:
// Тестовый дублёр, имитирует работу RealService, 
// возвращая заготовленные значения и запоминая параметры, с которыми вызываются его методы
struct MockService : public Service {
    int DoSomething(int param) override {
        // Запоминаем параметр метода
        this->param = param;
        // Возвращаем заранее заготовленный результат
        return return_value;
    }
    optional<int> param;
    int return_value = 0;
};

void TestMyClass() {
    // Создаём и настраиваем mock-объект
    MockService service;
    service.return_value = 10; // Имитируем возврат значения 10 из метода DoSomething

    // Создаём тестируемый объект
    MyClass my_obj(service);

    // Вызываем тестируемый метод
    my_obj.Run();
    // Проверяем, как my_obj использует service
    assert(service.param == 42);
    // ... прочие проверки
}
Таким образом, зависимость от интерфейса позволила протестировать класс MyClass изолированно от других классов.
Найдётся применение интерфейсам и в SVG-библиотеке. Пора браться за клавиатуру.
Множественное наследование
C++ поддерживает множественное наследование — наследование от более чем одного базового класса. Оно позволяет классу реализовывать несколько интерфейсов или использовать функциональность сразу нескольких родительских классов.
Рассмотрим на примере классов Cat и Fish. Рыбы и коты — животные Animal, поэтому их можно покормить. Кроме того, коты — существа, которые, в отличие от рыб, обладают методом Speak. Назовём интерфейс таких объектов Speakable.

Когда класс наследуется от нескольких классов, все его базовые классы перечисляются через запятую:
class Speakable {
public:
    virtual ~Speakable() = default;
    virtual void Speak() const = 0;
};

class Drawable {
public:
    virtual ~Drawable() = default;
    virtual void Draw() const = 0;
};

class Animal {
public:
    virtual ~Animal() = default;
    void Eat(string_view food) {
        cout << GetType() << " is eating "sv << food << endl;
        ++energy_;
    }
    virtual string GetType() const = 0;

private:
    int energy_ = 100;
};

// Рыба — и животное, и объект, который можно нарисовать
class Fish : public Animal, public Drawable {
public:
    string GetType() const override {
        return "fish"s;
    }
    void Draw() const override {
        cout << "><(((*>"sv << endl;
    }
};

// Кот — животное, он может говорить, и его можно нарисовать
class Cat : public Animal, public Speakable, public Drawable {
public:
    void Speak() const override {
        cout << "Meow-meow"sv << endl;
    }
    void Draw() const override {
        cout << "(^w^)"sv << endl;
    }
    string GetType() const override {
        return "cat"s;
    }
};
Благодаря публичному наследованию от класса Animal кошек и рыб можно покормить:
void Feed(Animal& animal) {
    animal.Eat("meat"sv);
}

int main() {
    Cat cat;
    Fish fish;

    // И кошка, и рыба — животные, поэтому их можно покормить
    Feed(cat);
    Feed(fish);
}
cat is eating meat
fish is eating meat
С кошкой можно поговорить:
void Talk(Speakable& speakable) {
    speakable.Speak();
}

int main() {
    Cat cat;
    Talk(cat);
}
Вывод:
Meow Meow
Что произойдет, если попробовать поговорить с рыбой? Выберите один ответ.

void Talk(Speakable& speakable) {
    speakable.Speak();
}

int main() {
    Fish fish;
    Talk(fish);
}.
Функция Talk принимает ссылку на Speakable. Класс Fish не унаследован от Speakable и не имеет оператора приведения к Speakable. Поэтому программа даже не скомпилируется.

И кошку, и рыбу можно нарисовать:
template <typename DrawableIterator>
void DrawPicture(DrawableIterator begin, DrawableIterator end) {
    for (; begin != end; ++begin) {
        const Drawable* drawable = *begin;
        drawable->Draw();
    }
}

int main() {
    Cat cat;
    Fish fish;

    // Рисование поддерживают и коты, и рыбы
    std::array<const Drawable*, 2> picture{&cat, &fish};
    DrawPicture(picture.begin(), picture.end());
}
Вывод программы:
(^w^)
><(((*>
Множественное наследование следует использовать аккуратно. В том числе чтобы не столкнуться с проблемой так называемого ромбовидного наследования. Оно возникает, когда родители производного класса имеют общего предка. Эта ситуация так называется, потому что иерархия классов похожа на ромб.
Для иллюстрации создадим класс CatFish, унаследованный от Cat и Fish. С архитектурной точки зрения так наследоваться неправильно: сом — это рыба, и к котам, кроме английского названия, никакого отношения не имеет. Но пример очень показательный.

На диаграмме получилось два «ромба», идущие по стрелкам наследования от CatFish к базовым классам Drawable и Animal.
Объявив класс CatFish, попробуем покормить получившуюся химеру:
class CatFish : public Cat, public Fish {
};

int main() {
    CatFish cat_fish;
    Feed(cat_fish);
}
Сразу столкнемся с ошибкой компиляции:
prog.cc: In function 'int main()':
prog.cc:77:18: error: 'Animal' is an ambiguous base of 'CatFish'
   77 |     Feed(cat_fish);
      |                  ^
Проблема в том, что класс CatFish унаследовал функциональность Animal дважды — от кота и от рыбы. При вызове Feed возникает неоднозначность в том, как мы хотим покормить сома — как рыбу или как кота. Будто у него две пищеварительные системы. Если нас устраивает наличие у сома двух ртов, явно укажем, по какой ветке наследования хотим выполнить приведение типа:
int main() {
    CatFish cat_fish;
    
    // Кормим сома сначала как кота
    Feed(static_cast<Cat&>(cat_fish));
    
    // Затем кормим сома как рыбу
    Feed(static_cast<Fish&>(cat_fish));

    // Также можно явно указать, какой из методов Eat() нужно вызвать
    cat_fish.Cat::Eat("milk");
}
cat is eating meat
fish is eating meat
cat is eating milk
Если с наличием у сома двух ртов ещё как-нибудь можно смириться, то рисование сома то как рыбы, то как кота, выглядит совсем уж дико. В C++ для решения этой проблемы можно использовать виртуальное наследование. Классы-родители, имеющие общего предка, должны наследоваться от этого предка виртуально. В данном случае Cat и Fish должны виртуально наследоваться от Animal и Drawable:
class Fish : public virtual Animal, public virtual Drawable { ... };

class Cat : public virtual Animal, public Speakable, public virtual Drawable { ... };
Теперь при наследовании от Cat и Fish класс CatFish будет иметь одну копию данных и методов их общих предков Animal и Drawable. Потребуется также явно переопределить методы Draw и GetType, ведь родительские классы Cat и Fish реализовали их по-разному, и нужно устранить эту неоднозначность:
class CatFish : public Cat, public Fish {
public:
    string GetType() const override {
        return "catfish"s;
    }
    void Draw() const override {
        // Рисуем сома несколько иначе, чем рыбу
        cout << "><(((*){"sv << endl;
    }
};
Теперь CatFish получился вполне жизнеспособным. Его можно покормить и нарисовать. При этом он может ещё и поддержать беседу, жалобно мяукая:
int main() {
    CatFish cat_fish;

    Feed(cat_fish);
    Talk(cat_fish);
    cat_fish.Draw();
}
catfish is eating meat
Meow-meow
><(((*){
Вот такой получился странный сом — дитя порочного союза родителей, имеющих общего предка. Инцест до добра не доводит.
Пример с классом CatFish — искусственный. Обычно при множественном наследовании избегают ромбовидных иерархий классов. Виртуальное наследование применяется в тех редких случаях, когда нужно устранить описанные проблемы ромбовидной иерархии.
Встречаются примеры и в стандартной библиотеке. В частности, класс std::basic_iostream, который является родителем для std::basic_stringstream и std::basic_fstream, виртуально наследуется от классов std::basic_istream и std::basic_ostream, имеющих общего предка.
Когда анализируете иерархии классов на предмет ромбовидного наследования, руководствуйтесь не геометрической формой иерархии, а наличием нескольких путей от класса-наследника до любого из его родителей.
На рисунке показаны две похожие внешне диаграммы классов. На диаграмме слева существуют два пути от класса E до родительского класса A. На диаграмме справа классы Y и Z имеют только по одному пути до любого из своих родителей.

Итак, поддержка множественного наследования — полезная возможность C++, позволяющая реализовывать несколько интерфейсов и наделять классы функциональностью сразу нескольких классов. Главное — старайтесь избегать ромбовидного наследования.
Настало время применить множественное наследование на практике и заодно добавить долгожданную поддержку цвета в SVG-библиотеку.
Да будет цвет!
В SVG-файле объекты, такие как круги, ломаные и тексты, поддерживают два типа цвета:
Цвет заливки внутренностей. Задаётся атрибутом fill. По умолчанию для цвета заливки используется значение black. Вот почему выводимые библиотекой изображения были чёрными.
Цвет контура фигур. Задаётся атрибутом stroke. По умолчанию используется значение none, означающее отсутствие контура.
Формат SVG поддерживает различные способы задания цвета. Вот некоторые из них:
Именованное значение цвета, например: red, green, blue.
Формат rgb, задающий значения интенсивностей красного, зелёного и синего компонента цвета в диапазоне от 0 до 255. Например: rgb(255,0,0).
Формат rgba, дополнительно задающий значение альфа-канала в диапазоне от 0.0 (абсолютно прозрачно) до 1.0 (абсолютно непрозрачно). Например: rgba(255,100,10,0.5).
Этот SVG-файл рисует несколько цветных кругов:
<?xml version="1.0" encoding="UTF-8" ?>
<svg xmlns="http://www.w3.org/2000/svg" version="1.1">
  <circle cx="50" cy="50" r="40" fill="grey" stroke="black"/>
  <circle cx="70" cy="70" r="30" fill="none" stroke="green"/>
  <circle cx="40" cy="40" r="30" fill="rgb(180,40,100)"/>
  <circle cx="100" cy="50" r="40" fill="rgba(255,255,0,0.5)"/>
</svg>

Сначала объявим тип Color в библиотеке svg как аналог типа string. Это поможет расширить способы задать цвет в будущих версиях библиотеки. Сразу же объявим константу NoneColor для упрощения задания цвета none:
namespace svg {
...
using Color = std::string;

// Объявив в заголовочном файле константу со спецификатором inline,
// мы сделаем так, что она будет одной на все единицы трансляции,
// которые подключают этот заголовок.
// В противном случае каждая единица трансляции будет использовать свою копию этой константы
inline const Color NoneColor{"none"};
...
}
Следующий вопрос, который нужно решить: как задать цвет заливки и обводки фигур. Заливкой и контуром обладают многие элементы SVG-файла, но не все. Например, элемент <image> не имеет заливки и обводки. Поэтому добавлять эти свойства в класс svg::Object не стоит.
Хорошее решение должно позволять выборочно добавлять свойства заливки и контура, а также ряд других свойств и при этом избегать дублирования кода.
Введем вспомогательный базовый класс svg::PathProps . Путь — представленный в виде последовательности различных контуров векторный объект, который будет содержать свойства, управляющие параметрами заливки и контура. Унаследовав от него классы Circle, Polyline и Text, мы сделаем их обладателями этих свойств.

namespace svg {
...
class PathProps {
public:
    void SetFillColor(Color fill_color);
    void SetStrokeColor(Color stroke_color);
    ...
};

class Circle : public Object, public PathProps { ... };
...
} // namespace svg

int main() {
    svg::Circle circle;
    circle.SetFillColor("red"s);
}
У такого способа есть один недостаток — отсутствует поддержка method chaining. Для устранения недостатка требуется возвращать из методов PathProps::Set* ссылку на текущий экземпляр правильного типа. Например, при вызове SetFillColor у класса Circle должна возвращаться ссылка Circle&. На помощь приходят шаблоны: класс PathProps должен принимать шаблонный параметр Owner, который задает тип класса, владеющего этими свойствами.
namespace svg {
...
template <typename Owner>
class PathProps {
public:
    Owner& SetFillColor(Color color) {
        fill_color_ = std::move(color);
        return AsOwner();
    }
    Owner& SetStrokeColor(Color color) {
        stroke_color_ = std::move(color);
        return AsOwner();
    }

protected:
    ~PathProps() = default;

    // Метод RenderAttrs выводит в поток общие для всех путей атрибуты fill и stroke
    void RenderAttrs(std::ostream& out) const {
        using namespace std::literals;

        if (fill_color_) {
            out << " fill=\""sv << *fill_color_ << "\""sv;
        }
        if (stroke_color_) {
            out << " stroke=\""sv << *stroke_color_ << "\""sv;
        }
    }

private:
    Owner& AsOwner() {
        // static_cast безопасно преобразует *this к Owner&,
        // если класс Owner — наследник PathProps
        return static_cast<Owner&>(*this);
    }

    std::optional<Color> fill_color_;
    std::optional<Color> stroke_color_;
};

// Наследованием от PathProps<Circle> мы «‎сообщаем» родителю,
// что владельцем свойств является класс Circle
class Circle : public Object, public PathProps<Circle> {
    ...
    void RenderObject(const RenderContext& context) const {
        auto& out = context.out;
        out << "<circle cx=\""sv << center_.x << "\" cy=\""sv << center_.y << "\" "sv;
        out << "r=\""sv << radius_ << "\" "sv;
        // Выводим атрибуты, унаследованные от PathProps
        RenderAttrs(context.out);
        out << "/>"sv;
    }
    ...
};
...
} // namespace svg

int main() {
    svg::Circle c;
    // Теперь method chaining работает
    c.SetFillColor("red"s).SetStrokeColor("black").SetCenter({10, 10});
}


Защищенный метод PathProps::RenderAttrs используется в дочерних классах для вывода атрибутов, общих для всех наследников PathProps. В нашем случае это атрибуты fill и stroke.
Интересный прием, когда дочерний класс наследуется от шаблона и передает свой тип в качестве шаблонного параметра, имеет название Curiously Recurring Template Pattern (CRTP). Это один из инструментов обеспечения статического полиморфизма. В нашем случае он позволил элегантно реализовать method chaining без дублирования кода.
Когда наследование — не лучший выбор
Наследование и виртуальные методы — основные способы поддержать полиморфизм времени выполнения в C++. Вы объявляете виртуальную функцию в базовом классе и переопределяете её в наследниках. После этого можно работать с классами-наследниками через интерфейс их общего предка.
Реализуется такой функционал за счет хранения дополнительной информации с каждым объектом, который имеет виртуальные методы. В примере ниже класс B отличается от класса A только наличием виртуальных методов.
class A {
    int32_t i;
};

class B {
    virtual ~B() = default;
    int32_t i;
};

int main() {
    using namespace std;
    cout << "sizeof(int32_t): "sv << sizeof(int32_t) << endl;
    cout << "sizeof(A): "sv << sizeof(A) << endl;
    cout << "sizeof(B): "sv << sizeof(B) << endl;
}
Один из возможных вариантов вывода:
sizeof(int32_t): 4
sizeof(A): 4
sizeof(B): 16
Конкретные цифры могут быть другими, но размер класса B всегда будет больше размера класса A.
Небольшие накладные расходы (размером примерно с указатель) на хранение каждого объекта — малая цена за функциональные возможности, которые мы получаем. Тем не менее у полиморфизма, основанного на использовании виртуальных функций, есть недостатки.
Проиллюстрируем их на гиперболизированном примере программы, решающей квадратное уравнение. Квадратное уравнение может иметь одно из следующих решений:
Два действительных корня. Программа должна вывести оба корня.
Один действительный корень. Программа должна вывести этот корень.
Действительных корней нет. Программа должна сообщить об этом.
struct Solution {
    virtual ~Solution() = default;
    virtual void Print() const = 0;
};

struct OneRoot : Solution {
    OneRoot(double v)
        : value(v) {
    }
    void Print() const override {
        cout << "One root: "sv << value << endl;
    }
    double value;
};

struct TwoRoots : Solution {
    TwoRoots(double v1, double v2)
        : value1(v1)
        , value2(v2) {
    }
    void Print() const override {
        cout << "Two roots: "sv << value1 << " and "sv << value2 << endl;
    }
    double value1, value2;
};

struct NoRoots : Solution {
    void Print() const override {
        cout << "No roots"sv << endl;
    }
};

// Возвращает корни квадратного уравнения вида ax^2+bx+c=0
unique_ptr<Solution> SolveQuadraticEquation(double a, double b, double c) {
    if (a == 0) {
        throw invalid_argument("Not a quadratic equation"s);
    }

    const double d = b * b - 4 * a * c;
    if (d > 0) {
        const double sqrt_d = sqrt(d);
        const double dbl_a = 2.0 * a;
        return make_unique<TwoRoots>((-b - sqrt_d) / dbl_a, (-b + sqrt_d) / dbl_a);
    } else if (d == 0) {
        return make_unique<OneRoot>(-b / (2 * a));
    } else {
        return make_unique<NoRoots>();
    }
}

int main() {
    const auto solution = SolveQuadraticEquation(1, 0, -4);
    solution->Print();
}
Проанализируйте код программы, решающей квадратное уравнение, и выберите верные утверждения.
Runtime-полиморфизм с std::variant
std::variant — стандартный шаблонный класс, который в один момент времени хранит значение одного из заданных типов либо, в случае ошибки, не содержит значения. Список типов, которые может хранить variant, задается в его шаблонных параметрах.

Перечень возможных типов решений квадратного уравнения известен заранее. Поэтому можно объявить тип Solution, который использует variant для объединения типов:
std::monostate — означает, что действительных корней нет.
double — хранит один действительный корень.
std::pair<double, double> — хранит два действительных корня.
#include <cmath>
#include <variant>

using namespace std;
using Solution = variant<monostate, double, pair<double, double>>;
Тогда функцию SolveQuadraticEquation можно переписать так:
// Возвращает корни квадратного уравнения вида ax^2+bx+c=0
Solution SolveQuadraticEquation(double a, double b, double c) {
    if (a == 0) {
        throw invalid_argument("Not a quadratic equation"s);
    }

    const double d = b * b - 4 * a * c;
    if (d > 0) {
        const double sqrt_d = sqrt(d);
        const double dbl_a = 2.0 * a;
        return pair{(-b - sqrt_d) / dbl_a, (-b + sqrt_d) / dbl_a};
    } else if (d == 0) {
        return -b / (2 * a);
    } else {
        return monostate{};
        // либо return {}, так как monostate - самый первый элемент списка типов Solution
    }
}
Эта версия функции не использует динамическое выделение памяти ни явно, ни косвенно: функция возвращает результат по значению, а объекты variant не выделяют память в куче. variant занимает объем памяти, достаточный, чтобы вместить любой из своих шаблонных параметров плюс служебные данные о том, какой из типов в данный момент хранится.
int main() {
    cout << "sizeof(Solution)"sv << sizeof(Solution) << endl;
}
Размер типа Solution составляет 24 байта: 16 байт достаточно для хранения типа pair<double,double>, имеющего наибольший размер, плюс 8 байт на служебные данные и обеспечение нужного выравнивания.
Когда программа решит квадратное уравнение, она должна вывести в stdout результат, зависящий от типа значения, которое в данный момент хранится в variant. Если классическое решение использовало для этих целей виртуальные методы, то variant предлагает другой способ поддержки полиморфизма времени выполнения:
Создайте Посетитель — класс или структуру с перегруженными операциями () для каждого типа, которые могут содержаться в variant. Название «Посетитель»‎ связано с паттерном проектирования «Посетитель». Этот паттерн работает по схожему принципу.
Вызовите функцию std::visit, передав в неё Посетителя и переменную типа variant. Эта функция вызовет операцию () Посетителя, принимающую тот тип, который в данный момент хранится внутри variant.
Сравните, насколько компактнее можно реализовать вывод корней квадратного уравнения по сравнению с версией, использовавшей наследование:
struct SolutionPrinter {
    void operator()(monostate) const {
        cout << "No roots"sv << endl;
    }
    void operator()(double root) const {
        cout << "One root: "sv << root << endl;
    }
    void operator()(pair<double, double> roots) const {
        cout << "Two roots: "sv << roots.first << " and "sv << roots.second << endl;
    }
};

int main() {
    const auto solution = SolveQuadraticEquation(1, 0, -4);
    // Функция visit вызовет оператор (), принимающий тот тип,
    // который хранится в variant
    visit(SolutionPrinter{}, solution);
}
Здесь код, который обрабатывает хранящееся внутри variant значение, выполняется Посетителем. В классическом решении класс Solution содержал метод Print, неотделимый от типа Solution.
Функция visit ещё во время компиляции требует, чтобы Посетитель содержал операции (), способные принять все хранящиеся в variant типы. Если это не так, программа не скомпилируется:
struct IncompleteSolutionPrinter {
    /* Забыли перегрузить оператор () для monostate */
    void operator()(double root) const {
        cout << "One root: "sv << root << endl;
    }
    void operator()(pair<double, double> roots) const {
        cout << "Two roots: "sv << roots.first << " and "sv << roots.second << endl;
    }
};

int main() {
    const auto solution = SolveQuadraticEquation(1, 0, -4);

    // Эта строчка не скомпилируется (хотя сообщение об ошибке будет весьма мудрёным)
    visit(IncompleteSolutionPrinter{}, solution);
}
Чтобы добавить новое действие над корнями, в классическом решении требовалось добавить новый виртуальный метод в базовый класс, а здесь нужно создать нового Посетителя. Так действия  изолируются друг от друга.
Это иллюстрирует структура GreatestRootGetter, которая находит значение наибольшего из корней квадратного уравнения:
struct GreatestRootGetter {
    optional<double> operator()(monostate) const { return nullopt; }
    optional<double> operator()(double root) const { return root; }
    optional<double> operator()(pair<double, double> roots) const {
        return std::max(roots.first, roots.second);
    }
};

int main() {
    const auto solution = SolveQuadraticEquation(1, 0, -4);

    if (const auto greatest_root = visit(GreatestRootGetter{}, solution)) {
        cout << "Greatest root: "sv << *greatest_root << endl;
    } else {
        cout << "No roots"sv << endl;
    }
}
Класс-посетитель может обладать состоянием и использовать его в своей работе. Например, вместо вывода корней в cout Посетитель может выводить их в поток вывода, на который ссылается одно из его полей:
struct OstreamSolutionPrinter {
    ostream& out;

    void operator()(monostate) const {
        out << "No roots"sv << endl;
    }
    void operator()(double root) const {
        out << "One root: "sv << root << endl;
    }
    void operator()(pair<double, double> roots) const {
        out << "Two roots: "sv << roots.first << " and "sv << roots.second << endl;
    }
};

int main() {
    const auto solution = SolveQuadraticEquation(1, 0, -4);

    ostringstream strm;
    // Выводим в поток strm
    visit(OstreamSolutionPrinter{strm}, solution);
    cout << strm.str();
}
Обработать значение внутри variant можно, не создавая класс-посетитель. Для этого вместо Посетителя передайте универсальную — или обобщенную — лямбда-функцию. Она принимает параметр типа auto. В следующем примере печать корней уравнения выполняется функциями PrintRoots, вызываемыми из такой лямбда-функции:
void PrintRoots(ostream& out, monostate) {
    out << "No roots"sv << endl;
}
void PrintRoots(ostream& out, double root) {
    out << "One root: "sv << root << endl;
}
void PrintRoots(ostream& out, pair<double, double> roots) {
    out << "Two roots: "sv << roots.first << " and "sv << roots.second << endl;
}

int main() {
    const auto solution = SolveQuadraticEquation(1, 0, -4);

    ostringstream strm;
    visit(
        [&strm](auto value) {
            // Это универсальная лямбда-функция (generic lambda).
            // Внутри неё нужная функция PrintRoots будет выбрана за счёт перегрузки функций.
            PrintRoots(strm, value);
        }, solution);

    cout << strm.str();
}
Можно обойтись вообще без посетителей и функции visit, когда достаточно обработать некоторые частные случаи:
int main() {
    const auto solution = SolveQuadraticEquation(1, 0, -4);

    // Проверка типа при помощи std::holds_alternative().
    if (holds_alternative<double>(solution)) {
        // Когда мы убедились, что variant сейчас хранит double,
        // можно смело брать это значение при помощи std::get.
        cout << "One root: "sv << get<double>(solution) << endl;
    }

    // ---------------

    // std::get_if вернёт указатель на значение нужного типа 
    // либо nullptr, если variant содержит значение другого типа.
    if (const auto* roots = get_if<pair<double, double>>(&solution)) {
        assert(roots != nullptr);
        cout << "Two roots: "sv << roots->first << " and "sv << roots->second << endl;
    } else {
        assert(roots == nullptr);
    }

    // ---------------

    try {
        // Если solution хранит значение типа double, получим ссылку на него.
        const double& root = get<double>(solution);
        cout << "One root: "sv << root << endl;
    } catch (const bad_variant_access& e) {
        // Либо словим std::bad_variant_access в случае ошибки.
        cout << e.what() << endl;
    }
}
Достоинства variant:
Позволяет передавать объекты по значению без динамического выделения памяти;
Облегчает добавление новых «‎методов»‎ — вы просто создаете структуру или класс с перегруженными операциями ();
Нет необходимости вводить базовый класс. variant позволяет объединять не связанные друг с другом классы и примитивные типы данных;
При небольшом количестве типов внутри variant затраты на вызов нужной операции Посетителя функцией visit могут быть ниже, чем при использовании виртуальных функций.
Недостатки variant:
Типы, объединяемые в variant, должны быть известны на этапе компиляции. Поэтому с ним не получится создать систему подключаемых модулей, которые еще называются плагинами. С использованием наследования система, поддерживающая расширение, просто объявляет интерфейсы, а классы плагинов эти интерфейсы реализуют.
Затрудняется добавление новых типов, так как это означает изменение сигнатуры типа, основанного на variant, и требует модификации всех посетителей.
Неэффективное использование памяти, когда размеры типов сильно различаются. Если один из типов внутри variant занимает четыре байта, а другой — 100, итоговый тип будет иметь размер не менее 100 байт.
Для каждой операции требуется создать отдельного Посетителя. Без должного контроля эти посетители будут разбросаны по различным файлам программы.
Передача параметров Посетителю требует бо́льших усилий по сравнению с обычными методами, так как функция std::visit не предоставляет для этого никаких средств.
При большом количестве типов внутри variant затраты на вызов нужной операции Посетителя могут быть выше, чем затраты на вызов виртуального метода.
Попробуем variant в действии. И начнём с улучшения SVG-библиотеки.
Динамическое приведение типа
Оператор static_cast можно использовать для приведения типов в пределах иерархии классов. Однако это может привести к проблемам.
Рассмотрим иерархию классов животных — мышей и ежей:
class Animal {
public:
    virtual ~Animal() = default;

protected:
    int health_ = 10;
};

class Mouse : public Animal {
public:
    void EatCheese() {
        health_ += 10;
    }
};

class Hedgehog : public Animal {
public:
    void Sing(string song) {
        sing_history_.push_back(move(song));
    }

private:
    vector<string> sing_history_;
};
Дальнейшие действия будут развиваться как в следующем анекдоте:
Пришли мыши к Сове: «Сова, ты старая и мудрая. Скажи, что нам сделать, чтобы коты перестали нас ловить и есть». Сова говорит им: «Мышки, станьте ежиками. Если вы будете колючими, вас никто не съест!»
Обалдевшие от восторга мыши побежали домой, там опомнились и вернулись к сове. «Сова, расскажи, — а как нам стать ежиками?». А Сова им в ответ: «Я решаю важные стратегические вопросы! С тактикой разбирайтесь сами!»
void PlayWithAnimal(Animal& animal) {
    Mouse& mouse = static_cast<Mouse&>(animal);
    cout << "Mouse eats cheese"sv << endl;
    mouse.EatCheese();

    Hedgehog& hedgehog = static_cast<Hedgehog&>(animal);
    cout << "Hedgehog sings songs"sv << endl;
    hedgehog.Sing("Jingle Bells"s);
    hedgehog.Sing("Yesterday"s);
}

int main() {
    Mouse mouse;
    PlayWithAnimal(mouse);
    cout << "---"sv << endl;
    Hedgehog hedgehog;
    PlayWithAnimal(hedgehog);
}
Программа скомпилируется без ошибок, однако при запуске упадёт:
Mouse eats cheese
Hedgehog sings songs
Segmentation fault
Оператор static_cast можно безопасно использовать только чтобы привести тип вверх по иерархии классов. Безопасно привести тип вниз по иерархии этим оператором можно, только если известно, что объект перед вами — это экземпляр нужного класса или его наследника. В противном случае попытка обратиться к объекту по ссылке или указателю несовместимого типа приведет к неопределенному поведению.
Внутри функции PlayWithAnimal неизвестно, какого типа объект был передан в функцию, ведь она способна принять любого наследника Animal.
Для безопасного приведения типа в пределах иерархии классов служит оператор dynamic_cast. В отличие от static_cast, он во время выполнения программы проверяет возможность преобразования, используя информацию о типе объекта. Такое преобразование выполняется медленнее, чем static_cast, зато безопаснее.
dynamic_cast использует служебную информацию, хранящуюся в объекте, чтобы установить его тип и выполнить нужное преобразование. Исходный класс или структура должны иметь хотя бы одну виртуальную функцию. Достаточно будет даже виртуального деструктора.
При приведении одного типа указателя к указателю другого типа возвращается ненулевой указатель, если преобразование типа возможно. В противном случае — нулевой:
void PlayWithAnimal(Animal& animal) {
    if (Mouse* mouse = dynamic_cast<Mouse*>(&animal)) {
        cout << "Mouse eats cheese"sv << endl;
        mouse->EatCheese();
    }

    if (Hedgehog* hedgehog = dynamic_cast<Hedgehog*>(&animal)) {
        cout << "Hedgehog sings songs"sv << endl;
        hedgehog->Sing("Jingle Bells"s);
        hedgehog->Sing("Yesterday"s);
    }
}

int main() {
    Mouse mouse;
    PlayWithAnimal(mouse);
    cout << "---"sv << endl;
    Hedgehog hedgehog;
    PlayWithAnimal(hedgehog);
}
Теперь функция PlayWithAnimal сможет во время выполнения программы определить, с каким объектом имеет дело, и выполнить над ним допустимые действия:
Mouse eats cheese
---
Hedgehog sings songs
dynamic_cast позволяет преобразовывать не только указатели, но и ссылки. Так как в C++ нет понятия нулевой ссылки, при невозможности преобразования выбрасывается исключение std::bad_cast:
void PlayWithAnimal2(Animal& animal) {
    try {
        // При невозможности приведения ссылки к нужному типу 
        // оператор dynaic_cast выбросит исключение std::bad_cast
        Mouse& mouse = dynamic_cast<Mouse&>(animal);
        cout << "Mouse eats cheese"sv << endl;
        mouse.EatCheese();
    } catch (const std::bad_cast&) {
    }

    try {
        Hedgehog& hedgehog = dynamic_cast<Hedgehog&>(animal);
        cout << "Hedgehog sings songs"sv << endl;
        hedgehog.Sing("Jingle Bells"s);
        hedgehog.Sing("Yesterday"s);
    } catch (const std::bad_cast&) {
    }
}
Приведение типа ссылок с использованием dynamic_cast менее предпочтительно, чем  приведение типа указателей. Исключения должны сигнализировать о внештатной ситуации, а не управлять выполнением программы.
dynamic_cast позволяет выполнить над объектом действия, зависящие от его типа. Но везде, где возможно, отдавайте предпочтение полиморфизму и виртуальным методам. Это делает код более гибким и не нарушает инкапсуляцию.
Для рисования фигур можно использовать dynamic_cast, не вводя чисто виртуальный метод Draw в базовом классе:
class Shape { ... };
class Rectangle : public Shape { ... };
class Circe : public Shape { ... };

void DrawShape(const Shape& shape, Canvas& canvas) {
    if (const Rectangle* r = dynamic_cast<const Rectangle*>(&shape)) {
        // рисуем прямоугольник r на холсте canvas
    } else if (const Circle* c = dynamic_cast<const Circle*>(&shape)) {
        // рисуем окружность c на холсте canvas
    }
}
Это неудачное решение с точки зрения архитектуры. Публичное наследование подразумевает поддержку полиморфизма, и от функции DrawShape ожидается, что она способна принимать любых наследников класса Shape. Создав новый класс-наследник Shape, легко забыть внести изменения в функцию DrawShape и множество других мест, использующих dynamic_cast. Из-за этого DrawShape будет работать неправильно, и в целом поддержка программы станет сложнее. Поэтому dynamic_cast нежелательно использовать в библиотеках — пользователи библиотеки лишаются возможности наследоваться от библиотечных классов, ведь о них код библиотеки ничего не знает.
Тем не менее бывают ситуации, когда dynamic_cast полезен:
Если нет возможности добавить виртуальный метод в базовый класс. Например, из-за того, что это класс сторонней библиотеки. В таком случае вы можете использовать dynamic_cast, выполнить приведение типа к нужным классам-наследникам и вызвать специфичные для них операции.
dynamic_cast позволяет запросить у объекта нужный интерфейс и в случае успеха использовать его.
Другие виды наследования
Публичное наследование — основной вид наследования в C++. Оно выражает отношение «является» между классами. Его ещё называют наследованием интерфейса, так как публичные методы и данные родителя остаются публичными в классе-наследнике:
class Parent {...};
// Класс Child публично унаследован от класса Parent
class Child : public Parent {...};

// Структуры по умолчанию используют публичное наследование
struct ChildStruct : Parent {...};
Однако C++ поддерживает и другие, реже используемые виды наследования.
Приватное наследование
Приватное наследование — второй по распространенности вид наследования в C++. При приватном наследовании публичные и защищенные методы и данные родителя становятся приватными в классе-наследнике. Они доступны только классу-наследнику, но не коду вне его.
Поэтому приватное наследование называется наследованием реализации — класс-наследник унаследовал детали реализации своего родителя, но не его интерфейс. Наследник предоставляет свой набор публичных методов, с которым должны работать клиенты.
Чтобы обозначить приватное наследование в объявлении класса, перед именем родительского класса пишут ключевое слово private. По умолчанию классы в C++ наследуются приватно, а структуры — публично:
class Parent {
public:
    void ParentMethod();
    ...
};
// Класс Child приватно унаследован от Parent
class Child : private Parent {
public:
    void ChildMethod() {
        ParentMethod(); // Классу Child доступны публичные и защищённые методы родителя
    }
};
// Тоже приватное наследование: классы по умолчанию наследуются приватно
class Child1 : Parent {...};

int main() {
    Child child;
    
    // Не скомпилируется: в классе Child метод ParentMethod стал приватным
    // child.ParentMethod();

    // Класс Child предоставляет свой набор публичных методов
    child.ChildMethod();
}
Приватное наследование выражает другой тип отношений между классами — «реализован посредством». Класс-наследник реализован посредством родительского класса.
С точки зрения кода вне класса приватное наследование неотличимо от композиции. По сравнению с композицией наследование создаёт более тесную связь между классами. В результате будет больше причин для изменений производного класса при изменении класса-родителя. Поэтому используйте композицию везде, где возможно, а приватное наследование — там, где это необходимо.
Вот несколько ситуаций, когда приватное наследование имеет преимущества перед композицией:
При приватном наследовании класс-наследник может переопределить виртуальные методы своего родителя. При композиции для этого нужно создать вспомогательный класс, предопределяющий виртуальные методы, и использовать его как часть производного класса:
class Base {
public:
    // Реализует паттерн «Шаблонный метод»
    void Algorithm() {
        Step1();
        Step2();
    }
private:
    virtual void Step1(); // Этот шаг может быть переопределён подклассами
    void Step2();
};
// --- Приватное наследование ---
class Child : Base {
public:
    void DoSomething() {
        Algorithm();
    }
private:
    void Step1() override {...} // Переопределяем шаг алгоритма
};
// --- Композиция ---
class Composite {
public:
    void DoSomething() {
        child_.Algorithm();
    }

private:
    class Child : public Base {
    private:
        void Step1() override {...}
    };

    Child child_; // Используем Child посредством композиции
};
В приватном наследовании классу-наследнику доступны не только публичные методы родителя, но и защищенные. При композиции защищенные методы используемого класса недоступны.
При наследовании, включая приватное, класс-наследник может «вынести»‎ публичные или защищенные данные и методы класса в свою публичную область видимости. Так, приватное наследование от std::variant позволяет упростить реализацию класса json::Node.
Решение, использующее композицию:
namespace json {
...
class Node final {
public:
    using Value = std::variant<std::nullptr_t, Array, Dict, bool, int, double, std::string>;
    Node() = default;
    Node(std::nullptr_t);
    Node(int val);
    Node(double val);
    Node(std::string val);
    Node(Array val);
    Node(Dict val);
    Node(bool val);

    bool IsInt() const {
        return std::holds_alternative<int>(value_);
    }
    int AsInt() const {
        using namespace std::literals;
        if (!IsInt()) {
            throw std::logic_error("Not an int"s);
        }
        return std::get<int>(value_);
    }
    ...
private:
    Value value_;
};
...
} // namespace json
Унаследовав json::Node приватно от std::variant, мы сделаем недоступным неявное преобразование типа Node к типу variant. А с использованием using сделаем доступными конструкторы класса variant, включая универсальный конструктор из содержащихся в JSON значений:
namespace json {
...
class Node final
    : private std::variant<std::nullptr_t, Array, Dict, bool, int, double, std::string> 
{
public:
    // Делаем доступными все конструкторы родительского класса variant
    using variant::variant;

    bool IsInt() const {
        return std::holds_alternative<int>(*this);
    }
    int AsInt() const {
        using namespace std::literals;
        if (!IsInt()) {
            throw std::logic_error("Not an int"s);
        }
        return std::get<int>(*this);
    }
    ...
};
...
} // namespace json
При приватном наследовании становится недоступным преобразование класса-наследника к классу-родителю. Неявное или явное преобразование вызовет ошибку компиляции. Приватное наследование — это не наследование интерфейса!
class Parent {...};
class Child : Parent {...};

void PlayWithParent(Parent& parent);

int main() {
    Child c;
    PlayWithParent(c); // Ошибка компиляции
    Parent* p = dynamic_cast<Parent*>(&c); // Ошибка компиляции
}
Это ограничение касается кода за пределами класса-наследника. Так как классу-наследнику доступен интерфейс родителя, внутри методов класса разрешено преобразование типа вверх по иерархии классов.
Для иллюстрации такой полезной возможности рассмотрим класс Timer, который о каждом тике уведомляет своего наблюдателя, реализующего интерфейс TimerObserver:
class TimerObserver {
public:
    // Вызывается при очередном тике таймера
    virtual void OnTick(int counter) = 0;

protected:
    // Timer не владеет своими наблюдателями,
    // поэтому TimerObserver не предназначен для полиморфного удаления
    ~TimerObserver() = default;
};

class Timer {
public:
    Timer() = default;

    // Запрещаем копирование и присваивание Timer, чтобы не думать о том, 
    // должна ли копия таймера уведомлять наблюдателей таймера-оригинала
    Timer& operator=(const Timer&) = delete;
    Timer(const Timer&) = delete;

    void SetObserver(TimerObserver* observer) {
        observer_ = observer;
    }

    void Tick() {
        ++tick_counter_;
        if (observer_) {
            observer_->OnTick(tick_counter_);
        }
    }

private:
    TimerObserver* observer_ = nullptr;
    int tick_counter_ = 0;
};
Класс TimerDisplay приватно реализует интерфейс TimerObserver. В своём конструкторе TimerDisplay регистрирует себя в роли наблюдателя переданного ему таймера, а в деструкторе отписывается от получения уведомлений. Если бы использовалось публичное наследование, внешний код мог бы вызвать метод OnTick напрямую у TimerDisplay или подписать его на получение событий у другого таймера:
// Благодаря приватному наследованию от Timer, преобразование TimerDisplay к TimerObserver
// будет недоступно вне класса TimerDisplay.
class TimerDisplay : TimerObserver {
public:
    TimerDisplay(Timer& timer, string name)
        : timer_(timer)
        , name_(move(name))  //
    {
        // Внутри методов класса доступно преобразование к TimerObserver,
        // поэтому TimerDisplay* будет преобразована к типу TimerObserver*
        timer_.SetObserver(this);
    }

    // Запрещаем копирование и присваивание, чтобы не задумываться о том,
    // должна ли копия TimerDisplay в своём деструкторе сбрасывать наблюдателя у timer_
    TimerDisplay(const TimerDisplay&) = delete;
    TimerDisplay& operator=(const TimerDisplay&) = delete;

    ~TimerDisplay() {
        // Надо отписаться от своего таймера, чтобы после уничтожения этого объекта таймер не пытался его уведомить
        timer_.SetObserver(nullptr);
    }

private:
    void OnTick(int counter) override {
        cout << name_ << " tick #"sv << counter << endl;
    }
    Timer& timer_;
    string name_;
};
Создадим пару таймеров. Дисплей, подключенный к таймеру, будет отображать текущее количество тиков при каждом вызове метода Tick.
int main() {
    Timer timer1;
    Timer timer2;

    TimerDisplay display1{timer1, "Timer 1"s};
    timer1.Tick();
    timer2.Tick();
    {
        cout << "---"sv << endl;
        TimerDisplay display2{timer2, "Timer 2"s};
        timer1.Tick();
        timer2.Tick();
        cout << "---"sv << endl;
        // При выходе из блока объект display2 отпишется от получения уведомлений от timer2
    }

    timer1.Tick();
    timer2.Tick();
}
Счетчик тиков второго таймера будет отображаться только внутри вложенного блока функции main:
Timer 1 tick #1
---
Timer 1 tick #2
Timer 2 tick #2
---
Timer 1 tick #3
Защищенное наследование
При защищённом наследовании публичные и защищенные данные и методы родителя становятся защищенными в классе-наследнике. Поэтому наследники производного класса также смогут ими пользоваться:
class Parent {
public:
    void ParentMethod();
    virtual void ParentMethod2();
};

class Child : protected Parent {
public:
    void ChildMethod() {
        ParentMethod();
    }
};

// Внук
class GrandChild : public Child {
public:
    void GrandChildMethod() {
        ParentMethod(); // Внукам также доступны методы Parent
    }
};
Необходимость в этом экзотическом виде наследования на практике встречается крайне редко.
Итоги
На иллюстрации показано сравнение областей видимости при использовании различных вариантов наследования:

Используйте публичное наследование, чтобы выразить между классами отношение «‎является»‎.
Используйте приватное наследование, чтобы выразить отношение «реализован с помощью»‎ и использовать в одном классе функциональность родительского класса, не раскрывая внешнему коду его интерфейс. По возможности отдавайте предпочтение композиции и используйте приватное наследование, когда композиция не позволяет эффективно реализовать задуманное.
Защищенное наследование — экзотическая форма наследования и применяется крайне редко.
Какой тип наследования следует использовать, чтобы реализовать класс Apple на основе класса Fruit? Выберите один вариант ответа.
Наследование и исключения
В C++ можно использовать классы и структуры в качестве объектов исключений. У этого есть ряд преимуществ.
Во-первых, классы исключений могут нести дополнительную информацию о возникшей проблеме. Например:
имя файла, при чтении которого возникла проблема;
введённые пользователем данные, не прошедшие проверку;
имя файла и номер строки исходного кода, в котором произошло выбрасывание исключения.
Во-вторых, обработчик catch, отлавливающий исключения родительского класса, может поймать исключения любых его публичных наследников. То есть приведение типа вверх по иерархии классов работает и при поиске подходящего обработчика исключений.
На диаграмме показана иерархия классов стандартных исключений C++. Некоторые стандартные классы исключений на ней для экономии места не показаны.

Все стандартные классы исключений прямо или косвенно наследуются от класса std::exception. Когда нужно однотипно обрабатывать все стандартные исключения, можно написать единственный обработчик catch, отлавливающий std::exception:
#include <iostream>
#include <stdexcept>

using namespace std;

int main() {
    try {
        throw std::invalid_argument("Invalid argument"s);
    } catch (const std::exception& e) {
        std::cout << e.what() << std::endl;
    }
}
Когда требуется особая реакция на определенный тип исключений, следует разместить его обработчик catch до обработчика более общего типа.
Это иллюстрирует программа, которая определяет, четное ли очередное введенное пользователем число. Ввод заканчивается, когда пользователь введёт exit или нажмите комбинацию клавиш Ctrl+Z (на Windows) либо Ctrl+D (на Linux или MacOS) для ввода символа конца файла:
#include <iostream>
#include <stdexcept>
#include <string>
#include <string_view>

using namespace std;

int main() {
    while (true) {
        cout << "Enter a number, or type 'exit' to quit"sv << endl;
        string str;
        if (!getline(cin, str) || (str == "exit"sv)) {
            break;
        }

        try {
            size_t idx;
            // stoi может выбросить out_of_range либо invalid_argument
            int number = std::stoi(str, &idx);
            if (idx != str.length()) {
                throw invalid_argument("invalid argument"s);
            }

            cout << number;
            if (number % 2 == 0) {
                cout << " is even"sv << endl;
            } else {
                cout << " is odd"sv << endl;
            }
        } catch (const out_of_range&) {
            cout << "An overflow occurred when converting '"sv << str << "' to number"sv << endl;
        } catch (const invalid_argument&) {
            cout << '\'' << str << "' is not a valid number"sv << endl;
        } catch (const exception& e) {
            // Сюда можем попасть, например, при нехватке памяти
            cout << "Unexpected exception: "sv << e.what() << endl;
        } catch (...) {
            // В этот обработчик попасть не должны никогда, так как в программе
            // не выбрасываются исключения, не унаследованные от std::exception.
            // Тем не менее это на практике возможно, особенно когда используется
            // код сторонних библиотек.
            cout << "Unknown error"sv << endl;
        }
    }
}
Функция stoi преобразует строки в числа. Она может выбросить исключения двух типов:
out_of_range, если в строке записано число, не помещающееся в диапазон int;
invalid_argument, если в начале строки не записано число.
Чтобы программа сообщала об этих ошибках по-разному, их обработчики должны быть размещены до обработчика исключений exception, способного поймать любые стандартные исключения:
Enter a number, or type 'exit' to quit
10
10 is even
Enter a number, or type 'exit' to quit
13
13 is odd
Enter a number, or type 'exit' to quit
1235s
'1235s' is not a valid number
Enter a number, or type 'exit' to quit
hello
'hello' is not a valid number
Enter a number, or type 'exit' to quit
99999999999999999999999999999
An overflow occurred when converting '99999999999999999999999999999' to number
Enter a number, or type 'exit' to quit
exit
При создании собственных классов исключений рекомендуется наследоваться от std::exception или одного из его подклассов. Это позволит перехватывать пользовательские типы исключений вместе со стандартными.
Пример:
class UserValidationError : public invalid_argument {
public:
    UserValidationError(bool invalid_login, bool invalid_password)
        : invalid_argument(MakeErrorMessage(invalid_login, invalid_password))
        , invalid_login_(invalid_login)
        , invalid_password_(invalid_password) {
    }

    bool IsUserNameValid() const {
        return !invalid_login_;
    }

    bool IsPasswordValid() const {
        return !invalid_password_;
    }

private:
    static std::string MakeErrorMessage(bool invalid_login, bool invalid_password) {
        if (invalid_login && invalid_password) {
            return "Invalid login and password"s;
        } else if (invalid_login) {
            return "Invalid login"s;
        } else if (invalid_password) {
            return "Invalid password"s;
        } else {
            return "Unknown user registration error"s;
        }
    }

    bool invalid_login_ = false;
    bool invalid_password_ = false;
};

struct User {
    string login;
    string password;
};

void ValidateUser(const User& user) {
    const bool login_is_valid = !user.login.empty();
    const bool password_is_valid = user.password.length() > 10;
    if (!login_is_valid || !password_is_valid) {
        throw UserValidationError(!login_is_valid, !password_is_valid);
    }
}

int main() {
    try {
        ValidateUser({"CoolHacker"s, "qwerty"s});
    } catch (const std::exception& e) {
        cout << e.what() << endl;
    } catch (...) {
        cout << "Unknown exception"sv << endl;
    }
}
Invalid password
При наследовании классов исключений важно использовать публичное наследование. Другие типы наследования сделают невозможным перехват исключений дочернего класса в обработчике базового.
Так, если забыть указать публичное наследование при объявлении UserValidationError, преобразование от UserValidationError к std::exception станет недоступным:
class UserValidationError : invalid_argument { ... };
Тогда обработчик catch (const std::exception& e) не будет считаться подходящим обработчиком для исключения UserValidationError. Это исключение будет поймано в обработчике catch (...), который выведет менее информативное сообщение:
Unknown exception
Классы исключений следует ловить по ссылке — возможно, константной, — а не по значению. Это позволит избежать срезки, когда исключение дочернего класса попадает в обработчик исключения родительского класса. Обработчик, принимающий исключение родительского класса по значению, будет иметь дело не с оригинальным объектом исключения, а с копией части объекта, который относится к родительскому классу.
Рассмотрим срезку на иерархии животных:
class Animal {
public:
    virtual ~Animal() = default;
    virtual string GetType() const {
        return "unknown"s;
    }
};

class Mouse : public Animal {
public:
    string GetType() const override {
        return "mouse"s;
    }
};

class Frog : public Animal {
public:
    string GetType() const override {
        return "frog"s;
    }
};

int main() {
    try {
        throw Mouse();
    } catch (Animal animal) {
        cout << "Caught an animal of type: "sv << animal.GetType() << endl;
    }
}
Обработчик catch ловит исключения типа Animal по значению. Перед передачей мыши в обработчик исключения она будет частично скопирована в новый объект, имеющий тип Animal. В результате обработчик исключения поймает не мышонка, не лягушку, а неведому зверушку:
Caught an animal of type: unknown
Компилятор может предупредить о том, что полиморфный класс Animal отлавливается по значению:
prog.cc: In function 'int main()':
prog.cc:25:21: warning: catching polymorphic type 'class Animal' by value [-Wcatch-value=]
   25 |     } catch (Animal animal) {
      |                     ^~~~~~ 
После исправления обработчика исключения на ловлю по ссылке, проблема будет решена:
int main() {
    try {
        throw Mouse();
    } catch (const Animal& animal) {
        cout << "Caught an animal of type: "sv << animal.GetType() << endl;
    }
}
Будет пойман мышонок:
Caught an animal of type: mouse
Подведем итоги.
Используйте наследование, чтобы построить иерархии классов исключений. Это позволит одинаково обрабатывать исключения одной и той же категории.
Делайте собственные классы исключений прямыми или косвенными наследниками std::exception. Это позволит обрабатывать пользовательские типы ошибок наравне со стандартными.
Сначала размещайте обработчики конкретных типов исключений, а потом — более общих. Так вы сможете обработать нужные типы ошибок особо. С остальными ошибками справится универсальный обработчик.
Всегда используйте публичное наследование при объявлении классов исключений. Ловите исключения по ссылке, а не по значению, чтобы избежать срезки.
Что выведет эта программа?
#include <iostream>
#include <stdexcept>
#include <string>
#include <string_view>

using namespace std;

int main() {
    try {
        cout << stoi("hello"s) << "!" << endl;
    } catch (const exception&) {
        cout << "exception"sv << endl;
    } catch (const out_of_range&) {
        cout << "out_of_range"sv << endl;
    } catch (const invalid_argument&) {
        cout << "invalid_argument"sv << endl;
    } catch (...) {
        cout << "unknown"sv << endl;
    }
}
