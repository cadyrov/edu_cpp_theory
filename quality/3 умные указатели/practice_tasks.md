# Практические задания по умным указателям

## Задание 1: Простой RAII-обертка для файла
**Описание:** Создай класс `FileRAII`, который использует `unique_ptr` с пользовательским deleter для автоматического закрытия файла.

**Требования:**
- Конструктор принимает имя файла
- Автоматическое закрытие при разрушении
- Метод `isOpen()` для проверки состояния
- Метод `write(const std::string& data)` для записи

**Тесты:**
1. Файл открывается корректно
2. Файл автоматически закрывается при выходе из области видимости
3. `isOpen()` возвращает правильное состояние
4. Запись данных работает корректно
5. Попытка работы с закрытым файлом безопасна
6. Перемещение объекта работает корректно
7. Копирование запрещено (не компилируется)
8. После перемещения исходный объект пустой
9. Можно создать пустой объект (без файла)
10. Deleter вызывается при reset()

---

## Задание 2: Умная фабрика объектов
**Описание:** Реализуй фабрику, которая создает объекты разных типов и возвращает `unique_ptr` на базовый класс.

**Требования:**
- Базовый класс `Shape` с виртуальными методами
- Производные классы `Circle`, `Rectangle`, `Triangle`
- Фабричная функция `CreateShape(ShapeType type, params...)`
- Перечисление `ShapeType`

**Тесты:**
1. Создание круга с корректными параметрами
2. Создание прямоугольника с корректными параметрами
3. Создание треугольника с корректными параметрами
4. Полиморфный вызов методов
5. Автоматическое удаление объектов
6. Виртуальный деструктор работает корректно
7. Некорректный тип возвращает nullptr
8. Перемещение созданных объектов
9. Хранение в контейнерах
10. Использование auto для выведения типа

---

## Задание 3: Система кэширования с shared_ptr
**Описание:** Создай систему кэширования, где несколько клиентов могут совместно использовать кэшированные объекты.

**Требования:**
- Класс `Cache<T>` с методами `get(key)` и `put(key, value)`
- Объекты удаляются из кэша автоматически когда никто их не использует
- Метод `size()` возвращает количество элементов в кэше

**Тесты:**
1. Добавление объекта в кэш
2. Получение объекта из кэша
3. Совместное использование объекта несколькими клиентами
4. Автоматическое удаление неиспользуемых объектов
5. Размер кэша изменяется корректно
6. Получение несуществующего ключа возвращает nullptr
7. Перезапись существующего ключа
8. Очистка кэша
9. Кэш работает с разными типами объектов
10. Thread-safety не требуется, но объекты удаляются правильно

---

## Задание 4: Реализация Observer pattern с weak_ptr
**Описание:** Реализуй паттерн Observer, где наблюдатели используют `weak_ptr` для избежания циклических ссылок.

**Требования:**
- Класс `Subject` с методами `attach(observer)`, `detach(observer)`, `notify()`
- Класс `Observer` с методом `update(message)`
- Автоматическое удаление "мертвых" наблюдателей

**Тесты:**
1. Подписка наблюдателя на события
2. Уведомление всех наблюдателей
3. Отписка наблюдателя
4. Автоматическое удаление разрушенных наблюдателей
5. Уведомление не влияет на "мертвых" наблюдателей
6. Несколько наблюдателей получают уведомления
7. Subject может существовать без наблюдателей
8. Наблюдатель может подписаться на несколько Subject
9. Уведомления приходят в правильном порядке
10. Очистка всех наблюдателей работает корректно

---

## Задание 5: Реализация идиомы Pimpl
**Описание:** Создай класс `NetworkClient`, использующий идиому Pimpl для сокрытия деталей реализации.

**Требования:**
- Публичный интерфейс в заголовочном файле
- Детали реализации в .cpp файле
- Поддержка перемещения
- Методы `connect()`, `send()`, `receive()`, `isConnected()`

**Тесты:**
1. Создание объекта без включения деталей реализации
2. Вызов публичных методов работает корректно
3. Перемещение объекта сохраняет состояние
4. После перемещения источник становится пустым
5. Деструктор вызывается корректно
6. Состояние подключения сохраняется
7. Методы можно вызывать после перемещения
8. Пустой объект безопасно использовать
9. Копирование запрещено (если не реализовано)
10. Приватные данные действительно скрыты

---

## Задание 6: Copy-on-Write строка
**Описание:** Реализуй класс `CoWString`, использующий оптимизацию Copy-on-Write для экономии памяти.

**Требования:**
- Конструкторы от `const char*` и `std::string`
- Методы чтения: `size()`, `operator[]`, `c_str()`
- Методы записи: `operator[]`, `append()`, `operator+=`
- Копирование должно быть дешевым

**Тесты:**
1. Создание строки из C-строки
2. Создание строки из std::string
3. Копирование не создает новые данные сразу
4. Чтение не вызывает копирование
5. Первая модификация создает копию
6. Модификация единственного владельца не создает копию
7. Несколько копий используют одни данные до модификации
8. Метод append работает корректно
9. Оператор += работает корректно
10. Размер возвращается правильно

---

## Задание 7: Умный пул объектов
**Описание:** Создай пул объектов, который переиспользует созданные объекты для улучшения производительности.

**Требования:**
- Класс `ObjectPool<T>` с методами `acquire()` и `release()`
- Автоматический возврат в пул при разрушении
- Максимальный размер пула
- Фабричная функция для создания новых объектов

**Тесты:**
1. Получение объекта из пустого пула создает новый
2. Возврат объекта в пул
3. Повторное получение возвращает переиспользованный объект
4. Превышение максимального размера не сохраняет объект
5. Автоматический возврат при разрушении
6. Пул работает с разными типами объектов
7. Очистка пула работает корректно
8. Размер пула не превышает максимум
9. Статистика использования пула
10. Thread-safety не требуется

---

## Задание 8: Граф с умными указателями
**Описание:** Реализуй направленный граф, используя `shared_ptr` для узлов и `weak_ptr` для обратных ссылок.

**Требования:**
- Класс `Node` с данными и списком соседей
- Класс `Graph` для управления узлами
- Методы `addNode()`, `addEdge()`, `removeNode()`, `removeEdge()`
- Обход графа (DFS/BFS)

**Тесты:**
1. Добавление узлов в граф
2. Создание ребер между узлами
3. Удаление узлов не нарушает граф
4. Удаление ребер работает корректно
5. Обход в глубину находит все достижимые узлы
6. Обход в ширину работает корректно
7. Циклы в графе не вызывают утечек памяти
8. Граф корректно очищается при разрушении
9. Изолированные узлы удаляются автоматически
10. Поиск пути между узлами

---

## Задание 9: Иерархия виджетов GUI
**Описание:** Создай иерархию виджетов для GUI, где родитель владеет детьми через `unique_ptr`, а дети ссылаются на родителя через сырой указатель.

**Требования:**
- Базовый класс `Widget` с виртуальными методами
- Производные классы `Window`, `Button`, `Label`
- Методы `addChild()`, `removeChild()`, `getParent()`
- Автоматическая очистка при разрушении родителя

**Тесты:**
1. Создание иерархии виджетов
2. Добавление дочерних виджетов
3. Удаление дочерних виджетов
4. Автоматическое разрушение детей при разрушении родителя
5. Получение ссылки на родителя
6. Перемещение виджета от одного родителя к другому
7. Поиск виджета по имени в иерархии
8. Вызов виртуальных методов работает корректно
9. Обход всех детей рекурсивно
10. Проверка принадлежности виджета иерархии

---

## Задание 10: Менеджер ресурсов с автоматической загрузкой
**Описание:** Создай менеджер ресурсов, который автоматически загружает и выгружает ресурсы по мере необходимости.

**Требования:**
- Класс `ResourceManager<T>` с методами `load()`, `unload()`, `get()`
- Автоматическая выгрузка неиспользуемых ресурсов
- Подсчет ссылок на ресурсы
- Кэширование загруженных ресурсов

**Тесты:**
1. Загрузка ресурса по имени
2. Получение уже загруженного ресурса из кэша
3. Автоматическая выгрузка при отсутствии ссылок
4. Явная выгрузка ресурса
5. Подсчет активных ресурсов
6. Очистка всех ресурсов
7. Обработка ошибок загрузки
8. Перезагрузка ресурса
9. Статистика использования ресурсов
10. Ограничение максимального количества ресурсов в памяти 