Умный указатель unique_ptr
Работа с сырыми указателями и динамической памятью в C++ требует внимательности. Иначе можно столкнуться с целым рядом ошибок:
утечки памяти,
использование неинициализированного указателя,
повторный вызов delete с указателем на ранее удаленный объект,
использование непарной версии оператора delete.
Управляться с динамической памятью становится еще труднее, когда дело доходит до написания кода, устойчивого к исключениям.
Взгляните на программу, которая создает и удаляет двоичное дерево поиска:
template <typename T>
struct TreeNode {
    T value;
    TreeNode* left = nullptr;
    TreeNode* right = nullptr;
};

template <typename T>
void DeleteTree(TreeNode<T>* node) {
    if (!node) {
        return;
    }
    DeleteTree(node->left);
    DeleteTree(node->right);
    delete node;
}

int main() {
    using T = TreeNode<int>;
    // Здесь гарантируется порядок вычислений: new T{4}, new T{7}, new T{6, ...}
    T* root1 = new T{6, new T{4}, new T{7}}; // Здесь спрятались возможные утечки памяти
    DeleteTree(root1);
}
В каких операторах new выбрасывание исключения приведет к утечкам памяти
new T{6, ...}
new T{4}
new T{7}
Верно. Перед созданием узла 7 в динамической памяти будет создан узел 4. Исключение, выброшенное при создании узла 7, приведёт к утечке памяти, которую занимает узел 4.

К счастью, стандартная библиотека предоставляет классы умных указателей. Умный указатель — это класс, синтаксически похожий на обычный указатель: у него есть операторы * и -> для доступа к объекту или ресурсу. При этом умный указатель управляет временем жизни объекта, своевременно удаляя его, что сильно упрощает работу с объектами в динамической памяти.
Этот урок посвящён указателю std::unique_ptr — одному из наиболее часто используемых умных указателей.
unique_ptr — умный указатель, который единолично владеет объектом в динамической памяти. Это значит, что в программе в один момент времени может быть только один экземпляр unique_ptr, ссылающийся на конкретный объект в динамической памяти. Поэтому этот указатель и называют уникальным. Внутри unique_ptr содержится обычный указатель на объект в динамической памяти:
Создать unique_ptr очень просто. Для этого нужно подключить заголовочный файл <memory> и передать конструктору unique_ptr указатель на объект в куче:
#include <iostream>
#include <memory>
#include <string>

using namespace std;

struct Cat {
    Cat(const string& name, int age)
        : name_(name)
        , age_(age)  //
    {
        cout << name_ << " cat was created"s << endl;
    }
    const string& GetName() const noexcept {
        return name_;
    }
    int GetAge() const noexcept {
        return age_;
    }
    ~Cat() {
        cout << name_ << " cat was destroyed"s << endl;
    }
    void Speak() const {
        cout << "Meow!"s << endl;
    }

private:
    string name_;
    int age_;
};

int main() {
    Cat* cat = new Cat("Tom"s, 2);
    unique_ptr<Cat> p{cat};
    p->Speak();
    // Деструктор p удалит кота
}
Сразу после создания unique_ptr начнет владеть переданным ему объектом и при выходе из области видимости автоматически удалит его, вызвав оператор delete:
Tom cat was created
Meow!
Tom cat was destroyed
В отличие от сырых указателей, unique_ptr всегда проинициализирован — он либо ссылается на существующий объект, либо равен nullptr:
int main() {
    unique_ptr<Cat> p;
    assert(!p);
}
Удобнее и безопаснее сразу после создания объекта в куче не иметь дела с «сырыми» указателями вообще и сразу получить  unique_ptr, ссылающийся на созданный объект. Для этого служит шаблонная функция std::make_unique, которая создаёт объект в куче, передавая конструктору объекта свои аргументы, и возвращает unique_ptr. Ключевое слово auto помогает более кратко объявить переменную-указатель:
int main() {
    // Создает экземпляр класса Cat в куче и возвращает владеющий unique_ptr
    auto cat = make_unique<Cat>("Tom"s, 2);
    cat->Speak();
}
Таким образом, unique_ptr позволяет создать объект в куче и управлять временем его жизни, вообще не используя операторы new и delete.
Чтобы получить значение сырого указателя на объект, есть метод get:
Cat* raw_cat_ptr = new Cat("Tom"s, 2);
unique_ptr<Cat> cat_ptr{raw_cat_ptr};

// get() возвращает сырой указатель на объект
assert(cat_ptr.get() == raw_cat_ptr);
В отличие от обычного указателя, unique_ptr — move-only тип. Нельзя создать копию unique_ptr, ведь тогда объектом владели бы несколько unique_ptr, что недопустимо. Вместо копирования разрешается перемещать указатель на объект от одного unique_ptr к другому. После перемещения старый указатель теряет право владения объектом и начинает указывать на nullptr. Право владения переходит к новому указателю:
int main() {
    // Создает экземпляр Cat в куче и возвращает unique_ptr
    auto cat1 = make_unique<Cat>("Tom"s, 2);
    // Следующая строчка не скомпилируется - экземпляры unique_ptr копировать нельзя
    unique_ptr<Cat> cat2 = cat1;

    // Зато можно перемещать.
    auto cat2 = std::move(cat1);

    assert(!cat1);
    assert(cat2);
}
Часто значение unique_ptr перемещается из одной области видимости в другую. Следующая функция создаёт кота в динамической памяти и возвращает unique_ptr, владеющий этим котом:
// Функция создаёт двухлетних котов с заданным именем
unique_ptr<Cat> CreateCat(const string& name) {
    return make_unique<Cat>(name, 2);
}
unique_ptr можно принимать в качестве параметров функций и методов. Обычно unique_ptr передаётся по rvalue-ссылке:
class Witch {
public:
    explicit Witch(const string& name)
        : name_(name) {
    }

    void SetCat(unique_ptr<Cat>&& cat) noexcept {
        cat_ = std::move(cat);
    }
    unique_ptr<Cat> ReleaseCat() noexcept {
        return std::move(cat_);
    }

private:
    string name_;
    unique_ptr<Cat> cat_;
};
Так, можно создать кота, передать его волшебнице, а потом забрать у неё обратно. При этом перемещении участвует только указатель. Сам объект, сколь бы «‎тяжелым» он ни был, никуда не перемещается и не копируется:
int main() {
    Witch witch("Hermione"s);
    witch.SetCat(CreateCat("Crookshaks"s));
    auto cat = witch.ReleaseCat();
    cat->Speak();

    Witch witch2("Ginny Weasley"s);
    witch2.SetCat(std::move(cat));
    assert(!cat);
}
Класс, который содержит поле типа unique_ptr, также по умолчанию становится move-only — компилятор не может сгенерировать для него конструктор копирования и копирующий оператор присваивания:
int main() {
    Witch witch("Hermione"s);
    // Ошибка компиляции - в классе Witch удалены конструктор копирования и оператор копирующего присваивания
    // Witch witch2(witch);

    // Зато можно переместить
    Witch witch2(std::move(witch));
}
Если компилятор не смог сгенерировать конструктор копирования и оператор присваивания для класса Witch — не беда. Нужно лишь немного помочь ему в этом.
Идиома Pimpl
Кроме управления временем жизни объектов указатель unique_ptr применяется в идиоме pImpl. Это прием программирования, который скрывает от пользователей класса детали его реализации.
Рассмотрим применение этой идиомы на примере класса Транспортный Справочник:
transport_catalogue.h:
#pragma once
#include "geo.h"

struct Stop {
    ...
};

struct Bus {
    ...
};

class TransportCatalogue {
public:
    void AddStop(std::string name, geo::Coordinates pos);
    ...
private:
    std::deque<Bus> buses_;
    std::deque<Stop> stops_;
    ...
};
transport_catalogue.cpp:
#include "transport_catalogue.h"

void TransportCatalogue::AddStop(std::string name, geo::Coordinates pos) {
    ...
}
...
В этом классе есть публичные методы, доступные клиентам, а также приватные данные и методы, которые определяют детали реализации класса. Под клиентами класса подразумеваются части программы, которые этот класс используют.
Если отредактировать тело метода AddStop, система сборки вашей IDE увидит, что изменен лишь файл transport_catalogue.cpp, и перекомпилирует только его. Однако если вы решите добавить приватное поле или изменить сигнатуру приватного метода, для этого вам придется отредактировать заголовочный файл transport_catalogue.h. Среда разработки перекомпилирует все .cpp файлы, которые прямо или косвенно подключают изменённый заголовочный файл. Если в вашей программе много мест, в которых подключается transport_catalogue.h, много времени будет тратиться на перекомпилирование при любом изменении этого заголовочного файла.
Проект состоит из следующих файлов:

Укажите, какие файлы с расширением .cpp потребуется перекомпилировать после внесения изменений в файл transport_catalogue.h?
Идиома Pimpl позволяет перенести содержимое приватной части класса из заголовочного файла в .cpp-файл, тем самым спрятав приватную часть от клиентов вашего класса. Для этого нужно, чтобы в приватной части класса содержались не сами данные, а «непрозрачный» указатель на них:
transport_catalogue.h:
class TransportCatalogue {
public:
    TransportCatalogue();
    ~TransportCatalogue(); // Деструктор здесь важен. Его тело будет в .cpp файле

    void AddStop(std::string name, geo::Coordinates pos);
    /* Прочие публичные методы */
private:
    // Объявляем вложенную структуру Impl, не раскрывая здесь её содержимое
    struct Impl;
    // unique_ptr автоматически удалит связанные с классом данные
    std::unique_ptr<Impl> impl_;
};
Теперь приватная часть класса содержит только указатель на структуру Impl. Чтобы объявить такой указатель, достаточно знать лишь что Impl — структура. Полностью эту структуру следует разместить в .cpp файле. Таким образом, детали реализации класса оказались скрыты.
В конструкторе класса нужно проинициализировать поле impl_.
transport_catalogue.cpp:
#include "transport_catalogue.h"

// Структура TransportCatalogue::Impl содержит детали реализации класса TransportCatalogue
struct TransportCatalogue::Impl {
    void AddStop(std::string name, geo::Coordinates pos) {
        ...
    }

private:
    std::deque<Bus> buses_;
    std::deque<Stop> stops_;
    ...
};

TransportCatalogue::TransportCatalogue()
    : impl_(std::make_unique<Impl>()) {
}

// Деструктор следует разместить внутри .cpp-файла, где видно содержимое структуры Impl
// Так как нас устраивает деструктор, сгенерированный компилятором, вместо
// тела деструктора напишем = default.
TransportCatalogue::~TransportCatalogue() = default;

void TransportCatalogue::AddStop(std::string name, geo::Coordinates pos) {
    impl_->AddStop(std::move(name), pos);
}
Рассмотрим ключевые шаги для реализации идиомы Pimpl:
В приватной части класса объявляем структуру Impl, но не описываем её содержимое. Этого достаточно, чтобы внутри класса можно было использовать указатель на структуру.
В приватной части класса размещаем unique_ptr<Impl>. Умный указатель сам позаботится о том, чтобы освободить память, которую занимает структура Impl.
Вложенную структуру Impl объявляем в начале .cpp-файла. Важно указать полное имя структуры вместе с именем вашего класса. В нашем примере структура имеет имя TransportCatalogue::Impl.
В конструкторе проинициализируем поле impl_ функцией make_unique. Если у класса было несколько конструкторов, для каждого из них в структуре Impl может понадобиться создать конструктор с соответствующим набором параметров.
Деструктор unique_ptr вызывает операцию delete для удаления объекта. Операция delete требует, чтобы тип удаляемого объекта был известен компилятору. Поэтому в классе TransportCatalogue нужно явным образом задать деструктор, а тело деструктора написать в .cpp-файле, ниже объявления структуры Impl.
В публичных методах класса заменяем обращения к полям класса на обращения к полям и методам структуры Impl.
Если в классе были приватные методы, их следует перенести внутрь структуры Impl.
Таким образом, объявление класса TransportCatalogue будет содержать только интерфейс (публичную часть) класса, а все детали реализации переедут в невидимую структуру Impl внутри .cpp-файла. Указатель на эту структуру будет единственным полем класса. Любые изменения в реализации класса не затронут заголовочный файл, а значит не потребуют перекомпилировать файлы программы, кроме изменившегося.
Кроме ускорения сборки идиома Pimpl помогает авторам библиотек сохранять совместимость ABI при выпуске новой версии библиотеки. Чтобы приложение использовало обновлённую библиотеку, не нужно пересобирать приложение. Достаточно установить в системе новую версию библиотеки.
Вместе с приватной областью класса идиома Pimpl прячет внутрь .cpp-файла ещё и директивы #include, подключаются сторонние библиотеки.



От widget.h зависит только my_class.cpp, но не my_class.h
Перемещение объектов, использующих идиому Pimpl
Так как внутри класса, использующего идиому Pimpl, содержится unique_ptr на неполный тип, компилятор не сможет сгенерировать для него перемещающий конструктор и операцию присваивания — для этого в месте, где используются эти операции, компилятору должно быть видно содержимое структуры Impl. Поэтому вы можете столкнуться с ошибками компиляции в коде, подобном этому:
main.cpp:
#include "transport_catalogue.h"

TransportCatalogue CreateTransportCatalogue() {
    TransportCatalogue tc;
    ...
    // Когда в функции возвращается один единственный объект,
    // компилятор избавится от вызова копирующего или перемещающего конструктора.
    // Эта оптимизация называется Guaranteed copy elision
    return tc;
}

TransportCatalogue CreateTransportCatalogueEx(bool param) {
    TransportCatalogue tc1;
    ...
    TransportCatalogue tc2;
    ...
    // Здесь компилятор не знает, какой из объектов вернёт функция,
    // и будет копировать или перемещать один из объектов tc1 и tc2.
    if (param) {
        return tc1;
    }
    return tc2;
}
Компилятор выдаст ошибку:
main.cpp: In function 'TransportCatalogue CreateTransportCatalogueEx()':
main.cpp:8:16: error: use of deleted function 'TransportCatalogue::TransportCatalogue(const TransportCatalogue&)'
    8 |         return tc1;
      |                ^~~
In file included from main.cpp:1:
transport_catalogue.h:4:7: note: 'TransportCatalogue::TransportCatalogue(const TransportCatalogue&)' is implicitly deleted because the default definition would be ill-formed:
    4 | class TransportCatalogue {
      |       ^~~~~~~~~~~~~~~~~~
...
Чтобы исправить проблему, нужно поступить с перемещающим конструктором и операцией присваивания так же, как с деструктором: явно объявить их в классе и реализовать внутри соответствующего .cpp файла, ниже объявления структуры Impl:
transport_catalogue.h:
class TransportCatalogue {
public:
    ...
    // Перемещающий конструктор класса unique_ptr не бросает исключений,
    // поэтому мы можем гарантировать отсутствие исключений при перемещении 
    TransportCatalogue(TransportCatalogue&&) noexcept;
    TransportCatalogue& operator=(TransportCatalogue&&) noexcept;
};
transport_catalogue.cpp:
struct TransportCatalogue::Impl {
    ...
};

// Явно объявляем перемещающий конструктор ниже объявления структуры Impl
TransportCatalogue::TransportCatalogue(TransportCatalogue&&) noexcept = default;

// Аналогично реализуем операцию перемещающего присваивания
TransportCatalogue& TransportCatalogue::operator=(TransportCatalogue&&) noexcept = default;
Вот так, буквально в пару строк удалось решить проблему с перемещением объектов.
Важно помнить, что после перемещения прежним объектом TransportCatalogue пользоваться нельзя — его указатель impl_ теперь обнулён.
int main() {
    TransportCatalogue tc1;
    TransportCatalogue tc2{ std::move(tc1) };
    // Содержимое tc1 перемещено в tc2

    tc2.AddStop(...); // OK

    // Неопределённое поведение из-за разыменования нулевого указателя
    tc1.AddStop(...);
}



После перемещения указатель impl_ у объекта tc1 равен nullptr
Обратите внимание, что если поля внутри Impl хранили ссылки или указатели друг на друга, то эти указатели и ссылки остаются валидными и после перемещения, так как мы просто перекидываем внешний указатель на внутреннюю структуру от одного транспортного справочника к другому. Поэтому внутри поля bus_by_name_ ключи string_view и значения Bus* остаются валидными.
Копирование объектов, использующих идиому Pimpl
Обычно в объектах, использующих идиому Pimpl, реализуют деструктор и операции перемещения, так как они тривиальны. Конструктор копирования и операция копирующего присваивания по умолчанию у таких объектов удалены из-за поля типа unique_ptr. Часто достаточно одного лишь перемещения, но если копирование необходимо, его можно реализовать явно. Принцип тот же: явно объявляем копирующий конструктор и операцию присваивания в заголовочном файле, а определяем в .cpp-файле, ниже объявления стуктуры Impl.
transport_catalogue.h:
class TransportCatalogue {
public:
    ...

    TransportCatalogue(const TransportCatalogue& other);
    TransportCatalogue& operator=(const TransportCatalogue& other);
private:
    struct Impl;
    std::unique_ptr<Impl> impl_;
};
transport_catalogue.cpp:
struct TransportCatalogue::Impl {
    // Если копирование структуры Impl не сводится к простому копированию её полей,
    // то пишем пользовательский конструктор копирования
    Impl(const Impl& other) {
        /* Копируем содержимое other */
    }

    // Если присваивание Impl не сводится к простому присваиванию полей,
    // нужно реализовать должным образом операцию присваивания вручную
    Impl& operator=(const Impl& other) {
        /* Присваиваем содержимое other */
    }
};

TransportCatalogue::TransportCatalogue(const TransportCatalogue& other)
// Если other не пуст, копируем его поле impl_
: impl_(other.impl_ ? std::make_unique<Impl>(*other.impl_) : nullptr) {
}

TransportCatalogue& operator=(const TransportCatalogue& other) {
    if (this != std::addressof(other)) {
        if (!other.impl_) {     // Правый аргумент пуст?
            impl_.reset();
        } else if (impl_) {     // Левый и правый аргументы не пустые?
            assert(other.impl_);
            *impl_ = *other.impl_;
        } else {                // Левый аргумент пуст, а правый не пуст
            assert(!impl_ && other.impl_);
            impl_ = std::make_unique<Impl>(other.impl_);
        }
    }
    return *this;
}
Если присваивание Impl не даёт заметных преимуществ в скорости или памяти перед копированием, можно упростить операцию присваивания:
TransportCatalogue& operator=(const TransportCatalogue& other) {
    if (this != std::addressof(other)) {
        impl_ = other.impl_ ? std::make_unique<Impl>(*other.impl_) : nullptr;
    }
    return *this;
}
Накладные расходы
Идиома Pimpl усложняет код: вместо одного класса в программе теперь класс и структура. Каждый публичный метод класса либо вызывает метод структуры Impl, либо обращается к её полям напрямую. Для перемещения или копирования объектов приходится вручную писать соответствующие конструкторы и операции присваивания. Без Pimpl с этим часто справлялся компилятор.
Сказывается идиома Pimpl и на производительности: создание и удаление структуры Impl в динамической памяти имеет накладные расходы. Если изначальный объект был «легковесным», время конструирования Impl в куче может в несколько десятков раз превышать время конструирования объекта на стеке.



Синий прямоугольник время конструирования и разрушения легковесного объекта, использующего идиому Pimpl, жёлтый - время конструирования объекта без идиомы Pimpl
Ссылка на бенчмарк
Pimpl добавляет накладные расходы и на вызов методов. Если раньше внутри метода можно было сразу обращаться к полям класса, то с Pimpl добавляется дополнительный уровень косвенности: перед доступом к данным нужно разыменовать указатель impl_. Из-за размещения структуры Impl отдельно от самого объекта, её данные могут оказаться не в кеше процессора, что также снижает производительность при вызове методов.
Существует подход под названием Fast Pimpl, который снижает затраты памяти и времени процессора при использовании идиомы Pimpl за счёт размещения данных не в куче, а на стеке. Однако этот подход заметно сложнее классического и не рассматривается в этом курсе. Вы можете самостоятельно ознакомиться с ним, например, в этом докладе.
Подводим итоги
Идиома Pimpl сохраняет совместимость ABI, что может быть полезным для библиотек: их становится возможно обновлять без перекомпиляции клиентского кода. Умный указатель unique_ptr упрощает эту задачу за счёт автоматического управления временем жизни объектов, находящихся в куче.
Идиома Pimpl обеспечивает лучшее сокрытие данных, так как полностью скрывает детали реализации из публично доступного интерфейса класса. Использование идиомы также может скрыть от клиента ряд зависимостей от внешних библиотек, что в некоторых случаях бывает полезно.
Идиома Pimpl может сократить время компиляции, так как из заголовочного файла удаляются детали реализации и избыточные директивы #include. Спрятав от клиентов «тяжеловесные» внешние библиотеки, вы уменьшаете объём работы компилятора.
Идиома Pimpl требует дополнительных усилий от программиста: нужно написать и отладить больше кода. Кроме того, приходится реализовывать операции копирования и перемещения, тогда как без использования идиомы их часто мог бы автоматически сгенерировать компилятор.
Pimpl снижает производительность, так как добавляет дополнительный уровень косвенности при вызове методов и способствует менее эффективному размещению данных в кеше процессора.
В целом идиома Pimpl — это некоторый костыль, исправляющий недостатки языка C++, которые он унаследовал ради совместимости с языком C.
Самое важное применение этой идиомы — сохранить совместимость ABI и спрятать зависимости класса от клиентского кода.
Если в вашей программе достоинства от использования идиомы Pimpl перевешивают недостатки, смело применяйте эту идиому. В противном случае отдавайте предпочтение более простому коду.
Умный указатель shared_ptr
Вы познакомились с умным указателем unique_ptr, который единолично владеет объектом в динамической памяти. Им удобно пользоваться в случаях, когда время жизни одного объекта ограничено временем жизни другого объекта-владельца. Примеры:
Время жизни дочерних узлов двоичного дерева ограничено временем жизни их родительского узла.
Аккаунт в соцсети и контент. Пока существует аккаунт, существуют и посты, которые опубликованы через него.
Однако встречаются задачи, в которых конкретный объект должен жить, пока в программе есть хотя бы один объект-владелец, ссылающийся на него. Примеры:
Несколько объектов на слайдах презентации могут использовать одно растровое изображение. Пока на слайдах есть хотя бы один такой объект, изображение удалять нельзя.
Одно и то же соединение с базой данных может использоваться несколькими объектами. Закрывать это соединение можно только после разрушения всех объектов.
Тут указатель unique_ptr бессилен, ведь в программе может быть только один его экземпляр, ссылающийся на конкретный объект.
В таких ситуациях используют умный указатель std::shared_ptr.
Указатель shared_ptr
shared_ptr — умный указатель, обеспечивающий совместное владение динамически выделенным ресурсом. Несколько экземпляров shared_ptr могут владеть одним и тем же объектом. Объект разрушается с помощью delete. Занимаемая им память освобождается, когда:
вызывается деструктор последнего экземпляра shared_ptr, владевший этим объектом;
последнему экземпляру shared_ptr, владеющему этим объектом, присваивается значение другого указателя (с помощью операции присваивания или вызова метода reset).
Можно создать shared_ptr на основе сырого указателя на объект в куче:
shared_ptr<Object> obj_ptr{new Object()};
Либо сразу создать объект в куче и получить владеющий этим объектом shared_ptr, вызвав функцию make_shared:
auto obj_ptr = make_shared<Object>();
Продемонстрируем принципы работы shared_ptr на примере роботов, которые совместно владеют зарядными устройствами.
// Зарядное устройство
class Charger {
public:
    explicit Charger(string name)
        : name_(move(name)) {
        cout << "Charger "sv << name_ << " has been created"sv << endl;
    }
    ~Charger() {
        cout << "Charger "sv << name_ << " has been destroyed"sv << endl;
    }
private:
    string name_;
};
Роботы могут использовать зарядные устройства, используя указатель shared_ptr. Для простоты будем считать, что каждый робот в один момент времени владеет только одним зарядным устройством. Несколько роботов могут использовать одно и то же зарядное устройство.
class Robot {
public:
    explicit Robot(string name)
        : name_(move(name)) {
        cout << "Robot "sv << name_ << " has been created"sv << endl;
    }
    ~Robot() {
        cout << name_ << " has been destroyed"sv << endl;
    }

    // Начать использовать зарядное устройство.
    void UseCharger(shared_ptr<Charger> charger) {
        charger_ = move(charger);
    }
    // Перестать владеть зарядным устройством.
    void ReleaseCharger() {
        charger_.reset();
    }

    const shared_ptr<Charger>& GetCharger() const {
        return charger_;
    }
private:
    string name_;
    shared_ptr<Charger> charger_;
};
Сначала создаются роботы r2d2 и c3po, затем во вложенном блоке добавляются умные указатели charger1, charger2 и charger3, ссылающиеся на соответствующие зарядные устройства. Первые два зарядных устройства используются роботами, а третье — нет.
int main() {
int main() {
    Robot r2d2{"R2D2"s};
    Robot c3po{"C3PO"s};
    {
        auto charger1 = make_shared<Charger>("Charger1"s);
        auto charger2 = make_shared<Charger>("Charger2"s);
        auto charger3 = make_shared<Charger>("Charger3"s);

        r2d2.UseCharger(charger1);
        c3po.UseCharger(charger2);
        cout << "----"sv << endl;
    }
    cout << "----"sv << endl;
    ...

При выходе из внутреннего блока разрушается charger3 — единственный указатель, ссылающийся на зарядное устройство №3. С ним перестает существовать и соответствующий объект. Также разрушаются указатели charger1 и charger2. Но зарядные устройства Charger1 и Charger2 не разрушаются, так как на них ссылаются указатели со стороны роботов:
Robot R2D2 has been created
Robot C3PO has been created
Charger Charger1 has been created
Charger Charger2 has been created
Charger Charger3 has been created
----
Charger Charger3 has been destroyed
----

Затем робот C3PO начинает использовать зарядное устройство робота R2D2.
   cout << "C3PO uses R2D2's charger"sv << endl;
    c3po.UseCharger(r2d2.GetCharger());
Так как shared_ptr внутри C3PO перестал ссылаться на Charger2 происходит разрушение Charger2.
C3PO uses R2D2's charger
Charger Charger2 has been destroyed

Затем R2D2 перестаёт ссылаться на своё зарядное устройство:
   cout << "R2D2 releases its charger"sv << endl;
    r2d2.ReleaseCharger();
    cout << "----"sv << endl;
Так как на Charger1 всё ещё ссылается shared_ptr со стороны C3PO, с Charger1 ничего не происходит.
R2D2 releases its charger
----

В конце функции main из своей области видимости выходят локальные переменные r2d2 и c3po.
   cout << "Robots end their lifetime"sv << endl;
    cout << "----"sv << endl;
}
Сначала разрушается переменная c3po, а вместе с ней и последний указатель на Charger2.
Robots end their lifetime
----
C3PO has been destroyed
Charger Charger1 has been destroyed

Затем разрушается переменная r2d2:
R2D2 has been destroyed

Таким образом, shared_ptr позволяет динамически продлевать время жизни объекта в куче, пока у этого объекта есть хотя бы один владелец. Как только все владеющие объектом указатели разрушаются или перестают указывать на него, объект удаляется.
shared_ptr полезен, когда несколько объектов с разным временем жизни совместно используют некоторый ресурс. Этот ресурс нельзя удалять, пока он используется хотя бы одним объектом. Чтобы ресурс не занимал память впустую, его нужно удалить, когда в нём больше никто не нуждается. shared_ptr автоматизирует управление временем жизни такого ресурса.
Например, в программе для создания презентаций несколько фигур могут совместно использовать одну и ту же текстуру для рисования своей внутренней области.

На рисунке показан слайд презентации с тремя фигурами. Фигура №1 использует текстуру A, фигуры №2 и №3 — текстуру B. Время жизни фигур на слайде заранее не известно, так как пользователь может удалить в редакторе любую из них в произвольный момент. Нужно своевременно удалить из памяти текстуру, если не осталось фигур, которые её используют.
Текстуру A можно удалить из памяти программы сразу после удаления фигуры №1, а текстуру B — только после удаления фигур №2 и №3. Текстуры — ресурсы, совместно используемые фигурами. Управление этими ресурсами легко автоматизировать, если фигуры будут ссылаться на свои текстуры, используя shared_ptr. Дубликат фигуры будет использовать shared_ptr, ссылающийся на ту же текстуру, что и оригинальная фигура. Каждая текстура будет автоматически удалена, когда на слайде не останется ни одной использующей её фигуры.
Создание shared_ptr из unique_ptr
У shared_ptr есть специальный конструктор, принимающий unique_ptr по rvalue-ссылке. С его помощью можно переместить содержимое unique_ptr в shared_ptr, превратив единоличное владение объектом в совместное:
auto u_ptr = std::make_unique<Dog>("Belka"s);
...
shared_ptr<Dog> s_ptr{std::move(u_ptr)};
// u_ptr пуст — право владения объектом передано указателю s_ptr.
assert(!u_ptr);
Обратное преобразование из shared_ptr в unique_ptr невозможно: основная задача shared_ptr — совместное владение, а не уникальное. Если вам нужно написать функцию, которая будет создавать объект и возвращать умный указатель, возвращайте unique_ptr, а затем присваивайте его shared_ptr, когда требуется. Возвращать shared_ptr стоит, когда вы точно знаете, что возвращаемый объект предназначен лишь для совместного владения.
Copy on write — теория
Умный указатель shared_ptr используется для совместного владения ресурсом. Ресурс живёт до тех пор, пока на него ссылается хотя бы один shared_ptr.
Однако владение ресурсом подразумевает не только управление его временем жизни, но и использование: доступ к данным и методам. В задаче про фигуры таким ресурсом был объект класса Texture. Несколько фигур могли использовать одну и ту же текстуру, что при больших размерах существенно экономило память.
Взгляните на методы класса Texture:
class Texture {
public:
    Size GetSize() const;

    char GetPixelColor(Point p) const;
    ...
};
Все методы этого класса константные, поэтому с их помощью можно только считывать данные из текстуры, но нельзя изменять их. Совместное владение неизменяемым объектом — самый простой сценарий использования указателя shared_ptr. В реальных программах часто требуется изменять состояние объектов.
Представьте, что в классе Texture есть метод SetPixelColor, изменяющий цвет пикселя, а в классе Shape — метод GetTexture, возвращающий shared_ptr<Texture>:
class Texture {
    ...
    void SetPixelColor(Point p, char color);
    ...
};

class Shape {
    ...
    std::shared_ptr<Texture> GetTexture() const;
    ...
};
Взгляните на этот фрагмент программы:
int main() {
    auto tex = std::make_shared<Texture>(...);

    Shape rect1 {ShapeType::RECTANGLE};
    rect1.SetPosition({0, 0});
    rect1.SetSize({15, 10});
    rect1.SetTexture(tex);

    Shape rect2 = rect1;
    rect2.SetPosition({5, 5});
    rect2.GetTexture()->SetPixelColor({5, 3}, '+');

    rect1.Draw();
    rect2.Draw();
}
Как в этой программе будут нарисованы прямоугольники rect1 и rect2?
Прямоугольники будут нарисованы с одной и той же текстурой tex.
Когда копируется фигура, то и оригинал, и копия будут ссылаться на одну и ту же текстуру. Поэтому изменение текстуры, полученной у одной фигуры, повлияет на внешний вид всех фигур с этой текстурой.
Предположим, что вас такое поведение не устраивает, и вы хотите, чтобы изменение текстуры одной фигуры не влияло на текстуру остальных фигур.
Самым простым решением этой проблемы было бы хранить внутри фигуры не указатель на текстуру, а саму текстуру.
Тогда при копировании фигуры будет копироваться и её текстура.
Но у этого подхода есть несколько серьёзных недостатков:
Чрезмерное потребление памяти. Текстуры обычно имеют большой размер. Хранить в памяти множество одинаковых копий одной текстуры расточительно: каждая из них размером десятки или сотни килобайт.
Снижение быстродействия из-за создания копии.
Исправить эти недостатки можно с помощью оптимизации Copy on write (копирование при записи). Смысл ее в следующем:
При копировании объекта копируются не сами данные, а только указатель на них. Это делает копирование объекта легковесной операцией.
Пока над копиями объекта выполняются операции чтения, все копии используют одни и те же данные.
При модификации объекта его данные копируются, если на них ссылается кто-то ещё. Объект начинает использовать модифицированную копию данных.
Если объект единолично использует свои данные, то при его модификации данные не копируются.
Рассмотрим на примере.
Создадим объект A. Вместе с ним создаются данные X. Объект A хранит указатель на объект X.

Объект A ссылается на данные X
Создадим две копии объекта A: объекты B и C. Копируются только указатели на данные. Сами данные не копируются.



Объекты A, B и C используют одни и те же данные X
Выполним модификацию объекта C. Перед модификацией данных они будут скопированы и C будет использовать измененную копию.

Теперь объект C использует отдельную копию данных Y
Еще раз изменим объект C. Так как он единолично владеет данными, они копироваться не будут.

Данные объекта C изменились с Y на Z
Создадим D, копию объекта C. И оригинал, и копия будут использовать одни и те же данные.

С и D используют одни и те же данные Z
Что произойдет, если теперь над объектом B выполнить операцию записи?
Будет создана копия данных X, B будет ссылаться на измененную копию.
Так как B владеет данными совместно с объектом A, будут скопированы данные, B будет ссылаться на модифицированную копию W.

Объект B ссылается на новую копию W
Рассмотрим, что происходит при разрушении объектов.
Объект D разрушается. Так как на данные Z ссылался и объект C, данные не удаляются.

Объект C удерживает данные Z от удаления
Объекты A, B и C удаляются. Вместе с ними удаляются и данные X, W, Z, которыми они владели единолично.

И никого не стало...
Этот алгоритм может показаться несколько сложным, однако возможностей shared_ptr достаточно, чтобы создать простой объект, реализующий эту оптимизацию.
Объект должен ссылаться на данные с помощью shared_ptr. Тогда копии объекта будут использовать одни и те же данные, а копирование объекта будет сводиться к копированию указателя shared_ptr.
Чтобы изменить состояние объекта, нужно убедиться, что он единственный владелец данных. Для этого воспользуемся методом shared_ptr::use_count. Он возвращает количество shared_ptr, владеющих объектом. Если вернулось число больше единицы, значит, на эти данные ссылается кто-то кроме текущего объекта. В этот момент нужно скопировать данные и модифицировать копию.
Чтобы оптимизацию Copy on Write было просто применять, создадим умный указатель CoW (Copy on Write). Внутри он будет хранить shared_ptr. За счёт этого все копии CoW будут использовать один и тот же экземпляр данных.
template <typename Value>
class CoW {
public:
    // Конструируем значение по умолчанию.
    CoW()
        : value_(std::make_shared<Value>()) {
    }

    // Создаём значение за счет перемещения его из value.
    CoW(Value&& value)
        : value_(std::make_shared<Value>(std::move(value))) {
    }

    // Создаём значение из value.
    CoW(const Value& value)
        : value_(std::make_shared<Value>(value)) {
    }

private:
    std::shared_ptr<Value> value_;
};
В этом классе 3 конструктора:
конструктор по умолчанию;
конструктор, создающий СoW-объект путём копирования переданного значения;
конструктор, создающий CoW-объект путём перемещения переданного значения.
Конструктор копирования и операцию присваивания писать не нужно, так как с их генерированием справится компилятор.
Следующим шагом добавим в CoW операции * и ->. Они предоставят доступ к данным в режиме чтения:
template <typename Value>
class CoW {
public:
    ...

    // Оператор разыменования служит для чтения значения.
    const Value& operator*() const noexcept {
        assert(value_);
        return *value_;
    }

    // Оператор -> служит для чтения полей и вызова константных методов.
    const Value* operator->() const noexcept {
        assert(value_);
        return value_.get();
    }

    ...
};
Проверим CoW в действии. Положим внутрь строку и убедимся, что обе CoW-копии используют одну и ту же строку:
int main() {
    using namespace std::literals;

    CoW<std::string> s1("Hello");
    CoW<std::string> s2{s1};

    // Для доступа к значению используем операцию разыменования.
    std::cout << *s1 << ", "sv << *s2 << std::endl;

    // Для вызова константных методов служит стрелочка.
    std::cout << s1->size() << std::endl;

    // Оба указателя ссылаются на одну и ту же строку в памяти.
    assert(&*s1 == &*s2);
    std::cout << &*s1 << ", "sv << &*s2 << std::endl;
}
Запустим программу. На вашем компьютере адреса в третьей строке будут другими, но обязательно одинаковыми:
Hello, Hello
5
000001B0C3ED5A30, 000001B0C3ED5A30
Доступ на запись устроен хитрее. Добавим метод Write. В нём удостоверимся, что текущий указатель — единственный владелец данных. Для этого воспользуемся методом shared_ptr::use_count.
Если кроме текущего указателя на данные ссылается кто-то ещё, создадим копию и будем использовать её. В самом конце вызовем переданную нам функцию и передадим туда не константную ссылку на текущую копию объекта:
template <typename Value>
class CoW {
public:
    ...

    // Write принимает функцию, в которую CoW передаст неконстантную ссылку на хранящееся значение.
    template <typename ModifierFn>
    void Write(ModifierFn&& modify) {
        EnsureUnique();
        // Теперь value_ — единственный владелец данных.

        std::forward<ModifierFn>(modify)(*value_);
    }

private:
    // Удостоверяемся, что текущий объект единолично владеет данными.
    // Если это не так, создаём копию и будем ссылаться на неё.
    void EnsureUnique() {
        assert(value_);

        if (value_.use_count() > 1) {
            // Кроме нас на value_ ссылается кто-то ещё, копируем содержимое value_.
            value_ = std::make_shared<Value>(*value_);
        }
    }

    ...
};
Чтобы изменить CoW-объект, вызовем метод Write. В него передадим лямбда-функцию и внутри неё изменим значение объекта.
int main() {
    using namespace std::literals;

    CoW<std::string> s1("Hello"s);
    CoW<std::string> s2{s1};

    std::cout << *s1 << " "sv << *s2 << std::endl;

    s2.Write([](auto& value) {
        // Внутри этой функции можно изменить значение, содержащееся в s2.
        value = "World"s;
        value += '!';
    });

    // Теперь s2 содержит строку "World!".
    std::cout << *s1 << " "sv << *s2 << std::endl;
}
Этот способ удобен, когда над объектом нужно проделать несколько модифицирующих операций. Но чаще всего требуется вызвать лишь один неконстантный метод класса или изменить одно из полей. В этом случае эта конструкция будет громоздкой:
s2.Write([](auto& value) {
    value.clear();
});
Подумаем, как сделать это более лаконично.
Можно было бы добавить в CoW метод Write без параметров, который бы вернул ссылку на объект:
template <typename Value>
class CoW {
public:
    ...
    Value& Write() {
        EnsureUnique();

        return *value_;
    }
    ...
};
Тогда изменение объекта сократилось бы до одной строки:
s1.Write().clear();
Однако за этой простотой кроется опасность. Пользователь класса может сохранить ссылку, возвращенную методом Write. Затем использует эту ссылку для модификации данных, когда объект уже не будет единоличным владельцем.
Что выведет эта программа?
CoW<std::string> s1("Hello"s);

auto& data = s1.Write();
CoW<std::string> s2(s1); 

data = "Hi"s;
std::cout << *s1 << " "sv << *s2;
Hi Hi.
Изменение данных объекта, полученных у s1, привело к изменению данных объекта s2. Отданная наружу ссылка позволила изменить данные в обход механизмов логики Copy on write.



Ссылка ref позволяет модифицировать строку в обход s1 и s2
Чтобы защититься от этого, нужно возвращать пользователю не ссылку, а специальный прокси-объект с операциями * и ->.
template <typename Value>
class CoW {
    // Прокси-объект объявлен в приватной области. Поэтому его нельзя создать снаружи класса.
    struct WriteProxy {
        explicit WriteProxy(Value* value) noexcept
            : value_ptr_{value} {
        }

        // Прокси-объект нельзя копировать и присваивать.
        WriteProxy(const WriteProxy&) = delete;
        WriteProxy& operator=(const WriteProxy&) = delete;

        // У lvalue-ссылок операции разыменования нет.
        Value& operator*() const& = delete;
        // А у rvalue-ссылок разыменование есть.
        [[nodiscard]] Value& operator*() const&& noexcept {
            return *value_ptr_;
        }

        // Операции -> у lvalue-ссылок нет.
        Value* operator->() const& = delete;
        // У rvalue-ссылок операция -> есть.
        Value* operator->() const&& noexcept {
            return value_ptr_;
        }

    private:
        Value* value_ptr_;
    };

public:
    [[nodiscard]] WriteProxy Write() {
        EnsureUnique();

        // Возвращаем прокси-объект для модификации данных.
        return WriteProxy(value_.get());
    }
    ...
};
Чтобы защититься от многократного использования WriteProxy, здесь используется перегрузка операций * и -> для rvalue- и lvalue-ссылок. У rvalue-ссылок на WriteProxy эти операции есть, а у lvalue-ссылок они удалены. Поэтому такой код компилироваться не будет:
   CoW<std::string> s1("Hello");
    auto writer = s1.Write();
    CoW<std::string> s2;
    writer->append("!!!"); // Ошибка компиляции.
Теперь одиночные модификации объекта можно выполнить без использования лямбда-функций:
CoW<std::string> s1("Hello");
CoW<std::string> s2{s1};
// Чтобы изменить значение, нужно разыменовать результат вызова Write().
*s2.Write() = "Wor";
*s2.Write() += "ld";
// Можно вызывать не константные методы, используя ->.
s2.Write()->append("!");.
Copy on write — практика
Рассмотрим оптимизацию Copy on write для компактного хранения изображений в графическом редакторе.
Представьте, что вы разрабатываете графический редактор наподобие Paint. В этой программе пользователь может рисовать на растре различные графические примитивы: линии, окружности, прямоугольники, изменять цвета отдельных пикселей.
Растровое изображение — двумерный массив пикселей размером MxN.




Пример растрового изображения
Одна из обязательных функций любого графического редактора — возможность отмены изменений. Для этого редактор должен сохранять предыдущие версии изображения, чтобы в любой момент можно было переключиться на одну из них. И здесь начинаются сложности.
Чем больше размеры картинки, тем больше памяти она занимает. Например, иконка 32x32 пикселя с глубиной цвета в 32 бита будет занимать 32∗32∗(32/8)=4096 байт, или 4 килобайта. А фотография размером 4000x3000 пикселей и глубиной цвета 32 бита — уже 48 мегабайт. Если после каждой правки сохранять копию изображения целиком, никакой памяти не хватит!
В этом случае поможет Copy on write. Воспользуемся тем, что в подобных редакторах большинство действий пользователя изменяют лишь небольшую часть изображения. Например, рисование карандашом или кистью изменяет всего лишь сотни или даже десятки пикселей.
Разобьём всё изображение на тайлы, прямоугольные кусочки (а чаще, квадратные) фиксированного размера. Каждый тайл будет хранить небольшую часть целого изображения.




Растровое изображение, разбитое на тайлы размером 4x4
Размеры тайла не должны быть слишком маленькими, чтобы накладные расходы, связанные с ним, были незначительными по сравнению с размерами самого тайла. Большое изображение, составленное из слишком маленьких тайлов, будет использовать много памяти для хранения служебной информации.
Слишком большим тайл тоже не должен быть, так как память выделяется целыми тайлами, что может быть расточительно.
Типичный размер тайла — от 8x8 до 64x64 пикселей. При глубине цвета в 32 бита тайл будет занимать от 0.25 до 16 килобайт, а служебные данные — несколько десятков байт.
Если размеры изображения не кратны размерам тайла, количество тайлов по горизонтали и вертикали округляют вверх и часть области граничных тайлов не используют. Например, если используются тайлы 4x4, изображение размером 14x11 пикселей потребует 4x3=12 тайлов. Похожим образом поступают с кафельной плиткой: размеры стены округляют вверх до целого числа плиток, а потом лишние части плитки отрезают.




Части тайлов, выходящие за границы изображения, не используются
Изображение должно хранить каждый тайл с оптимизацией Copy on write. Тогда копия изображения будет использовать те же тайлы, что и оригинал. И только при изменении пикселей изображения будут создаваться модифицированные копии затронутых тайлов.
Copy on write будет экономить память даже при хранении единственного изображения, если все его пиксели одного цвета. В этом случае всю поверхность изображения можно замостить копией одного тайла.




Вся поверхность картинки img_1 вымощена 12-ю копиями тайла T1
Рассмотрим работу с тайловым изображением.
Создадим img_2, копию картинки img_1, и нарисуем внутри img_2 вертикальный отрезок. На основе тайла T1 будут созданы тайлы T2 и T3. Остальные тайлы в изображении img_2 будут использовать тайл T1.




В тайлах T2 и T3 нарисован вертикальный отрезок
Скопируем img_2 в img_3, где нарисуем диагональный отрезок. Будут созданы тайлы:
T4 на основе тайла T2,
T5 на основе тайла T1,
T6 на основе тайла T1.




В тайлах T4, T5 и T6 нарисован диагональный отрезок
Нарисуем в img_3 ещё один диагональный отрезок. Тайл T6 будет модифицирован без создания его копии, так как он используется в единственном экземпляре:




В тайле T6 нарисован диагональный отрезок
В результате в программе получилось 3 изображения размером 16x12 пикселей, использующие всего 6 тайлов 4x4. Даже на таком простом примере можно видеть, как мы сэкономили память в 6 раз. При большем количестве похожих копий можно достичь экономии в десятки и даже сотни раз!
Умный указатель weak_ptr
Вы познакомились с умным указателем shared_ptr. Благодаря ему несколько умных указателей могут владеть одним динамически выделенным ресурсом. Ресурс будет автоматически уничтожен, когда последний из ссылающихся на ресурс умных указателей разрушится или станет ссылаться на другой объект.
У вас могло сложиться впечатление о всесильности указателя shared_ptr. Настало время это развеять.
Проблема циклических ссылок
Рассмотрим два класса: Person и Apartment. Человек живёт в квартире, поэтому содержит shared_ptr, ссылающийся на его квартиру. В квартире, в свою очередь, проживает человек, поэтому она содержит shared_ptr, ссылающийся на человека:
struct Apartment;

struct Person {
    explicit Person(string name)
        : name(move(name))  //
    {
        cout << "Person "sv << this->name << " has been created"sv << endl;
    }
    ~Person() {
        cout << "Person "sv << name << " has died"sv << endl;
    }

    string name;
    shared_ptr<Apartment> apartment;
};

struct Apartment {
    Apartment() {
        cout << "The apartment has been created"sv << endl;
    }
    ~Apartment() {
        cout << "The apartment has been destroyed"sv << endl;
    }

    shared_ptr<Person> person;
};
Создадим человека и квартиру и свяжем их друг с другом:
int main() {
    auto apartment = make_shared<Apartment>();
    auto person = make_shared<Person>("Ivan"s);
    person->apartment = apartment;
    apartment->person = person;
}
Запустив программу, столкнёмся с утечкой памяти: ни у человека, ни у квартиры не был вызван деструктор.
The apartment has been created
Person Ivan has been created
Суть проблемы в том, что между person и apartment возникла циклическая ссылка. Циклическая ссылка — ситуация, при которой в программе появляется циклическая последовательность владеющих ссылок. В данном случае:
объект person владеет объектом apartment, не давая ему уничтожиться;
объект apartment владеет объектом person, также не давая ему уничтожиться.

В итоге даже при отсутствии внешних ссылок на person и apartment эти объекты удерживают друг друга от разрушения, что и приводит к утечке памяти.
В нашем случае проблема возникла из-за неправильного предположения, что квартира владеет своими жильцами и одновременно человек владеет квартирой.
В реальных программах циклические ссылки могут принимать более сложные формы. На следующей диаграмме можно обнаружить два цикла: A-B-C и A-B-C-E.

Указатели unique_ptr и shared_ptr — владеющие. Объект, который ссылается на другой объект по shared_ptr или unique_ptr, отвечает за его удаление. Выбирайте unique_ptr и shared_ptr только тогда, когда нужно обозначить владение одного объекта другим. И в то же время, когда удаление владеющего объекта должно повлечь за собой удаление того, которым владеют. В остальных случаях используйте обычные ссылки или невладеющие указатели.
Циклическое владение практически всегда свидетельствует об ошибке. Решение: разорвать цикл владеющих ссылок, заменив некоторые связи между объектами на обычные указатели. Например, можно заменить связь от Apartment к Person на обычный указатель:
struct Apartment {
    Apartment() {
        cout << "The apartment has been created"sv << endl;
    }
    ~Apartment() {
        cout << "The apartment has been destroyed"sv << endl;
    }

    Person* person = nullptr;
};

int main() {
    auto apartment = make_shared<Apartment>();
    auto person = make_shared<Person>("Ivan"s);
    person->apartment = apartment;
    // Теперь apartment ссылается на person по обычному указателю.
    apartment->person = person.get();
    cout << "----"sv << endl;
}
Запустим программу и увидим, что оба объекта своевременно разрушились:
The apartment has been created
Person Ivan has been created
----
Person Ivan has died
The apartment has been destroyed
Немного усложним код. Изменения в коде выделены комментариями. Что выведет эта программа?
#include <iostream>
#include <memory>
#include <string_view>

using namespace std;

struct Apartment;

struct Person {
    explicit Person(string name)
        : name(move(name))  //
    {
        cout << "Person "sv << this->name << " has been created"sv << endl;
    }
    ~Person() {
        cout << "Person "sv << name << " has died"sv << endl;
    }

    string name;
    shared_ptr<Apartment> apartment;
};

struct Apartment {
    Apartment() {
        cout << "The apartment has been created"sv << endl;
    }
    ~Apartment() {
        cout << "The apartment has been destroyed"sv << endl;
    }

    Person* person = nullptr;
};

// ----- Начало изменений ----
void PrintApartmentInfo(const Apartment& apartment) {
    if (apartment.person) {
        cout << apartment.person->name << " is living in the apartment" << endl;
    } else {
        cout << "The apartment is empty"sv << endl;
    }
}

int main() {
    auto apartment = make_shared<Apartment>();
    {
        auto person = make_shared<Person>("Ivan"s);
        person->apartment = apartment;
        apartment->person = person.get();
        cout << "----"sv << endl;
    }
    PrintApartmentInfo(*apartment);
}
// ----- Конец изменений ----
Указатель person — единственный экземпляр shared_ptr, который ссылается на человека, проживающего в квартире. При выходе из вложенного блока функции main житель квартиры будет разрушен, а указатель apartment->person станет невалидным. При попытке разыменовать этот указатель внутри функции PrintApartmentInfo произойдёт неопределённое поведение.
Программа содержит неопределенное поведение.
Эта проблема вызвана разыменованием «висячего» указателя. Её можно исправить, обнулив в деструкторе класса Person ссылку на него со стороны Apartment, однако есть способ лучше.
Встречайте, weak_ptr!
std::weak_ptr — умный указатель, хранящий невладеющую, или слабую, ссылку на объект, на который ссылается shared_ptr.
weak_ptr позволяет безопасно узнать, существует ли объект, на который он ссылается, и получить к нему временный доступ, если объект всё ещё жив. При этом наличие слабой ссылки не продлевает объекту жизнь. Объект будет удалён, как только на него перестанут ссылаться shared_ptr, — по этой причине их ещё называют сильными ссылками:
#include <cassert>
#include <memory>

using namespace std;

struct Object {
    void DoSomething() {
    }
};

int main() {
    auto sp = make_shared<Object>();

    weak_ptr wp{sp};  // Аналог weak_ptr<Object> wp{sp}.

    // Пока объект жив, слабые ссылки не устаревают.
    assert(!wp.expired());
    // После обнуления shared_ptr объект удаляется.
    sp.reset();

    // С этого момента все слабые ссылки становятся устаревшими.
    assert(wp.expired());
}
weak_ptr не имеет операторов * и ->, ведь обращаться к объекту, который может быть в любой момент удалён, небезопасно.
Чтобы безопасно обратиться к объекту, на который ссылается weak_ptr, нужно получить временный объект shared_ptr, используя метод lock. Если объект был удалён, метод lock вернёт нулевой указатель:
int main() {
    auto sp = make_shared<Object>();
    weak_ptr wp{sp};

    if (auto sp2 = wp.lock()) {
        // В этом блоке можно безопасно обращаться к объекту, используя сильную ссылку.
        sp2->DoSomething();
    } else {
        // Сюда мы не попадем, так как на объект всё ещё ссылается sp.
        assert(false);
    }

    sp.reset();
    // Объект уже разрушен, создать сильную ссылку не выйдет.
    assert(!wp.lock());
}
Рассмотренная ранее проблема циклических ссылок может быть безопасно решена с использованием weak_ptr.  Для этого одну из ссылок, образующих цикл, нужно сделать слабой.
Объявив внутри Apartment слабую ссылку на Person, решим и проблему с утечкой памяти, и проблему висячих ссылок:
struct Apartment {
    Apartment() {
        cout << "The apartment has been created"sv << endl;
    }
    ~Apartment() {
        cout << "The apartment has been destroyed"sv << endl;
    }

    // Ссылка на Person автоматически обнуляется, когда Person будет удалён.
    weak_ptr<Person> person;
};

void PrintApartmentInfo(const Apartment& apartment) {
    if (const auto person = apartment.person.lock()) {
        cout << person->name << " is living in the apartment" << endl;
    } else {
        cout << "The apartment is empty"sv << endl;
    }
}

int main() {
    auto apartment = make_shared<Apartment>();
    {
        auto person = make_shared<Person>("Ivan"s);
        person->apartment = apartment;
        apartment->person = person;
        cout << "----"sv << endl;
    }
    PrintApartmentInfo(*apartment);
}
Теперь программа отработает корректно без дополнительных усилий с нашей стороны:
The apartment has been created
Person Ivan has been created
----
Person Ivan has died
The apartment is empty
The apartment has been destroyed
Решение проблемы висячих ссылок — не единственное применение указателя weak_ptr. Он умеет отслеживать, жив ли некоторый объект, а ещё может получать доступ к нему. Этим способностям можно найти много разных применений. В следующем задании вам предстоит разработать простой кэш объектов, который будет возвращать существующий объект из кэша или, при его отсутствии, создавать новый.

