Временные объекты
Вы уже знаете много приемов ускорения, включая правильный подбор контейнеров, использование профилировщика и даже учёт кэширования процессора. Рассмотрим пример:
#include <iostream>
#include <string>
using namespace std;
class Number {
private:
    int a_;
public:
    Number() {
        cout << "Default Ctor"s << endl;
    }
    Number(int num)
        : a_(num) 
    {
        cout << "Ctor(int)"s << endl;
    }
    Number(const Number& other)
        : a_(other.a_) 
    {
        cout << "Copy Ctor"s << endl;
    }
    ~Number() {
        cout << "Dtor"s << endl;
    }
    Number& operator=(const Number& other) {
        a_ = other.a_;
        cout << "Op="s << endl;
        return *this;
    }
    Number operator+(const Number& second) {
        cout << "Op+" << endl;
        return a_ + second.a_;
    }
};

int main() {
    Number a(1), b(1), c;
    c = a + b;
    cout << "End of calculations"s << endl;
}
При этом очевидных объектов только три: a, b и c. Четвёртый — временный — объект возникает здесь:
return a_ + second.a_;
У этого объекта нет имени. Невозможно узнать его адрес. Но он должен быть создан, чтобы функция могла его вернуть. После этого вызывается operator=, объект копируется в объект c и сразу уничтожается.
Программа работает, но создание временного объекта, а потом ещё и его копирование выглядят лишними. Совсем неудобно получилось бы, если объекты класса Number были тяжелыми, их конструктор и копирование были сложнее, чем O(1), в процессе динамически выделялась память, могли возникнуть исключения.
В языке С++ есть механизмы, которые помогают избавиться от лишних действий. Вы научитесь их замечать и применять в ближайших уроках.
Copy elision и NRVO
Copy elision
Вернемся к примеру из прошлого урока:
...
Number operator+(const Number& second) {
    cout << "Op+" << endl;
    return a_ + second.a_;
}
...

int main() {
    ...
    c = a + b;
    ...
}
Из функции возвращался временный объект, который потом присваивался объекту c и разрушался сразу после этого:
Op+
Ctor(int)
Op=
Dtor
Но присмотритесь. Объект, который создается в return, и объект, возвращаемый из функции, совершенно не обязаны быть одним и тем же объектом. Если строго следовать тому, что написано в коде, порядок действий должен быть таким:
Из функции нужно вернуть тип Number, выражение a_ + second.a_ имеет тип int. Компилятор знает, что делать — вызвать конструктор Ctor(int). Получается первый временный объект.
Объект — результат работы функции — создан. Но теперь нужно его вернуть. Вызывается конструктор копирования, и первый временный объект копируется во второй, а второй передается в main.
Первый временный объект разрушается.
Второй временный объект копируется через оператор присваивания в объект c.
Второй временный объект разрушается.
Странно, что в выводе на экран процесс не виден. Дело в том, что в этом случае работает механизм, призванный защитить программу от лишних вызовов конструктора копирования. Посмотрите на второй шаг — его компилятор оптимизировал.
Этот механизм называется “copy elision”. В русскоязычных текстах иногда используют термин «пропуск копии», но чаще употребляется английское название.
В примере вы встретились с copy elision в ситуации, когда временный объект возвращается из функции, и компилятор предпочитает не вызывать лишний раз конструктор копирования.
Посмотрите на примеры и разберитесь, где ещё сработает этот вид оптимизации:
// класс кота Шрёдингера
class SchrodingerCat {
    ...
}

// класс Коробки
class Box {
    ... 
    // кота из коробки можно вытащить
    SchrodingerCat GetCat() {
        is_empty_ = true;
        return box.cat;
    }
    
    bool HasCat() {
        return !is_empty_;
    }
    ...
}

int main() {
    // пока в коробку не заглянешь,
    // не узнаешь, есть ли там кот
    Box black_box(); // (1)
    if (black_box.HasCat()) { // (2)
        SchrodingerCat fluffy = black_box.GetCat(); // (3)
    }
}
Когда вызывается конструктор коробки, появляется временный объект. Потом он копируется в создаваемый объект.
Чтобы обратиться к методу HasCat, коробку сначала надо скопировать, используя конструктор копирования. Так происходит при обращении к любым методам класса.
Правильный ответ
Кот fluffy инициализируется при создании временным объектом. Кажется, здесь можно избежать копирования.
Абсолютно верно! Это второй случай, когда copy elision позволяет избежать ненужного копирования.
Резюмируем. Copy elision — это вид оптимизации, позволяющий компилятору пропустить вызов конструктора копирования:
при возврате из функции временного объекта;
при инициализации объекта временным объектом.
NRVO
Немного поменяем пример. Для вас уже очевидно, что имеет место copy elision:
SchrodingerCat GetCat() {
    is_empty_ = true;
    return SchrodingerCat(); // копирование временного объекта не произойдет
}
Внесем еще одно изменение:
SchrodingerCat GetCat() {
   SchrodingerCat cat;
   cout << "Кажется, в коробке есть кот!"s << endl;
   is_empty_ = true;
   return cat;
}
...
int main() {
   ...
   auto fluffy = black_box.GetCat();
   ...
}
cat — временный объект?
Нет.
NRVO, или Named Return Value Optimization — второй вид оптимизации компилятора, помогающий избегать лишних копирований. Как видно из названия, речь идет о возвращении из функции некой именованной переменной.
Там, где живут чудовища
Но не всё так гладко, как может показаться. Ниже — список опасностей и места, где они поджидают неопытных программистов.
Копирование копированию рознь.
 Будем доставать из коробки пару котов и добавим вывод на экран:
class SchrodingerCat {
 public:
     SchrodingerCat() = default;
     SchrodingerCat(const SchrodingerCat& other) {
         cout << "Cctor"s << endl;
     }
     SchrodingerCat& operator=(const SchrodingerCat& other) {
         cout << "Op="s << endl;
         return *this;
     }
     ~SchrodingerCat() = default;
 };

 class Box {
 public:
     // достанем пару котов
     pair<SchrodingerCat, SchrodingerCat> GetCats() {
         SchrodingerCat cat1;
         SchrodingerCat cat2;
         is_empty_ = true;
         // временная пара котов -> пара, которая возвращается из функции
         return {cat1, cat2};
     }
     bool HasCat() {
         return !is_empty_;
     }

 private:
     bool is_empty_ = false;
 };

 int main() {
     Box black_box;
     if (black_box.HasCat()) {
         pair<SchrodingerCat, SchrodingerCat> cat_pair;
         // копируем пару котов в переменную cat_pair
         cat_pair = black_box.GetCats();
     }
 }
 
В этом примере можно было ожидать, что конструктор копирования не вызовется. Возвращаем временный объект из функции по значению — это совпадает с одним из случаев, когда ожидается copy elision. Но из cat1 и cat2 должна быть создана пара. Именно там конструктор копирования всё-таки будет вызван. Этот случай компилятор не может оптимизировать. Результат вывода на экран:
Cctor
 Cctor
 Op=
 Op=
 
Не всё, что кажется временным, — временно. Поле временного объекта — не временный объект. Поэтому copy elision в этом случае работать не будет. Если возвращаете из функции значение поля, задумайтесь, насколько дорого вам будет обходиться его копирование.
Copy elision полезен, но коварен. Если конструктор копирования или деструктор включают в себя действия, результат которых важен в дальнейшем, компилятор не обратит на это внимания, и действие совершено не будет.
Copy elision и NRVO позволяют пропустить вызов конструктора копирования, но конструктор копирования у класса объекта должен существовать. Иначе говоря, этот код не скомпилируется:
class SchrodingerCat {
    ...
    // негоже копировать котов
    SchrodingerCat (const SchrodingerCat& other) = delete;
    ...
}

class Box {
    ... 
    SchrodingerCat GetCat() {
        SchrodingerCat cat();
        cout << "Кажется, в коробке есть кот!"s << endl;
        is_empty_ = true;
        // вызов конструктора копирования будет пропущен,
        // но конструктор удалён,
        // возникнет ошибка компиляции
        return cat;
    }
    ...
}
Кажется, в целом компилятор отлично справляется и без дополнительных усилий программиста.
Компилятор старается, но не может избавиться от всех копирований. Чаще ему всё-таки нужна наша помощь.
Функция move и другие перемещения
Слон большой, серый, одна штука
Вы уже знаете, как компилятор справляется с лишними копированиями и ускоряет код даже без ведома программиста. Но компилятор не панацея от всех бесполезных действий.
Посмотрите на пример:
using WhiteElephant = string;
// функция, которая умеет делать очень больших слонов 
WhiteElephant BuyElephant() {
    return WhiteElephant(100000000, 'a');
}

int main() {
    vector<WhiteElephant> crowd_of_elephants;
    WhiteElephant heavy_elephant = BuyElephant();
    crowd_of_elephants.push_back(heavy_elephant);
}
Здесь создаётся crowd_of_elephants — толпа слонов. Но в начале она пустая. Пользователь покупает слона и сохраняет его в переменную heavy_elephant. После этого слон добавляется в толпу. Всё просто, и не такое видели. Но в момент копирования heavy_elephant в толпу слонов станет двое. Один теперь в толпе с другими слонами, а второй остался в переменной heavy_elephant. Вряд ли покупатель слонов хотел копировать животных.
В языке С++ есть способ, позволяющий не размножать слонов и другие объекты там, где не нужно. Этот метод использует move-семантику. Вместо семантики копирования — один слон в толпе, второй у хозяина — можно использовать семантику перемещения: забрать слона у хозяина и поместить в толпу.
Если изменим код так, чтобы купленный слон не сохранялся в переменную heavy_elephant, а напрямую передавался в метод push_back, временный слон, вернувшийся после BuyElephant, будет напрямую перемещён в толпу.
crowd_of_elephants.push_back(BuyElephant());
Компилятор видит, что имеет дело с временным объектом, и понимает, что объект будет уничтожен сразу после переноса в вектор. Поэтому компилятор не копирует объект, а переносит его.
Рассмотрим эту идею чуть глубже. Внутри объекта WhiteElephant лежит указатель на место в памяти, где последовательно расположены элементы. Чтобы скопировать элемент, нужно пройти по всем элементам и создать их копии. Но если компилятор знает, что объект временный, он может просто забрать указатель на элементы и перенести его в объект внутри вектора.
Передавая в функции временные объекты, программисты делают код не только более лаконичным, но и более быстрым.
Нет ничего более постоянного, чем временное
Посмотрим на ситуацию с точки зрения владельца слона. Я, гордый обладатель редкого вида слонов, собираюсь отпустить свое приобретение в саванну к сородичам. Но сначала хочу совершить с ним прогулку. То есть мне нужно сохранить своего слона в переменную:
int main() {
    vector<WhiteElephant> crowd_of_elephants;
    // купил слона
    WhiteElephant heavy_elephant = BuyElephant();
    // гуляю и общаюсь с новым большим другом
    SmallWalk(heavy_elephant);
    // о нет! опять слонов стало два! один у меня, один в толпе
    crowd_of_elephants.push_back(heavy_elephant);
}
Не может быть, чтобы не было способа в этом случае избежать раздвоения слонов при копировании.
Чтобы сказать компилятору, что объект в будущем не понадобится, и его можно не копировать, а перенести, используют специальную функцию move. Находится она в библиотеке <utility>:
#include <utility>
...
int main() {
    vector<WhiteElephant> crowd_of_elephants;
    WhiteElephant heavy_elephant = BuyElephant();
    SmallWalk(heavy_elephant);
    // я отпускаю слона на волю
    crowd_of_elephants.push_back(move(heavy_elephant));
}
Функция move позволит хозяину слона сообщить компилятору, что слон больше не нужен, и можно его просто перенести. При этом объект heavy_elephant остался у хозяина, но никто не гарантирует, что находится внутри объекта. Скорее всего, он просто пуст, а все данные перенесены в вектор. Теперь отвлекитесь от перемещений слона и решите жестокую историческую задачу о смелых воинах.
Копировать нельзя переместить
В предыдущих уроках мы старались всячески избегать лишних копирований. Компилятор оптимизировал, а программист вызывал функцию move и подсовывал вместо постоянных объектов временные. В целом, можно сформулировать правило:
«Там, где возможно копирование, должно быть возможно и перемещение».
Но вы уже знаете, что при копировании вызываются специальные методы — конструктор копирования или оператор присваивания. Если вместо копирования требуется осуществить перемещение, компилятору нужны другие методы. В уроке изучим это подробнее.
Запрет на копирование
Вернемся к задаче о считалке Иосифа. В заготовке кода была структура, которая подсчитывает количество копирований, и вам пришлось решать задачу, используя перемещение. Разберемся, как эта структура была устроена на примере другой похожей структуры:
struct NoncopyableInt {
    int value;
    NoncopyableInt(const NoncopyableInt&) = delete;
    NoncopyableInt& operator=(const NoncopyableInt&) = delete;
    NoncopyableInt(NoncopyableInt&&) = default;
    NoncopyableInt& operator=(NoncopyableInt&&) = default;
};
Вы уже знаете о конструкторе копирования и операторе присваивания. В их сигнатурах возникает специальное слово delete:
NoncopyableInt(const NoncopyableInt&) = delete;
NoncopyableInt& operator=(const NoncopyableInt&) = delete;
Так программист может сообщить компилятору, что конструктора копирования и оператора присваивания у структуры не существует. Значит, объекты этого типа запрещено копировать.
Возможность запретить копирование важна, когда копирование объекта может привести к непредсказуемым или нежелательным последствиям. Примеры класса, где копирование запрещено — istream и ostream. Потоки вывода и ввода должны управляться только из одного объекта. Если несколько объектов начнут пытаться писать или читать из потока, будет похоже на то, как несколько человек одновременно печатают на одной клавиатуре или читают вслух с разной скоростью один текст. При попытке копирования компилятор сообщит об ошибке:
// попробуем скопировать cout в наш объект out
ostream out(cout);
out << "Неужели скопировалось?"s << endl;
use of deleted function 'std::basic_ostream<_CharT, _Traits>::basic_ostream(const std::basic_ostream<_CharT, _Traits>&) [with _CharT = char; _Traits = std::char_traits<char>]'
     ostream out(cout);
In file included from C:/Program Files/mingw-w64/x86_64-8.1.0-posix-seh-rt_v6-rev0/mingw64/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/iostream:39,
                 from 1.cpp:1:
C:/Program Files/mingw-w64/x86_64-8.1.0-posix-seh-rt_v6-rev0/mingw64/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/ostream:391:7: note: declared here
       basic_ostream(const basic_ostream&) = delete;
После сигнатуры оператора копирования есть слово delete, и компилятор не дает скопировать объект.
Стандартное перемещение
В примере структуры из считалки Иосифа есть две сигнатуры, в которых пора разобраться:
NoncopyableInt(NoncopyableInt&&) = default;
NoncopyableInt& operator=(NoncopyableInt&&) = default;
Перед вами конструктор перемещения и перемещающий оператор присваивания.
Начнём с простого. Специальное слово default говорит, что компилятор должен сам решить, как будет происходить перемещение. Часто это удобно. Компилятор просто применит перемещение к каждому члену класса или структуры. Если для члена класса определен конструктор перемещения, компилятор будет стараться его найти. Если хотя бы один из членов класса переместить нельзя, компилятор не справится с поставленной задачей и сообщит об ошибке. Вот что случится, если удалить перемещающий конструктор и оператор присваивания:
#include <iostream>
using namespace std;
struct NonmovingInt {
    int value;   
    // копировать, нельзя перемещать!
    NonmovingInt(const NonmovingInt&) = default;
    NonmovingInt& operator=(const NonmovingInt&) = default;
    NonmovingInt(NonmovingInt&&) = delete;
    NonmovingInt& operator=(NonmovingInt&&) = delete;
};

struct NoncopyableInt {
    // пусть членом структуры станет перемещаемый тип
    NonmovingInt value;
    // копировать нельзя, перемещать!
    NoncopyableInt(const NoncopyableInt&) = delete;
    NoncopyableInt& operator=(const NoncopyableInt&) = delete;

    NoncopyableInt(NoncopyableInt&&) = default;
    NoncopyableInt& operator=(NoncopyableInt&&) = default;
};

int main() {
    NoncopyableInt source{1};
    NoncopyableInt target(move(source));
    cout << "Неужели перенеслось?"s << endl;
    return 0;
}
example.cpp: In function 'int main()':
example.cpp:27:39: error: use of deleted function 'NoncopyableInt::NoncopyableInt(NoncopyableInt&&)'
     NoncopyableInt target(move(source));
example.cpp:21:5: note: 'NoncopyableInt::NoncopyableInt(NoncopyableInt&&)' is implicitly deleted because the default definition would be ill-formed:
     NoncopyableInt(NoncopyableInt&&) = default;
     ^~~~~~~~~~~~~~
example.cpp:21:5: error: use of deleted function 'NonmovingInt::NonmovingInt(NonmovingInt&&)'
example.cpp:11:5: note: declared here
     NonmovingInt(NonmovingInt&&) = delete;
С простым разобрались, перейдем к интересному. Тип принимаемого значения в конструкторе копирования отличается от конструктора перемещения. Вместо const NoncopyableInt& при перемещении конструктор получает NoncopyableInt&&. Это тоже ссылка на объект типа NoncopyableInt, но необычная. Не ссылка на ссылку, а специальная rvalue-ссылка. Она относится к объекту, к адресу которого мы не можем получить прямой доступ. Такие ссылки бывают на временные объекты. Вызывая функцию move для обычного объекта, просто приводим его к типу rvalue-ссылки. rvalue-ссылки позволяют компилятору разобраться, нужно ли ему вызывать конструктор копирования или конструктор перемещения. Так компилятор отличает временные объекты от постоянных.
📖 rvalue-ссылки в С++, как и другие типы ссылок — отдельная большая тема, которая не покрывается этим курсом. В качестве дополнительного чтения можно посоветовать, например, статьи: первую и вторую.
Перемещение под контролем
Программисту бывает недостаточно стандартной реализации конструкторов и операторов присваивания — как копирующих, так и перемещающих. В таких случаях он может определить эти методы самостоятельно. Полезной функцией для конструктора перемещения и перемещающего оператора присваивания оказывается exchange из библиотеки <utility>.
Прочитайте о функции exchange или попробуйте догадаться, что будет выведено в результате:
int y = 1;
int z = 2;
int x = exchange(y, z);
cout << x << " " << y << " " << z << endl;
Часто функцией exchange пользуются, чтобы гарантировать определенное значение в перемещаемом объекте после собственно перемещения.
Спрячем кролика в шляпу:
class Rabbit {
public:
    enum class Color { WHITE, BLACK };

    Rabbit(Color color)
        : color_(color) 
    {
    }
    // копирование кроликов, как и слонов, в природе не предусмотрено
    Rabbit(const Rabbit& other) = delete;
    Rabbit& operator=(const Rabbit& other) = delete;

    Rabbit(Rabbit&& other) {
        ???
    }
    Rabbit& operator=(Rabbit&& other) {
        ???
        return *this;
    }

    Color GetColor() const {
        return color_;
    }

private:
    Color color_;
};

class Hat {
public:
    Hat(Rabbit&& rabbit)
        : rabbit_(move(rabbit)) 
    {
    }
    // не стоит копировать шляпу
    Hat(const Hat& other) = delete;
    Hat& operator=(const Hat& other) = delete;
    // но вот переместить шляпу можно
    Hat(Hat&& other) = default;
    Hat& operator=(Hat&&) = default;
    // в любой момент можно посмотреть, есть ли кролик в шляпе
    const Rabbit& GetRabbit() const {
        return rabbit_;
    }
private:
    Rabbit rabbit_;
};
Допустим, нужно переместить шляпу с белым кроликом внутри:
Hat magic_hat{Rabbit{Rabbit::Color::WHITE}};
Hat other_magic_hat{move(magic_hat)};
Продвинутый фокусник хотел бы знать, что случится с кроликом в шляпе magic_hat. Конкретно его интересует цвет животного. Посмотрим, что будет, если оставить перемещающие методы на усмотрение компилятору:
class Rabbit {
    ...
    Rabbit(Rabbit&& other) = default;
    Rabbit& operator=(Rabbit&& other) = default;
    ...
}
...
int main() {
    Hat magic_hat(Rabbit(Rabbit::Color::WHITE));
    Hat other_magic_hat(move(magic_hat));
    if (magic_hat.GetRabbit().GetColor() == Rabbit::Color::WHITE) {
        cout << "Кролик перемещён, но его цвет белый"s << endl;
    }
    else if (magic_hat.GetRabbit().GetColor() == Rabbit::Color::BLACK) {
        cout << "Кролик перемещён, но его цвет чёрный"s << endl;
    }
    else {
        cout << "Кажется, мы не уверены на счёт цвета кролика"s << endl;
    }
}
Эта программа сообщит:
Кролик перемещён, но его цвет белый
Кролик переместился, белый цвет остался. Для программиста ничего страшного не произошло. Объект остался в валидном состоянии. Но для фокусника этот результат выглядит странно. Хорошим тоном будет задать значение цвета, которое объект будет получать по умолчанию после перемещения. Пусть перемещенный кролик становится невидимым благодаря функции exchange:
Rabbit(Rabbit&& other) {
    color_ = exchange(other.color_, Color::INVISIBLE);
}

Rabbit& operator=(Rabbit&& other) {
    color_ = exchange(other.color_, Color::INVISIBLE);
    return *this;
}
Теперь точно известно, что в magic_hat после перемещения будет лежать невидимый кролик.
В итоговом проекте спринта вы будете добавлять поддержку move-семантики для своего вектора и списка. Функция exchange будет полезна для гарантии, что указатель на данные не остался в перемещаемом объекте, а был заменён на nullptr.
Тайные техники передачи аргументов
Тайные техники стандартных библиотек
При добавлении слона в толпу слонов использовался метод вектора push_back. Причём  он корректно работал и для временного объекта, в том числе для объекта, получаемого из функции move, и для постоянного:
// копируем постоянного слона в толпу
crowd_of_elephants.push_back(heavy_elephant);
// перемещаем временного слона в толпу
crowd_of_elephants.push_back(BuyElephant());
// перемещаем постоянного слона в толпу при помощи move
crowd_of_elephants.push_back(move(heavy_elephant));
В С++ функции с одинаковыми названиями компилятор различает благодаря списку аргументов. При вызове с аргументом компилятор ищет функцию с нужным именем и максимально близким типом аргумента. Идеальный вариант — когда типы совпадают. Пользователь передал объект типа int, а функция принимает объект типа int. Если стопроцентного попадания в тип аргумента не произошло, компилятор будет искать разрешенный вариант приведения одного типа в другой, чтобы хоть какая-нибудь функция с заданным именем могла быть вызвана для переданного объекта.

Конечно! Когда пишем метод Get для члена класса или для объекта контейнера, делаем два метода: один константный, другой нет. Это то же самое, ведь константность метода значит, что один из аргументов — указатель this — будет передан как const. Список аргументов отличается, и компилятор знает, какой из методов в каком случае вызывать.
Точно! Так же работает вызов конструкторов. Компилятор понимает, какой конструктор вызвать, в зависимости от переданных в него аргументов.
Если открыть описание метода push_back, обнаружим, что это не один метод, а два:
void push_back( const T& value );
void push_back( T&& value );
Первый метод принимает константную ссылку на постоянный объект. Значит, в этом методе объект будет копироваться. Второй метод принимает rvalue-ссылку — значит, объект будет перемещен, если это возможно.
Воспользуйтесь описаниями методов и функций и разделите методы и функции по двум группам: поддерживающие перемещение и не поддерживающие.
std::map<Key,T,Compare,Allocator>::at
Поддерживают перемещение
std::map<Key,T,Compare,Allocator>::operator[]
Не поддерживают перемещение
std::set<Key,Compare,Allocator>::insert
Поддерживают перемещение
std::stack<T,Container>::push
Поддерживают перемещение
Отдельно нужно сказать о контейнере array, который хранит свои данные в стеке. Этот контейнер поддерживает перемещение, но оно не такое эффективное, как у вектора. В векторе достаточно переместить указатель на данные. Никаких дополнительных действий с элементами не произойдёт. Вектор неперемещаемых элементов переместить можно. Но array работает иначе. Он не хранит указатель на данные, и для реализации перемещения нужно переместить каждый из элементов. Отсюда следуют два вывода:
Для перемещения array его элементы должны быть перемещаемыми;
Сложность перемещения array — линейная от количества элементов, что значительно хуже константной сложности перемещения вектора.
Тайные техники в жизни программистов
Немного изменим код примера со слоном:
int main() {
    WhiteElephant heavy_elephant = BuyElephant();
    vector<WhiteElephant> crowd_of_elephants;
    AddToCrowd(crowd_of_elephants, heavy_elephant);
    AddToCrowd(crowd_of_elephants, BuyElephant());
}
Чтобы добавить слона в толпу, нужно передать объект в функцию AddToCrowd. У программиста есть несколько вариантов, как это сделать:
по значению
void AddToCrowd(vector<WhiteElephant>& crowd, WhiteElephant elephant);
по константной ссылке
void AddToCrowd(vector<WhiteElephant>& crowd, const WhiteElephant& elephant);
по rvalue-ссылке
void AddToCrowd(vector<WhiteElephant>& crowd, WhiteElephant&& elephant)
Варианты с передачей по указателю тоже существуют, но рассматривать их не станем. В этом контексте они аналогичны передаче по ссылке.
Вариант с неконстантной ссылкой тоже отложим. Если ссылка будет неконстантной, то в толпу можно будет переместить только неконстантных животных, а это ограничение слишком сильное и ненужное.
Выбирая между оставшимися тремя способами — по значению, по константной ссылке и по rvalue-ссылке — программист будет руководствоваться двумя принципами:
эффективностью кода или, в данном случае, минимальным количеством копирований;
удобством для того, кто будет этот метод вызывать.
Посчитаем копирования в каждом из случаев:
// для постоянных объектов - одно копирование
// для временных объектов - одно копирование
void AddToCrowd(vector<WhiteElephant>& crowd, const WhiteElephant& elephant) {
    crowd.push_back(elephant);
}
// постоянные объекты не поддерживаются
// для временных объектов - одно перемещение
// если объект перемещаемый, то перемещение станет копированием
void AddToCrowd(vector<WhiteElephant>& crowd, WhiteElephant&& elephant) {
    crowd.push_back(move(elephant));
}
// постоянные объекты - одно копирование и одно перемещение
// временные объекты - два перемещения
// если объект перемещаемый, то перемещение станет вторым копированием
void AddToCrowd(vector<WhiteElephant>& crowd, WhiteElephant elephant) {
    crowd.push_back(move(elephant));
}


Неожиданным лидером по количеству перемещений вместо копирования становится передача аргумента по значению.
Временные объекты копироваться не будут. Они будут перемещены дважды: первый раз в сам объект аргумента, во второй раз — в контейнер.
Постоянные объекты, которые можно переносить, скопируются один раз, в аргумент, а в контейнер они будут перемещены.
Но нужно учитывать два недостатка:
Эта функция будет работать и для перемещаемых, и для неперемещаемых объектов. Только для неперемещаемых объектов она становится неэффективной — функция move не поможет переместить неперемещаемое. В этом случае перемещение превращается в тыкву и заменяется на второе копирование, что неприятно и малоэффективно.
Если перемещение по сложности не уступает копированию — например, как у контейнера array, — два перемещения становятся менее эффективными, чем одно копирование, и лучше выбрать вариант с константной ссылкой.
Техники стандартных библиотек против техники обычных программистов
Но ведь создатели стандартных библиотек использовали две разные функции! Надо разобраться, почему в их случае это было верно, а в нашем подойдёт вариант с одной функцией, принимающей аргумент по значению.
Стандартные классы и алгоритмы — шаблоны, и они должны поддерживать все возможные шаблонные параметры. Это накладывает строгие требования на дизайн методов класса. Методы и функции должны быть максимально эффективны и для перемещаемых, и для неперемещаемых объектов.
Кроме того стандартные библиотеки обязаны поддерживать и старые стандарты языков. Раньше, до появления возможности перемещать, многие объекты были неперемещаемыми, а библиотеки принимали аргументы по константной ссылке. Если бы создатели библиотек резко перешли на передачу аргументов по значению, код старых стандартов заметно замедлился бы, так как в этом случае количество копирований бы выросло.
Но когда программист пишет свое приложение, он знает, с какими объектами собирается работать. Если объекты перемещаемые, стоит выбрать передачу аргумента по значению. Если неперемещаемые — по константной ссылке. Такой механизм позволяет сохранить эффективность кода и избежать дублирования.
📖 Если будете писать шаблонный класс, который сможет работать с максимально возможным количеством типов и классов, можно использовать прием с двумя одноименными методами или познакомиться поближе с универсальными ссылками. Примером использования универсальной ссылки — метод std::vector<T,Allocator>::emplace. У использования универсальных ссылок в шаблонах есть особенность: тип аргумента становится отдельным шаблонным параметром. В сигнатуре тип Args не тот же самый, что тип T. Это позволяет компилятору подобрать максимально подходящий тип аргумента для объекта, который передается.
Move-итераторы
Последним штрихом к вашему арсеналу способов перемещения объектов будут move-итераторы.
Посмотрите на пример, написанный любителем творчества Пелевина:
void Print(const string& book_list_name, const vector<string>& book_list) {
    cout << book_list_name << endl;
    for (const string& s : book_list) {
        cout << s << endl;
    }  
}

int main() {
    vector<string> my_books = {"Chapaev i Pustota"s, "Nepobedimoe solnce"s, "Generation P"s, "Jizn' nasekomyh"s,
                               "Taynie vidy na goru Fudzi"s};
    vector<string> given_to_read(my_books.begin(), my_books.begin() + 2);
    vector<string> to_present(my_books.begin() + 2, my_books.end());

    Print("my_books", my_books);
    cout << endl;
    Print("given_to_read", given_to_read);
    cout << endl;
    Print("to_present", to_present);
}
Вектор my_books содержит названия книг, которыми этот любитель владеет. Вектор given_to_read — книги, которые он дал почитать и ожидает к возврату. Вектор to_present — книги, которые владелец хотел бы подарить друзьям, чтобы приобщить их к прекрасному.
Для создания векторов given_to_read и to_present использованы конструкторы по итераторам. Названия книг просто скопированы из вектора-полки в два других. На экран будет выведено:
my_books
Chapaev i Pustota
Nepobedimoe solnce
Generation P
Jizn' nasekomyh
Taynie vidy na goru Fudzi

given_to_read
Chapaev i Pustota
Nepobedimoe solnce

to_present
Generation P
Jizn' nasekomyh
Taynie vidy na goru Fudzi
Начальный вектор названий остался без изменений. В целом, логика верная. Книги, которые отданы почитать, всё ещё принадлежат автору, как и те, которые он только собирается подарить. Поэтому удалять что-либо из вектора my_books не нужно.
Прошло время, и книги, приготовленные в подарок, переданы новым владельцам. Просто переименуем переменную to_present в presented:
vector<string> presented(book_shelf.begin() + 2, book_shelf.end());
Но теперь, следуя логике, следует не копировать названия, а просто перенести их. Не хотелось бы кардинально переписывать программу, писать цикл, использовать push_back и move. Можно просто изменить семантику итераторов — превратить их из обычных в итераторы перемещения. Для этого нужна библиотека iterator и функция make_move_iterator:
int main() {
    vector<string> my_books = {"Chapaev i Pustota"s, "Nepobedimoe solnce"s, "Generation P"s, "Jizn' nasekomyh"s,
                               "Taynie vidy na goru Fudzi"s};
    vector<string> given_to_read(my_books.begin(), my_books.begin() + 2);
    vector<string> presented(make_move_iterator(my_books.begin() + 2), make_move_iterator(my_books.end()));

    Print("my_books", my_books);
    cout << endl;
    Print("given_to_read", given_to_read);
    cout << endl;
    Print("presented", presented);
}

## Лучшие практики для C++17

### 1. Использование std::move

**ХОРОШО:**
```cpp
// Используй std::move для явного перемещения
std::vector<std::string> data = GetData();
ProcessData(std::move(data)); // data больше не используется

// Используй std::move в конструкторах перемещения
class MyClass {
    std::string name_;
    std::vector<int> data_;
public:
    MyClass(MyClass&& other) noexcept
        : name_(std::move(other.name_))
        , data_(std::move(other.data_)) {}
};
```

**ПЛОХО:**
```cpp
// НЕ используй std::move без необходимости
std::string GetName() {
    std::string name = "test";
    return std::move(name); // Плохо! Мешает RVO
}

// НЕ используй std::move для локальных переменных в return
auto func() {
    std::vector<int> vec;
    return std::move(vec); // Плохо! Компилятор сам оптимизирует
}
```

### 2. Конструкторы и операторы перемещения

**ХОРОШО:**
```cpp
class Resource {
    int* data_;
public:
    // Помечай как noexcept для лучшей производительности
    Resource(Resource&& other) noexcept
        : data_(std::exchange(other.data_, nullptr)) {}
    
    Resource& operator=(Resource&& other) noexcept {
        if (this != &other) {
            delete[] data_;
            data_ = std::exchange(other.data_, nullptr);
        }
        return *this;
    }
};
```

**ПЛОХО:**
```cpp
class Resource {
    int* data_;
public:
    // Без noexcept и проверки на самоприсваивание
    Resource(Resource&& other) {
        data_ = other.data_;
        other.data_ = nullptr; // Используй std::exchange
    }
    
    Resource& operator=(Resource&& other) {
        data_ = other.data_; // Утечка памяти!
        other.data_ = nullptr;
        return *this;
    }
};
```

### 3. Передача параметров

**ХОРОШО:**
```cpp
// Для перемещаемых типов - передача по значению
void ProcessString(std::string str) {
    strings_.push_back(std::move(str));
}

// Для неперемещаемых типов - по const&
void ProcessData(const ExpensiveNonMovable& data) {
    // обработка
}

// Универсальные ссылки для шаблонов
template<typename T>
void AddItem(T&& item) {
    items_.push_back(std::forward<T>(item));
}
```

**ПЛОХО:**
```cpp
// Избыточные перегрузки
void ProcessString(const std::string& str) {
    strings_.push_back(str);
}
void ProcessString(std::string&& str) {
    strings_.push_back(std::move(str));
}

// Неэффективная передача по значению для неперемещаемых типов
void ProcessData(ExpensiveNonMovable data) { // Лишнее копирование
    // обработка
}
```

### 4. Контейнеры и алгоритмы

**ХОРОШО:**
```cpp
// Используй emplace для конструирования на месте
std::vector<std::string> vec;
vec.emplace_back(10, 'a'); // Конструирует строку на месте

// Используй move-итераторы для перемещения диапазонов
std::vector<std::string> source = GetStrings();
std::vector<std::string> dest(
    std::make_move_iterator(source.begin()),
    std::make_move_iterator(source.end())
);

// Резервируй место для избежания реаллокаций
std::vector<std::string> vec;
vec.reserve(expected_size);
```

**ПЛОХО:**
```cpp
// Используй push_back вместо emplace_back без необходимости
std::vector<std::string> vec;
vec.push_back(std::string(10, 'a')); // Лишний временный объект

// Копирование вместо перемещения
std::vector<std::string> source = GetStrings();
std::vector<std::string> dest(source.begin(), source.end()); // Копирование

// Не резервируй место заранее
std::vector<std::string> vec;
for (int i = 0; i < 1000; ++i) {
    vec.push_back(std::to_string(i)); // Множественные реаллокации
}
```

### 5. RAII и умные указатели

**ХОРОШО:**
```cpp
// Используй умные указатели вместо сырых
std::unique_ptr<Resource> CreateResource() {
    return std::make_unique<Resource>();
}

// Перемещай unique_ptr
std::unique_ptr<Resource> resource = CreateResource();
ProcessResource(std::move(resource));

// Используй auto для типов
auto resource = std::make_unique<Resource>();
```

**ПЛОХО:**
```cpp
// Сырые указатели без RAII
Resource* CreateResource() {
    return new Resource(); // Кто будет удалять?
}

// Копирование вместо перемещения unique_ptr
std::unique_ptr<Resource> resource = CreateResource();
ProcessResource(resource); // Ошибка компиляции!

// Явное указание типов там, где можно auto
std::unique_ptr<Resource> resource = std::make_unique<Resource>();
```

### 6. Исключения и move-семантика

**ХОРОШО:**
```cpp
class SafeClass {
public:
    // noexcept гарантирует отсутствие исключений
    SafeClass(SafeClass&& other) noexcept
        : data_(std::move(other.data_)) {}
    
    SafeClass& operator=(SafeClass&& other) noexcept {
        if (this != &other) {
            data_ = std::move(other.data_);
        }
        return *this;
    }
};
```

**ПЛОХО:**
```cpp
class UnsafeClass {
public:
    // Без noexcept - может бросать исключения
    UnsafeClass(UnsafeClass&& other)
        : data_(std::move(other.data_)) {
        // Потенциально опасный код
        if (SomeCondition()) {
            throw std::runtime_error("Error");
        }
    }
};
```

### 7. Оптимизации компилятора

**ХОРОШО:**
```cpp
// Доверяй RVO и NRVO
std::string CreateString() {
    std::string result = "Hello";
    result += " World";
    return result; // Не используй std::move
}

// Используй временные объекты для цепочек вызовов
auto result = CreateObject()
    .Method1()
    .Method2()
    .Method3();
```

**ПЛОХО:**
```cpp
// Мешай RVO
std::string CreateString() {
    std::string result = "Hello";
    result += " World";
    return std::move(result); // Плохо!
}

// Лишние промежуточные переменные
auto temp1 = CreateObject();
auto temp2 = temp1.Method1();
auto temp3 = temp2.Method2();
auto result = temp3.Method3();
```

### 8. Специфика C++17

**ХОРОШО:**
```cpp
// Используй structured bindings с move
auto [key, value] = std::move(pair);

// Используй if constexpr для условной компиляции
template<typename T>
void process(T&& obj) {
    if constexpr (std::is_move_constructible_v<T>) {
        container_.push_back(std::move(obj));
    } else {
        container_.push_back(obj);
    }
}

// Используй std::optional для возврата значений
std::optional<std::string> FindValue(const std::string& key) {
    if (auto it = map_.find(key); it != map_.end()) {
        return it->second;
    }
    return std::nullopt;
}
```

**ПЛОХО:**
```cpp
// Игнорируй возможности C++17
std::pair<std::string, int> pair = GetPair();
std::string key = pair.first;
int value = pair.second;

// Используй старые способы условной компиляции
template<typename T>
void process(T&& obj) {
    // Старый способ через SFINAE
}

// Используй исключения для контроля потока
std::string FindValue(const std::string& key) {
    auto it = map_.find(key);
    if (it == map_.end()) {
        throw std::runtime_error("Not found");
    }
    return it->second;
}
```

### 9. Производительность

**ХОРОШО:**
```cpp
// Минимизируй количество аллокаций
class Buffer {
    std::vector<char> data_;
public:
    void Resize(size_t new_size) {
        data_.resize(new_size);
    }
    
    void Append(const char* str, size_t len) {
        data_.insert(data_.end(), str, str + len);
    }
};

// Используй move-семантику в алгоритмах
std::sort(vec.begin(), vec.end(), 
    [](const std::string& a, const std::string& b) {
        return a < b;
    });
```

**ПЛОХО:**
```cpp
// Множественные аллокации
class Buffer {
    std::string data_;
public:
    void Append(const std::string& str) {
        data_ += str; // Потенциальная реаллокация каждый раз
    }
};

// Копирование в лямбдах
std::sort(vec.begin(), vec.end(), 
    [](std::string a, std::string b) { // Копирование параметров
        return a < b;
    });
```

### 10. Отладка и тестирование

**ХОРОШО:**
```cpp
// Добавляй проверки в debug-режиме
class MyClass {
    std::unique_ptr<int[]> data_;
    size_t size_;
public:
    MyClass(MyClass&& other) noexcept
        : data_(std::move(other.data_))
        , size_(std::exchange(other.size_, 0)) {
        assert(other.data_ == nullptr);
    }
};

// Используй статические проверки
static_assert(std::is_nothrow_move_constructible_v<MyClass>);
static_assert(std::is_nothrow_move_assignable_v<MyClass>);
```

**ПЛОХО:**
```cpp
// Игнорируй проверки состояния
class MyClass {
    std::unique_ptr<int[]> data_;
    size_t size_;
public:
    MyClass(MyClass&& other) noexcept
        : data_(std::move(other.data_))
        , size_(other.size_) {
        // Не очищаем состояние other
    }
};
```
