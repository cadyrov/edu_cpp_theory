# Ответы на тест: Эффективные линейные контейнеры

## Правильные ответы:

1. **B** - Увеличивается в 2 раза
2. **B** - Код с reserve(1000) перед циклом
3. **B** - Неопределенное поведение (указатель может инвалидироваться)
4. **B** - Как массив указателей на чанки памяти
5. **C** - Вставка в начало
6. **A** - Выведет 1 (итераторы deque не инвалидируются при push_back)
7. **B** - std::deque
8. **B** - Инвалидируются
9. **A** - O(1)
10. **B** - std::sort(lst.begin(), lst.end()) - требует итераторы произвольного доступа
11. **B** - Не инвалидируются при модификации контейнера
12. **B** - 2 (итератор остается валидным)
13. **B** - На стеке
14. **C** - std::array<int, 5> arr = {1, 2, 3, 4, 5};
15. **B** - Указатель на строку и её длина
16. **B** - Dangling reference (substr создает временный объект)
17. **B** - void func(std::string_view sv) - по значению
18. **C** - Пытается уменьшить capacity до size
19. **C** - swap с пустым вектором
20. **B** - vec.emplace_back(args) - конструирует на месте
21. **C** - O(1) амортизированная
22. **A** - Элементы после позиции вставки сдвигаются
23. **C** - std::copy_backward
24. **B** - Неопределенное поведение
25. **A** - std::vector (лучшая производительность для случайного доступа)
26. **C** - 5
27. **B** - Занимает меньше памяти чем std::list
28. **B** - Может удваиваться
29. **B** - void process(std::string_view sv) - корректное использование
30. **B** - Базовая гарантия
31. **B** - Обменивает указатели на данные
32. **C** - std::list
33. **A** - 1 (копирование массива)
34. **B** - Удаление элемента из середины
35. **C** - Создание указателя на данные
36. **B** - emplace_back наиболее эффективен
37. **B** - Поддерживают произвольный доступ
38. **C** - Size станет равен 0
39. **D** - Любой из перечисленных (все подходят для стека)
40. **B** - 1 (true) - capacity не влияет на сравнение содержимого 