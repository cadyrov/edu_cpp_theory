Эффективный вектор
О векторе сказано уже много. Резюмируем ваши знания. Его главное свойство, объясняющее все сильные и слабые стороны, — это последовательное расположение всех элементов в памяти. Создадим вектор из трех элементов и добавим один элемент в конец:
vector<int> v = {1, 2, 3};
v.push_back(4);
При создании вектора на стеке появится объект под именем v, который будет содержать информацию о векторе:
int* data — указатель на выделенный на куче отрезок памяти для трех элементов типа int;
size — количество элементов, которые в данный момент находятся в векторе;
capacity — количество элементов, для которых потенциально есть место в выделенной памяти, тоже три.
Данные всех трех параметров можно получить через одноименные методы вектора.
Что будет выведено в результате работы этой программы?
vector<int> v = {1, 2, 3};
v.push_back(4);
const int* data = v.data();
for (int i = 0; i < v.size(); ++i) {
    cout << *(data + i) << ' ';
}
cout << endl;
for (int i = 0; i < v.capacity(); ++i) {
    cout << *(data + i) << ' ';
}
1 2 3 4 (и дальше два неожиданных числа)
Два неизвестных числа у каждого пользователя могут быть разными. Это не цифры из лотереи, а некий мусор, лежавший в памяти, которую сейчас использует вектор для хранения элементов. Capacity вектора выросла вдвое: была 3, стала 6. Но size вектора увеличился на единицу: был 3, стал 4. Когда появятся новые элементы, вектор просто перезапишет их на место мусора. С дальнейшим добавлением элементов size станет равен capacity, и вектору снова придётся её удвоить.
Для освобождения от мусора есть специальный метод. Он нечасто используется и называется shrink_to_fit. Метод переаллоцирует память так, чтобы capacity стала равна size. Интересно, что этот запрос необязательно будет выполнен. Реализация контейнера такова, что запрос можно оставить без внимания. Да, и такое бывает.
Вернёмся к добавлению элементов в вектор.
В каком порядке будут выполнены эти шаги при работе метода push_back?
Выделение нового блока памяти в два раза больше предыдущего
Добавление нового элемента
Копирование старых элементов из предыдущего блока памяти в новый
Освобождение предыдущего блока памяти, увеличение capacity и size
Проверка, достаточно ли capacity, чтобы добавить новый элемент
Правильный ответ
5, 1, 3, 2, 4
Как только добавим в вектор ещё два элемента, место кончится опять. Снова придётся перевыделять память, увеличивая capacity в два раза, и скопировать туда элементы старого блока. Согласитесь, это неэффективно, если мы заранее знаем, сколько элементов должно быть в векторе. Именно для таких случаев есть метод reserve, который вы уже встречали в курсе.
Какой ещё важный сторонний эффект у того, что при добавлении элемента в вектор память может перевыделяться?
Известны ошибки, которые возникают при копировании элементов вектора в новый участок памяти. Нужно их опасаться.
Указатель, полученный методом data, будет инвалидироваться. После любых операций, которые потенциально могут перевыделять память, лучше этот указатель переопределить, вызвав метод data заново.
Не забудьте ответ на этот вопрос. Указатель вектора имеет свойство инвалидироваться или, иначе говоря, становиться неверным, недействительным.
Реализация SimpleVector похожа на реализацию стандартного вектора. Внутри вектора есть указатель на участок памяти, где располагаются элементы, и по ним можно итерировать. В конце этой темы вернёмся к SimpleVector и улучшим его реализацию, добавив метод Reserve.
Эффективный дек
Вы уже много знаете о векторе, но ещё не изучали, как работает дек, в чём его сила и слабость. С деком — двунаправленной очередью — вы познакомились в четвёртом спринте. В этом уроке рассмотрим его реализацию и выясним, в каких случаях стоит выбрать вектор, а в каких — дек.
Принципиальная разница дека и вектора: дек не обещает хранить элементы в памяти подряд. Сразу, не думая и не вникая в реализацию, можно сказать, что итерироваться по вектору должно быть проще, чем по деку. Проверим интуицию — разберёмся, как организована итерация по деку. Создадим дек, добавим в него три элемента при инициализации, потом ещё один в конец и один в начало:
deque<int> d = {1, 2, 3};
d.push_back(4);
d.push_front(0);
Будь это вектор, перевыделение памяти и копирование элементов произошли бы уже дважды — при добавлении каждого из новых элементов. Но дек работает иначе:
В стеке будет создан объект d, где сохранится количество элементов, расположенных в памяти. Кроме этого, внутри дека есть вектор, хранящий указатели на участки памяти, где находятся элементы. Иначе эти участки называются чанками. Изначально у дека будет один чанк размера три, где будут лежать элементы 1, 2 и 3.

Теперь вызовем push_back. Места в памяти для нового элемента нет. Дек выделит новый чанк — например, тоже размера три. Положим туда новый элемент на первое место. Не забудем добавить в вектор чанков новый указатель.

Пока всё идет неплохо. Вызываем push_front, и начинается самое интересное. Положить элемент нужно так, чтобы потом найти его по порядковому номеру. Мы же хотим удобный доступ к элементам. Секрет в том, что дек в очередной раз выделит новый чанк и положит туда 0, но не в начало, а в конец. Первые два элемента этого чанка пока останутся пустыми. Точнее там будет лежать некий мусор. Но внутри своей структуры дек держит специальный параметр "shift". Этот параметр говорит, насколько первый элемент дека сдвинут от начала чанка. В нашем случае shift = 2.

Очевидно, дек легко найдёт элемент по номеру его позиции. А значит, этот контейнер отлично поддерживает итераторы произвольного доступа.
Откройте свою IDE, выполните задания и ответьте на вопросы.

Задание 1
Напишите программу, которая:
Использует push_back и вставляет в вектор 1000000 случайных элементов. Не применяйте Reserve в этом случае. Представьте, что не знаете, сколько элементов будет вставлено;
Использует push_back и вставляет столько же элементов в дек;
Делает то же самое, но для 5000000 элементов.
Попробуйте увеличивать и уменьшать количество элементов. Примените профилировщик, чтобы сравнить результаты.
Какой контейнер оказался эффективнее?

Задание 2
Сделайте другой тест. Вы знаете, что итерировать по вектору должно быть проще, чем по деку. Чтобы проверить это, используйте сортировку. Напишите программу, которая бы сортировала 1000000 случайных элементов в векторе и в деке. Измените количество элементов. Сравните результаты.
Какой контейнер оказался эффективнее?
Возникает вопрос: что делать, если программист не может однозначно предсказать происходящее с контейнером. Например, это некий буфер, куда мы будем записывать данные, а потом должны по запросу пользователя их отсортировать? Здесь однозначного ответа нет, и не верьте тем, кто говорит, что знает его. Когда невозможно предсказать, как контейнер будет использоваться, подобрать подходящий можно, проведя измерения. Используйте профилировщик. Точные данные о времени выполнения операций помогут принять верное решение о выборе контейнера.
Инвалидация указателей и ссылок
Указатели на элементы вектора и дека при удалении/вставке
Вы уже знаете, что произойдёт с указателем data_ptr:
vector<int> v = {1, 2, 3};
int* data_ptr = v.data();
v.push_back(4);
Если при вставке нового элемента память перевыделена, элементы будут находиться уже по другому адресу. То же самое случится с любыми указателями на элементы вектора, если произойдет модификация контейнера.

Закрепим. Что будет выведено на экран?
vector<string> oh_my_god = { "Oh "s, "my "s, "God"s };
const string* ptr = &oh_my_god[0];
const int exclamations = 1000;

cout << *ptr << *(ptr + 1) << *(ptr + 2) << endl;

for (int i = 0; i < exclamations; ++i) {
    oh_my_god.push_back("!");
}

cout << *ptr << *(ptr + 1) << *(ptr + 2) << endl;
Указатель будет инвалидирован, и однозначно ответить, что будет выведено на экран, невозможно. Иногда в программировании ответ «поведение/значение не определено»‎ — правильный.
Заменим контейнер на дек:
deque<string> oh_my_god = { "Oh "s, "my "s, "God"s };
string* ptr = &oh_my_god[0];
const int exclamations = 1000;

cout << *ptr << *(ptr + 1) << *(ptr + 2) << endl;

for (int i = 0; i < exclamations; ++i) {
    oh_my_god.push_back("!");
}

cout << *ptr << *(ptr + 1) << *(ptr + 2) << endl;
Преимущество дека перед вектором в том, что при вставке в начало и в конец копирования не происходит. Это спасает указатели. В данном примере будет выведено:
Oh my God
Oh my God
Вставим элементы в середину:
deque<string> oh_my_god = { "Oh "s, "my "s, "God"s };
string* ptr = &oh_my_god[0];
const int exclamations = 1000;

cout << *ptr << *(ptr + 1) << *(ptr + 2) << endl;

// Вставим восклицательные знаки после Oh my
auto it = oh_my_god.begin() + 2;
oh_my_god.insert(it, exclamations, string("!"s));

// Выведем весь дек с помощью ptr
for (int i = 0; i < oh_my_god.size(); ++i) {
    cout << *(ptr + i);
}
При выводе дек выглядит не так, как планировалось — мало восклицательных знаков и пропал God:
Oh my God
Oh my !!!!!!!!!!!!!!
Резюме:
При вставке/удалении в конец вектора указатели инвалидируются, если происходит аллокация памяти;
При вставке/удалении из середины или в начало вектора указатели на последующие элементы инвалидируются;
При вставке/удалении в начало или в конец дека — сохраняются;
При вставке/удалении из середины дека указатели инвалидируются.
Ссылки на элементы вектора и дека при удалении/вставке
Для ссылок верно всё, что было верно для указателей:
При вставке/удалении в конец вектора указатели инвалидируются, если происходит аллокация памяти;
При вставке/удалении из середины или в начало вектора указатели на последующие элементы инвалидируются;
При вставке/удалении в начало или в конец дека — сохраняются;
При вставке/удалении из середины дека указатели инвалидируются.
Инвалидация итераторов
Указатели и ссылки ведут себя одинаково. У вектора они инвалидируются всегда. У дека они сохраняются при вставке в начало или в конец, но инвалидируются при вставке в середину. Утверждение «При вставке/удалении в середину указатели и ссылки инвалидируются» подходит для обоих контейнеров.

Разберемся, что происходит с итераторами. В целом они умнее обычных ссылок и указателей, поэтому у них есть шансы спастись после изменения контейнера. Поэкспериментируем:
int main() {
    // создадим вектор с одним элементом
    vector<int> numbers = {1};
    // найдём итератор на начало
    auto it = numbers.begin();
    cout << *it << endl;
    // вставим достаточно много элементов,
    // чтобы точно вызвать перевыделение памяти
    for (int i = 0; i < 1000; ++i) {
        numbers.push_back(i);
    }
    cout << *it << endl;
}
После работы программы увидим на экране:
Второе число может быть другим, это просто мусор. Выходит, итератор вектора инвалидировался. В целом ожидаемо, так как внутри итератора находится указатель, который, как вы уже знаете, точно валидируется.
Проведем аналогичный эксперимент с деком. В том же примере заменим контейнер:
int main() {
    // заменим контейнер
    deque<int> numbers = {1};
    ...
}
Результат на экране:
1
1
Значение элемента не изменилось. Выглядит многообещающе, но итераторы нужны, чтобы итерировать. Проверим, способен ли ещё на это наш итератор:
int main() {
    deque<int> numbers = {1};
    auto it = numbers.begin();
    cout << *it << endl;

    for (int i = 0; i < 1024; ++i) {
        numbers.push_back(i);
    }
    // попытаемся вывести последний элемент из дека
    cout << *it << " " << *(it + numbers.size() - 1) << endl;
}
Итератор очень старался, но не смог. И всё сломалось. Значит, итераторы инвалидировались несмотря на все старания.

Резюме: операции с изменением числа элементов инвалидируют итераторы и у вектора, и у дека.
Помощник в работе со строками: std::string_view
Строки похожи на вектор. Их элементы расположены последовательно в памяти. Они поддерживают доступ к элементам по номеру позиции. Разница в том, что строки содержат элементы только символьного типа. Но иногда мы ждем от строк большего, чем от вектора. Обычно строки содержат слова, и будет удобно уметь работать со словами, не создавая из строки новые строки, как мы делали это раньше.
Ускоряем разделение строки на слова
Вспомним пример из поискового сервера:
vector<string> SplitIntoWords(const string& text) {
    vector<string> words;
    string word;
    for (const char c : text) {
        if (c == ' ') {
            if (!word.empty()) {
                // обратите внимание на это место в коде
                // здесь мы каждый раз копируем найденное слово
                // в новый элемент в векторе
                words.push_back(word);
                word.clear();
            }
        } else {
            word += c;
        }
    }
    if (!word.empty()) {
        words.push_back(word);
    }
    return words;
}
Этот код можно переписать, используя итераторы и алгоритм find. Но если посмотреть внимательно, код замедляется не из-за того, как именно мы итерируемся по строке. Каждый раз при добавлении элемента в вектор words создается новая строка — копия слова из text. Это не самый быстрый метод, тем более мы просто хотим знать, где у слов начало и конец. Нам нужны не новые строки, а только позиции в уже имеющейся строке. Для подобных задач и создан std::string_view. Разберемся с нашей функцией:
#include <string_view> // Для использования string_view
// изменим название функции
// предыдущая её версия нам ещё пригодится
// пусть теперь наша функция возвращает вектор элементов string_view
vector<string_view> SplitIntoWordsView(const string& str) {
    vector<string_view> result;
    // 1
    auto pos = str.find_first_not_of(" ");
    // 2
    const auto pos_end = str.npos;
    // 3
    while (pos != pos_end) {
        // 4
        auto space = str.find(' ', pos);
        // 5
        result.push_back(space == pos_end ? str.substr(pos) : str.substr(pos, space - pos));
        // 6
        pos = str.find_first_not_of(" ", space);
    }

    return result;
}
По сути, string_view — указатель на начало некой строки и ее длина. Это не контейнер в прямом смысле: он не содержит элементы, а просто указывает на некую последовательность символов в памяти.
Новая функция вернёт вектор из string_view, то есть вектор указателей, на начало слов и их дли́ны. Как раз то, что нам и было надо — избежим копирования слов в вектор.
Рассмотрим реализацию по пунктам. Следите по комментариям к функции:
Создаём переменную, где будем сохранять начальную позицию для поиска следующего пробела. Иначе говоря, начало слова. Устанавливаем её на позицию первого непробельного символа.
Чтобы остановить поиск, нужен аналог итератора на конец. У string и string_view такую роль выполняет npos — специальная константа класса. Внутри это просто большое число, которое вряд ли когда-нибудь сможет оказаться реальной позицией в строке.
Используем цикл. Выходим из него, если не удалось найти непробельный символ.
В цикле ищем следующий пробел, вызывая метод find, который вернёт позицию ближайшего пробела, или npos, если пробел не найден.
Если пробел не найден, добавляем в вектор всё, начиная с pos. Если найден, выделяем слово от pos длиной space - pos.
Достигнув конца строки, выходим из цикла. Иначе, пропускаем одну позицию — пробел — и начинаем следующую итерацию цикла.
Запустим бенчмарк, где вызовем старую и новую функцию для большой строки:
// создадим очень длинную строку,
// состоящую из слов из ста 'a'
string GenerateText() {
    const int SIZE = 10000000;
    string text(SIZE, 'a');
    for (int i = 100; i < SIZE; i += 100) {
        text[i] = ' ';
    }
    return text;
}

int main() {
    const string text = GenerateText();
    {
        LOG_DURATION("string");
        const auto words = SplitIntoWords(text);
        // выведем первое слово
        cout << words[0] << "\n";
    }
    {
        LOG_DURATION("string_view");
        const auto words = SplitIntoWordsView(text);
        // выведем первое слово
        cout << words[0] << "\n";
    }

    return 0;
}
Результат работы (с максимальной оптимизацией):
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
string: 34 ms
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
string_view: 13 ms
Неплохо.
Но есть подвох
Поправим так, чтобы строка, которую нужно обработать, стала короткой:
int main() {
    const string text = "a b";
    {
        LOG_DURATION("string");
        const auto words = SplitIntoWords(text);
        cout << words[0] << "\n";
    }
    {
        LOG_DURATION("string_view");
        const auto words = SplitIntoWordsView(text);
        cout << words[0] << "\n";
    }

    return 0;
}
Запустим и удивимся:
a
string: 0 ms
⍰
string_view: 0 ms
Там, где мы ожидали увидеть a, внезапно вывелся неизвестный символ.
Предположите, в каком месте кода что-нибудь могло пойти не так. Можете использовать отладчик:
vector<string_view> SplitIntoWordsView(const string& str) {
    vector<string_view> result;
    // 1
    auto pos = str.find_first_not_of(" ");
    // 2
    const auto pos_end = str.npos;
    // 3
    while (pos != pos_end) {
        // 4
        auto space = str.find(' ', pos);
        // 5
        result.push_back(space == pos_end ? str.substr(pos) : str.substr(pos, space - pos));
        // 6
        pos = str.find_first_not_of(" ", space);
    }

    return result;
}

Вы близко подошли к пониманию, что такое временные объекты. В данном случае имеем дело именно с ними. substr конструирует собственную строку. Она потом превращается в элемент типа string_view, чтобы быть записанной в вектор. Подробнее временные объекты разберем в следующей теме.
string_view — это указатель на строку, которую мы никуда не сохранили. Она появилась и исчезла, а мы положили в вектор указатель на что-то переставшее существовать.
Обращение к несуществующему объекту — пример неопределённого поведения. Поведение программы при этом может быть любым. Даже соответствующим нашему представлению о правильной работе. Так получилось в предыдущем примере — мы увидели то слово, которое ожидали. В этом и состоит опасность неопределённого поведения — время от времени может возникать результат который выглядит правильным и кажется, что всё хорошо.
Чтобы исправить ситуацию, заменим тип аргумента. Пусть пользователь передаёт  string_view и сам заботится о том, чтобы строка не оказалась временной. Декларируя таким образом тип аргумента, говорим пользователю, что мы не в ответе за объект самой строки. Если строка исчезнет, все результаты работы функции будут инвалидированы:
vector<string_view> SplitIntoWordsView(string_view str) {
    ...
    result.push_back(space == pos_end ? str.substr(pos) : str.substr(pos, space - pos));
    ...
}
Теперь метод substr работает не со строкой, а с указателем на строку. Никаких временных строк не создаётся.
В отличие от string, объекты string_view легковесные, поэтому их передают в функцию по значению, а не по константной ссылке.
Есть ещё один неочевидный бонус в использовании такой сигнатуры. Компилятор умеет превращать строки в объекты типа string_view . Это значит, что в функцию, ожидающую string_view, можно передать и строку. Все преобразования будут выполнены автоматически. Но если функция ожидает аргумент-строку, передать туда string_view уже не удастся — обратное преобразование из string_view в string возможно только как явное:
void DoSomething(const string& str) { ... }

int main() {
    string_view s = "Hello"sv;
    // Явно преобразуем string_view в string
    DoSomething(string{s});
}
Такая асимметрия в преобразовании между string и string_view происходит из-за того, что string преобразуется в string_view без накладных расходов. Чтобы преобразовать string_view в string, строка выделяет память и копирует в неё всё содержимое string_view. Такая потенциально дорогая операция требует явного преобразования.
Эффективный список
В предыдущем спринте вы написали свой односвязный список. В стандартной библиотеке есть похожий контейнер, но двусвязный. Разница лишь в том, что перемещаться по нему можно не только вперёд, но и назад.
В векторе все элементы расположены последовательно в одном участке памяти. В деке элементы находятся в памяти в небольших чанках. Продолжая идею уменьшения количества последовательно расположенных элементов, приходим к выделению отдельного участка памяти для каждого элемента. При этом каждый элемент будет знать, где лежит предыдущий и следующий.
Рассмотрим удаление элемента из списка:
list<int> numbers = {1, 2, 3, 4};
auto it = find(numbers.begin(), numbers.end(), 3);
numbers.erase(it);
Чтобы найти элемент в списке, используем функцию find. Как и у других линейных контейнеров, собственного метода find у списка нет. Это значит, что поиск будет осуществляться за линейное время и потребует прохода по всем элементам один за другим.
Найдя тройку, вызываем метод erase, который правильно перенаправляет указатели предыдущего и следующего элемента. Время удаления константное.
Вспомните, какова сложность удаления элемента из вектора и дека.
Со вставкой элемента то же самое. Выделяется память под элемент, верно расставляются связи. Таким образом, и вставка, и удаление из середины работают для списка быстрее, чем для вектора и дека.
Функциональность списков ограничена, в том числе потому, что быстро получить доступ к элементу по его индексу невозможно. У списка двунаправленный итератор, а не итератор произвольного доступа. Это усложняет — а иногда делает невозможным — работу некоторых алгоритмов. Например, функцию бинарного поиска для списка использовать нельзя, так как эта функция требует итераторы произвольного доступа.
С другой стороны, алгоритм reverse существует в виде метода списка, и в реализации этого метода нет переставления элементов местами, что может быть достаточно затратно. Метод reverse просто переставляет указатели на соседние элементы.
Преимущество списка в том, что его устройство позволяет оставлять итераторы рабочими. Ни один из других изученных контейнеров такой возможности не предоставлял. Ни вставка, ни удаление, ни какое-либо другое изменение не инвалидируют итераторы списка — если, конечно, вы не удалили тот элемент, на который итератор указывал. В этом случае чуда не произойдёт, и итератор будет инвалидирован.
Ещё менее популярный контейнер, основанный на том же принципе, — forward_list, однонаправленный список. Он может подойти, если нужно итерировать по элементам только в одну сторону, так как в этом случае экономится память. Каждый элемент помнит указатель только на следующий элемент, но не на предыдущий.
Перед тем как приступить к заданию, изучите документацию по следующим методам:
insert
assign
erase
unique
remove
sort
Проще и быстрее: std::array
Подумайте, в каких случаях использовать динамическую память для хранения элементов контейнера действительно нужно. Данные в куче сохраняются даже после окончания работы функции, где была выделена память. Это полезно не всегда — до сих пор мы создавали контейнер в функции, и после её работы этот контейнер был нам больше не нужен. Динамическое выделение памяти удобно, когда не знаем, сколько точно будет элементов в контейнере. Потенциально их может оказаться как очень много, так и очень мало. Поэтому желательно выделять память «по запросу», а не резервировать лишнюю.
Но иногда мы заранее знаем, что элементов будет определенное небольшое количество. Тогда накладные расходы, связанные с выделением памяти в куче, нам не нужны — это достаточно ресурсозатратная операция. На такие случаи есть контейнер std::array — массив, который вообще не выделяет память в куче, а хранит всё на стеке функции.
Сначала проверим, что элементы массива действительно лежат на стеке функции. Используем простой приём:
#include <array>
#include <iostream>
using namespace std;
int main() {
    // создадим на стеке переменные x и y,
    // положим между ними массив, заполненный восьмерками
    int x = 111111;
    array<int, 10> numbers;
    numbers.fill(8);
    int y = 222222;
    // пройдёмся по адресам между y и x
    // и выведем то, что лежит в памяти
    for (int* p = &y; p <= &x; ++p) {
        cout << *p << " "s;
    }
    cout << endl;

    return 0;
}
Результат работы программы:
222222 8 8 8 8 8 8 8 8 8 8 6 0 111111
Вывод на экран в вашей IDE может немного отличаться, но это не меняет результата — все десять восьмерок хранятся последовательно в стеке.
Массивы в языке С устроены так же, но всё-таки std::array удобнее. У него есть методы, итераторы, и его можно, например, скопировать:
#include <array>
#include <iostream>

using namespace std;

int main() {
    array<int, 10> numbers;
    numbers.fill(8);
    // копируем массив
    const auto numbers_copy = numbers;
    // итерируем по массиву
    for (int x : numbers_copy) {
        cout << x << " ";
    }
    cout << endl;

    return 0;
}
Результат работы:
8 8 8 8 8 8 8 8 8 8
Разберемся, в каких ситуациях массив эффективнее. Представим, что у нас есть функция, которая всегда возвращает пять разных элементов. Напишем два варианта этой функции — один вариант с вектором, другой с массивом:
#include "profile.h"

#include <array>
#include <vector>

using namespace std;

vector<int> BuildVector(int i) {
    return {i, i + 1, i + 2, i + 3, i + 4};
}

array<int, 5> BuildArray(int i) {
    return {i, i + 1, i + 2, i + 3, i + 4};
}

const int COUNT = 1000000;

int main() {
    {
        LOG_DURATION("vector");
        for (int i = 0; i < COUNT; ++i) {
            auto numbers = BuildVector(i);
        }
    }
    {
        LOG_DURATION("array");
        for (int i = 0; i < COUNT; ++i) {
            auto numbers = BuildArray(i);
        }
    }

    return 0;
}
В array<int, 5> число пять означает максимальное количество элементов, которое может быть сохранено в объекте такого типа. Элементов всегда будет пять, не больше и не меньше. При этом типы array<int, 5> и array<int, 4> не будут совместимы друг с другом — они абсолютно разные. Запустим программу без оптимизации. Получим:
vector: 147 ms
array: 4 ms
А с оптимизацией результат ещё интереснее:
vector: 55 ms
array: 0 ms
Несмотря на то, что алгоритмическая сложность у этих двух функций одна и та же, массив работает в разы быстрее вектора.
Какая алгоритмическая сложность у измеряемых макросом LOG_DURATION секций?
Проведём ещё один эксперимент. Добавим сортировку для массива, но не будем трогать функцию с вектором. Это увеличит алгоритмическую сложность, и она станет равна C⋅N⋅logN:
#include "profile.h"

#include <algorithm>
#include <array>
#include <vector>

using namespace std;

vector<int> BuildVector(int i) {
    return {i, i + 1, i + 2, i + 3, i + 4};
}

array<int, 5> BuildArray(int i) {
    return {i, i + 1, i + 2, i + 3, i + 4};
}

const int COUNT = 1000000;

int main() {
    {
        LOG_DURATION("vector");
        for (int i = 0; i < COUNT; ++i) {  // C * N
            auto numbers = BuildVector(i);
        }
    }
    {
        LOG_DURATION("array");
        for (int i = 0; i < COUNT; ++i) {  // C * N * logN
            auto numbers = BuildArray(i);
            sort(begin(numbers), end(numbers));
        }
    }

    return 0;
}
Посмотрим на результаты:
vector: 55 ms
array: 6 ms
Важное наблюдение: функция с массивом всё ещё работает быстрее, хотя её алгоритмическая сложность больше. В данном случае расходы на выделение памяти для вектора оказались выше, чем добавление сортировки для массива.
Разработка контейнера SimpleVector. Часть первая
Устройство контейнера SimpleVector
В основе SimpleVector — массив в динамической памяти. Сам контейнер хранит лишь адрес начала массива, а также информацию о его текущем размере и вместимости:
Размер — количество элементов, содержащееся в массиве;
Вместимость — максимальное количество элементов, которые могут поместиться в массив.
template <typename Type>
class SimpleVector {
public:
    ...
private:
    // Вместо сырого указателя лучше использовать умный указатель, такой как ArrayPtr
    Type* items_;

    size_t size_;
    size_t capacity_;
};
Можно провести аналогию с ведром воды — capacity_ определяет максимальный объём воды, которая помещается в ведро, а size_ — текущее количество воды в ведре.

Сконструированный по умолчанию вектор имеет нулевой размер и вместимость, а указатель на массив равен nullptr.

Размер контейнера SimpleVector равен 5, а его вместимость равна 8. На какой элемент массива в динамической памяти ссылается итератор end? Введите ответ в виде числа.
Итератор end ссылается на элемент, следующий за последним элементом контейнера. Последний элемент контейнера имеет индекс 4, следовательно, итератор end ссылается на элемент с индексом 5.
Изменение размера вектора
Как и std::vector, класс SimpleVector может изменять свой размер в сторону увеличения и уменьшения. Для этого служит метод Resize:
template <typename T>
class SimpleVector {
public:
    void Resize(size_t new_size) { ... }
    ...
};
Самый простой случай — уменьшение размера массива. Для этого SimpleVector достаточно изменить значение поля size_.

Таким образом, SimpleVector при уменьшении своего размера не удаляет элементы из массива. «Лишние» элементы продолжают существовать вплоть до удаления массива по адресу items_. Например, до разрушения SimpleVector.
Чуть сложнее выглядит увеличение размера в пределах текущей вместимости контейнера. Помимо увеличения значения поля size_ происходит заполнение новых элементов значением по умолчанию для типа Type.

Чтобы заполнить элементы контейнера или массива одним и тем же значением, можно использовать алгоритм std::fill. Он присваивает элементам диапазона заданное значение.
Так как SimpleVector — шаблонный класс, операция присваивания для некоторых типов Type может выбрасывать исключения. Например, при нехватке памяти. Чтобы обеспечить строгую гарантию безопасности исключений, меняйте размер массива лишь после успешного заполнения новых элементов значением по умолчанию.
Самое интересное происходит, когда новый размер превышает текущую вместимость SimpleVector. В этом случае SimpleVector создаёт новый массив большего размера в динамической памяти, куда копирует элементы исходного массива и инициализирует остальные элементы значением по умолчанию. Для копирования элементов подходит алгоритм std::copy.

Подобно std::vector во многих реализациях стандартной библиотеки, новую вместимость SimpleVector можно выбрать как максимум из new_capacity и capacity_ * 2. Удваивание вместимости минимизирует частоту копирований элементов из одного массива в другой.
После копирования и заполнения элементов нулевым значением можно обновить size_ и capacity_, а старый массив — удалить. Так вы обеспечите строгую гарантию безопасности исключений. Умный указатель ArrayPtr позволит сделать код не только надежнее, но и проще.

Какую асимптотическую сложность имеет операция Resize в классе SimpleVector?
Правильный ответ
Худший случай работы метода Resize(N) происходит при увеличении размера с изменением вместимости контейнера. В этом случае надо скопировать в новый массив k существующих элементов и присвоить N-k элементам значение по умолчанию. Всего k + (N-k) = N операций.
Очистка контейнера SimpleVector
Очистку SimpleVector выполняет метод Clear. Он не изменяет его вместимость и семантически эквивалентен вызову Resize с аргументом, равным нулю. Метод Clear не выбрасывает исключений.
template <typename T>
class SimpleVector {
public:
    void Clear(size_t new_size) noexcept { ... }
    ...
};
Какую асимптотическую сложность имеет операция Clear в классе SimpleVector?
O(1)
Обнуление поля size_ не зависит от количества элементов массива. Поэтому операция Clear выполняется за константное время.
Разработка контейнера SimpleVector. Часть вторая
В предыдущем уроке вы познакомились с устройством SimpleVector и создали в нём операции для управления размером контейнера и доступа к его элементам. В этом уроке вы реализуете:
возможность сравнивать содержимое векторов, вставлять и удалять элементы;
пользовательский конструктор копирования;
пользовательский оператор присваивания.
Сравнение содержимого векторов
Вы уже реализовали операцию сравнения содержимого односвязных списков. Аналогично можно реализовать операции сравнения векторов, применив известные вам стандартные алгоритмы.
При сравнении векторов их вместимость нужно игнорировать. Например, два вектора одного размера, содержащие одни и те же элементы, равны, даже если имеют разную вместимость.
Какой стандартный алгоритм позволит реализовать операторы <, <=, >, >= в классе SimpleVector? Выберите один ответ.
std::lexicographical_compare
Этот алгоритм выполняет лексикографическое сравнение элементов двух диапазонов. Он позволит реализовать оператор <, а остальные операции можно выразить на основе оператора <.
Удаление последнего элемента вектора
Для «удаления» последнего элемента служит метод PopBack:
template <typename Type>
class SimpleVector {
public:
    void PopBack() noexcept { ... };
};
Чтобы удалить последний элемент непустого контейнера SimpleVector нужно уменьшить значение поля size_. Элемент продолжит находиться в векторе, но будет недоступен для использования.

Не допускается вызывать PopBack, когда вектор пуст. Такая же особенность есть и у метода pop_back стандартного вектора.
Добавление элемента в конец вектора
Для вставки элемента в конец вектора служит метод PushBack:
template <typename Type>
class SimpleVector {
public:
    void PushBack(const Type& value) { ... };
};
При добавлении элемента в конец вектора возможны две ситуации, зависящие от того, заполнен вектор полностью или нет.
Когда вектор заполнен частично, запишем вставляемый элемент следом за последним элементом вектора и увеличим его размер.

Чуть сложнее обстоит ситуация, когда вектор заполнен полностью. В этом случае выделите новый массив с удвоенной вместимостью, скопируйте в него элементы исходного массива, а в конец поместите вставляемый элемент. После этого можно обновить размер и вместимость вектора, переключиться на новый массив, а старый массив — удалить.

При выполнении метода PushBack в куче выделяется память и вызывается оператор присваивания у элементов массива. Эти операции могут выбросить исключение. Чтобы сделать метод устойчивым к возникновению исключений, примените умный указатель ArrayPtr, а поля size_ и capacity_ измените после того, как скопируете элементы в новый массив.
Так как при вставке значения в конец заполненного вектора происходит пересоздание массива элементов, операция PushBack делает невалидными существующие ссылки и итераторы. То же самое происходит и в случае std::vector.
Какую асимптотическую сложность имеет операция PushBack в классе SimpleVector? 
O(1)
Операция вставки в конец SimpleVector имеет константную амортизированную сложность за счёт того, что при заполнении массива его вместимость увеличивается вдвое. Для N вызовов PushBack суммарное количество операций над элементами массива будет зависеть от N линейно.
Удаление элемента из произвольного места вектора
Для удаления произвольного элемента вектора служит метод Erase. Он принимает итератор, указывающий на удаляемый элемент вектора, и возвращает итератор, который ссылается на элемент, следующий за удаленным:
template <typename Type>
class SimpleVector {
public:
    Iterator Erase(ConstIterator pos) { ... }
    ...
};
При работе этого метода элементы, следующие за удаляемым, должны быть скопированы на его место один за другим. После того, как все элементы будут скопированы, нужно уменьшить размер массива и вернуть указатель на элемент, следующий за удаленным.

При копировании элементов на место удаленного ранее хранившиеся в массиве значения перезаписываются. Если в середине такого процесса будет выброшено исключение, восстановить прежнее значение перезаписанных элементов массива будет невозможно. В этом случае вектор останется в согласованном, пусть и не первоначальном состоянии. В таком случае говорят, что метод предоставляет базовую гарантию безопасности исключений.
Обеспечить строгую гарантию безопасности исключений можно, создав новую копию массива в методе Erase, что негативно повлияло бы на производительность. По этой же причине метод vector::erase также дает базовый уровень гарантий безопасности исключений.
Вставка элемента в произвольное место вектора
Для вставки элемента в произвольное место вектора служит метод Insert. Он принимает итератор, ссылающийся на место вставки, и само вставляемое значение. Метод возвращает итератор, который ссылается на вставленный элемент:
template <typename Type>
class SimpleVector {
public:
    Iterator Insert(ConstIterator pos, const Type& value) { ... }
    ...
};
Как и в случае с PushBack, при вставке возможны две ситуации:
вектор заполнен частично,
вектор заполнен полностью.
При частичной заполненности вектора элементы, начиная с позиции вставки, сперва копируются на одну позицию «вправо».

После этого в освободившееся место записывается вставляемый элемент и увеличивается размер вектора.

Какой алгоритм подойдет для копирования диапазона элементов массива «вправо» на одну позицию?
std::copy_backward
Когда элемент вставляется в заполненный вектор, в куче выделяется массив с удвоенной вместимостью. В этот массив копируются элементы, которые предшествуют вставляемому, сам вставляемый элемент и элементы, следующие за ним. В конце вектор обновляет свой размер и вместимость, начинает ссылаться на новый массив, а старый массив удаляет:

Как и в случае с Erase, базовая гарантия безопасности исключений естественна для метода Insert. Аналогичное решение принято и для метода insert класса std::vector.
Строгой гарантии безопасности исключений можно добиться так: сделать копию вектора, модифицировать её, а в конце обменять содержимое оригинала и копии.
Обмен содержимого векторов
Для обмена содержимого текущего вектора с другим предназначен метод swap:
template <typename Type>
class SimpleVector {
public:
    void swap(SimpleVector& other) noexcept { ... }
};
Чтобы обменять содержимое векторов, достаточно поменять значения их полей. Эта операция выполняется за константное время, не требует выделения памяти и не бросает исключений.

## Лучшие практики для эффективных линейных контейнеров (C++17)

### std::vector

**Хорошо:**
```cpp
// Резервируем память заранее, если знаем примерный размер
std::vector<int> numbers;
numbers.reserve(1000);
for (int i = 0; i < 1000; ++i) {
    numbers.push_back(i);
}

// Используем emplace_back для конструирования на месте
std::vector<std::string> words;
words.emplace_back("Hello");  // Конструирует строку на месте
words.emplace_back(5, 'a');   // Конструирует строку из 5 символов 'a'

// Используем shrink_to_fit для освобождения лишней памяти
std::vector<int> data(1000);
data.resize(100);
data.shrink_to_fit();  // Освобождаем неиспользуемую память

// Используем swap для быстрой очистки с освобождением памяти
std::vector<int> temp;
data.swap(temp);  // data теперь пуст и не занимает памяти
```

**Плохо:**
```cpp
// Не резервируем память - много реаллокаций
std::vector<int> numbers;
for (int i = 0; i < 1000; ++i) {
    numbers.push_back(i);  // Множественные реаллокации
}

// Используем push_back вместо emplace_back
std::vector<std::string> words;
words.push_back(std::string("Hello"));  // Создаем временный объект

// Сохраняем указатели после модификации
std::vector<int> vec = {1, 2, 3};
int* ptr = &vec[0];
vec.push_back(4);  // ptr может стать невалидным
*ptr = 10;  // Неопределенное поведение!

// Используем clear() для освобождения памяти
std::vector<int> data(1000);
data.clear();  // Память не освобождается!
```

### std::deque

**Хорошо:**
```cpp
// Используем deque для частых вставок в начало/конец
std::deque<int> buffer;
buffer.push_front(1);
buffer.push_back(2);
buffer.push_front(0);  // Эффективно

// Используем deque как кольцевой буфер
class CircularBuffer {
    std::deque<int> data_;
    size_t max_size_;
public:
    void push(int value) {
        if (data_.size() >= max_size_) {
            data_.pop_front();
        }
        data_.push_back(value);
    }
};

// Избегаем случайного доступа к элементам в середине
std::deque<int> dq = {1, 2, 3, 4, 5};
for (auto it = dq.begin(); it != dq.end(); ++it) {
    process(*it);  // Последовательный доступ
}
```

**Плохо:**
```cpp
// Используем vector для частых вставок в начало
std::vector<int> buffer;
buffer.insert(buffer.begin(), 1);  // Медленно - O(n)

// Частый случайный доступ к элементам deque
std::deque<int> dq(1000000);
for (size_t i = 0; i < dq.size(); ++i) {
    dq[i] = i;  // Медленнее чем vector
}

// Предполагаем, что элементы deque лежат в памяти подряд
std::deque<int> dq = {1, 2, 3};
int* ptr = &dq[0];
// ptr + 1 может не указывать на dq[1]!
```

### std::list

**Хорошо:**
```cpp
// Используем list для частых вставок/удалений в середине
std::list<int> numbers = {1, 2, 4, 5};
auto it = std::find(numbers.begin(), numbers.end(), 4);
numbers.insert(it, 3);  // O(1) вставка

// Используем специализированные методы list
std::list<int> list1 = {1, 3, 5};
std::list<int> list2 = {2, 4, 6};
list1.merge(list2);  // Эффективное слияние отсортированных списков

// Удаляем элементы эффективно
std::list<int> numbers = {1, 2, 2, 3, 2, 4};
numbers.remove(2);  // Удаляет все элементы со значением 2

// Сохраняем итераторы после модификации
std::list<int> numbers = {1, 2, 3, 4, 5};
auto it = numbers.begin();
++it;  // Указывает на 2
numbers.erase(numbers.begin());  // it остается валидным
```

**Плохо:**
```cpp
// Используем list для случайного доступа
std::list<int> numbers(1000);
for (int i = 0; i < 1000; ++i) {
    auto it = numbers.begin();
    std::advance(it, i);  // O(n) для каждого доступа
    *it = i;
}

// Используем стандартные алгоритмы вместо методов list
std::list<int> numbers = {3, 1, 4, 1, 5};
std::sort(numbers.begin(), numbers.end());  // Ошибка компиляции!
// Правильно: numbers.sort();

// Предполагаем, что итераторы произвольного доступа
std::list<int> numbers = {1, 2, 3, 4, 5};
auto it = numbers.begin();
// it + 2;  // Ошибка компиляции!
```

### std::array

**Хорошо:**
```cpp
// Используем array для фиксированного размера
std::array<int, 5> coords = {1, 2, 3, 4, 5};

// Передаем array по ссылке
void process(const std::array<int, 5>& arr) {
    for (int value : arr) {
        std::cout << value << " ";
    }
}

// Используем array для стековых данных
std::array<char, 256> buffer;
std::fill(buffer.begin(), buffer.end(), 0);

// Используем constexpr с array (C++17)
constexpr std::array<int, 3> values = {1, 2, 3};
constexpr int sum = values[0] + values[1] + values[2];
```

**Плохо:**
```cpp
// Используем array для динамического размера
int size = get_size();
// std::array<int, size> arr;  // Ошибка компиляции!

// Передаем array по значению для больших массивов
void process(std::array<int, 10000> arr) {  // Медленное копирование
    // ...
}

// Пытаемся изменить размер array
std::array<int, 5> arr = {1, 2, 3, 4, 5};
// arr.resize(10);  // Метода не существует!
```

### std::string_view (C++17)

**Хорошо:**
```cpp
// Используем string_view для read-only операций
void print_word(std::string_view word) {
    std::cout << word << std::endl;
}

// Эффективная работа с подстроками
std::string text = "Hello, World!";
std::string_view hello = text.substr(0, 5);  // Без копирования
std::string_view world = text.substr(7, 5);

// Используем string_view в качестве параметра
bool starts_with(std::string_view text, std::string_view prefix) {
    return text.size() >= prefix.size() && 
           text.substr(0, prefix.size()) == prefix;
}

// Литералы string_view
using namespace std::string_view_literals;
auto sv = "Hello"sv;
```

**Плохо:**
```cpp
// Сохраняем string_view от временного объекта
std::string_view get_substring() {
    std::string temp = "Hello, World!";
    return std::string_view(temp.substr(0, 5));  // Dangling reference!
}

// Модифицируем через string_view
std::string_view sv = "Hello";
// sv[0] = 'h';  // Ошибка компиляции - string_view read-only

// Используем string_view для владения данными
class BadClass {
    std::string_view data_;  // Не владеет данными!
public:
    BadClass(const std::string& str) : data_(str) {}  // Опасно!
};
```

### Общие принципы выбора контейнера

**Хорошо:**
```cpp
// Выбираем контейнер по паттерну использования
std::vector<int> for_random_access;      // Случайный доступ
std::deque<int> for_front_back_ops;      // Операции в начале/конце
std::list<int> for_middle_insertions;    // Вставки в середину
std::array<int, 10> for_fixed_size;      // Фиксированный размер

// Используем профилирование для выбора
void benchmark_containers() {
    // Тестируем разные контейнеры с реальными данными
    auto start = std::chrono::high_resolution_clock::now();
    // ... операции с контейнером
    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
}
```

**Плохо:**
```cpp
// Используем неподходящий контейнер
std::list<int> for_sorting;  // list не поддерживает std::sort
std::vector<int> for_frequent_front_ops;  // Медленные операции в начале

// Игнорируем инвалидацию итераторов
std::vector<int> vec = {1, 2, 3};
auto it = vec.begin();
vec.push_back(4);  // it может стать невалидным
*it = 10;  // Потенциально неопределенное поведение
```


