# Тест: Эффективные линейные контейнеры

## Вопрос 1
Что происходит с capacity вектора при добавлении элемента, если size == capacity?

A) Увеличивается на 1
B) Увеличивается в 2 раза
C) Увеличивается в 1.5 раза
D) Остается неизменной

## Вопрос 2
Какой код демонстрирует правильное использование reserve?

A) 
```cpp
std::vector<int> v;
for (int i = 0; i < 1000; ++i) {
    v.push_back(i);
}
```

B)
```cpp
std::vector<int> v;
v.reserve(1000);
for (int i = 0; i < 1000; ++i) {
    v.push_back(i);
}
```

C)
```cpp
std::vector<int> v(1000);
for (int i = 0; i < 1000; ++i) {
    v.push_back(i);
}
```

D)
```cpp
std::vector<int> v;
v.resize(1000);
for (int i = 0; i < 1000; ++i) {
    v[i] = i;
}
```

## Вопрос 3
Что выведет следующий код?

```cpp
std::vector<int> v = {1, 2, 3};
int* ptr = v.data();
v.push_back(4);
v.push_back(5);
std::cout << *ptr;
```

A) 1
B) Неопределенное поведение
C) 0
D) Ошибка компиляции

## Вопрос 4
Как устроен std::deque внутри?

A) Как непрерывный блок памяти
B) Как массив указателей на чанки памяти
C) Как связный список
D) Как стек

## Вопрос 5
Какая операция эффективна для std::deque, но неэффективна для std::vector?

A) Доступ к элементу по индексу
B) Вставка в конец
C) Вставка в начало
D) Итерация по элементам

## Вопрос 6
Что произойдет с итератором deque после push_back?

```cpp
std::deque<int> d = {1, 2, 3};
auto it = d.begin();
d.push_back(4);
std::cout << *it;
```

A) Выведет 1
B) Итератор инвалидируется
C) Выведет 4
D) Ошибка компиляции

## Вопрос 7
Какой контейнер лучше выбрать для реализации кольцевого буфера?

A) std::vector
B) std::deque
C) std::list
D) std::array

## Вопрос 8
Что происходит с указателями на элементы deque при вставке в середину?

A) Остаются валидными
B) Инвалидируются
C) Только некоторые инвалидируются
D) Зависит от размера deque

## Вопрос 9
Какая временная сложность у операции вставки в середину std::list?

A) O(1)
B) O(n)
C) O(log n)
D) O(n²)

## Вопрос 10
Что не поддерживает std::list из-за своей внутренней структуры?

```cpp
std::list<int> lst = {3, 1, 4, 1, 5};
```

A) `lst.sort()`
B) `std::sort(lst.begin(), lst.end())`
C) `lst.remove(1)`
D) `lst.reverse()`

## Вопрос 11
Какое преимущество у итераторов std::list?

A) Быстрый случайный доступ
B) Не инвалидируются при модификации контейнера
C) Поддерживают арифметические операции
D) Занимают меньше памяти

## Вопрос 12
Что выведет этот код?

```cpp
std::list<int> lst = {1, 2, 3, 4, 5};
auto it = lst.begin();
++it; // указывает на 2
lst.erase(lst.begin());
std::cout << *it;
```

A) 1
B) 2
C) 3
D) Неопределенное поведение

## Вопрос 13
Где хранятся элементы std::array?

A) В куче
B) На стеке
C) В статической памяти
D) Зависит от размера

## Вопрос 14
Какой код корректен для std::array?

A) `std::array<int, 5> arr; arr.resize(10);`
B) `std::array<int, 5> arr = {1, 2, 3, 4, 5, 6};`
C) `std::array<int, 5> arr = {1, 2, 3, 4, 5};`
D) `int n = 5; std::array<int, n> arr;`

## Вопрос 15
Что такое std::string_view?

A) Контейнер для хранения строк
B) Указатель на строку и её длина
C) Неизменяемая строка
D) Альтернатива std::string

## Вопрос 16
Какая проблема с этим кодом?

```cpp
std::string_view get_hello() {
    std::string temp = "Hello, World!";
    return std::string_view(temp.substr(0, 5));
}
```

A) Ошибка компиляции
B) Dangling reference
C) Утечка памяти
D) Код корректен

## Вопрос 17
Как правильно передать std::string_view в функцию?

A) `void func(const std::string_view& sv)`
B) `void func(std::string_view sv)`
C) `void func(std::string_view* sv)`
D) `void func(const std::string_view* sv)`

## Вопрос 18
Что делает shrink_to_fit() для std::vector?

A) Уменьшает size до 0
B) Освобождает всю память
C) Пытается уменьшить capacity до size
D) Удаляет последний элемент

## Вопрос 19
Какой метод std::vector гарантированно освобождает память?

A) `clear()`
B) `shrink_to_fit()`
C) `swap` с пустым вектором
D) `resize(0)`

## Вопрос 20
Что эффективнее для создания объектов в векторе?

A) `vec.push_back(MyClass(args))`
B) `vec.emplace_back(args)`
C) `vec.insert(vec.end(), MyClass(args))`
D) Все одинаково эффективны

## Вопрос 21
Какая сложность у операции push_back для std::vector?

A) O(1) всегда
B) O(n) всегда
C) O(1) амортизированная
D) O(log n)

## Вопрос 22
Что происходит при вставке в середину std::vector?

```cpp
std::vector<int> v = {1, 2, 3, 4, 5};
auto it = v.begin() + 2;
v.insert(it, 10);
```

A) Элементы после позиции вставки сдвигаются
B) Создается новый массив
C) Элементы перед позицией вставки сдвигаются
D) Вставка невозможна

## Вопрос 23
Какой алгоритм используется для копирования элементов "вправо" в SimpleVector::Insert?

A) `std::copy`
B) `std::move`
C) `std::copy_backward`
D) `std::reverse_copy`

## Вопрос 24
Что произойдет при вызове PopBack() на пустом векторе?

A) Выбросится исключение
B) Неопределенное поведение
C) Ничего не произойдет
D) Размер станет -1

## Вопрос 25
Какой контейнер лучше для частых операций сортировки?

A) std::vector
B) std::deque
C) std::list
D) std::array

## Вопрос 26
Что выведет этот код?

```cpp
std::deque<int> d = {1, 2, 3};
d.push_front(0);
d.push_back(4);
std::cout << d.size();
```

A) 3
B) 4
C) 5
D) Ошибка компиляции

## Вопрос 27
Какое утверждение верно для std::forward_list?

A) Поддерживает двунаправленную итерацию
B) Занимает меньше памяти чем std::list
C) Поддерживает push_back
D) Имеет метод size()

## Вопрос 28
Что происходит с capacity при Resize в SimpleVector?

A) Всегда увеличивается до new_size
B) Может удваиваться
C) Остается неизменной
D) Всегда равна size

## Вопрос 29
Какой код демонстрирует правильное использование string_view?

A)
```cpp
std::string_view process(const std::string& str) {
    return str.substr(0, 5);
}
```

B)
```cpp
void process(std::string_view sv) {
    std::cout << sv;
}
```

C)
```cpp
std::string_view sv = std::string("Hello");
```

D)
```cpp
std::string_view sv;
sv = "Hello";
sv[0] = 'h';
```

## Вопрос 30
Какая гарантия безопасности исключений у SimpleVector::Insert?

A) Строгая гарантия
B) Базовая гарантия
C) Гарантия no-throw
D) Никаких гарантий

## Вопрос 31
Что делает метод swap для векторов?

A) Копирует элементы между векторами
B) Обменивает указатели на данные
C) Перемещает элементы
D) Создает новые массивы

## Вопрос 32
Какой контейнер не инвалидирует итераторы при вставке в конец?

A) std::vector
B) std::deque
C) std::list
D) std::array

## Вопрос 33
Что выведет этот код?

```cpp
std::array<int, 3> arr = {1, 2, 3};
std::array<int, 3> arr2 = arr;
arr2[0] = 10;
std::cout << arr[0];
```

A) 1
B) 10
C) 0
D) Ошибка компиляции

## Вопрос 34
Какая операция наиболее эффективна для std::list?

A) Случайный доступ к элементу
B) Удаление элемента из середины
C) Сортировка стандартным алгоритмом
D) Доступ к последнему элементу

## Вопрос 35
Что происходит при преобразовании std::string в std::string_view?

A) Копирование данных
B) Перемещение данных
C) Создание указателя на данные
D) Ошибка компиляции

## Вопрос 36
Какой код наиболее эффективен?

A)
```cpp
std::vector<std::string> words;
words.push_back("Hello");
```

B)
```cpp
std::vector<std::string> words;
words.emplace_back("Hello");
```

C)
```cpp
std::vector<std::string> words;
words.insert(words.end(), "Hello");
```

D) Все одинаково эффективны

## Вопрос 37
Какая особенность у итераторов std::deque?

A) Поддерживают только ++
B) Поддерживают произвольный доступ
C) Не инвалидируются никогда
D) Занимают больше памяти

## Вопрос 38
Что произойдет при вызове Clear() в SimpleVector?

A) Освободится вся память
B) Capacity станет равна 0
C) Size станет равен 0
D) Элементы будут уничтожены

## Вопрос 39
Какой контейнер лучше для реализации стека?

A) std::vector
B) std::deque
C) std::list
D) Любой из перечисленных

## Вопрос 40
Что выведет этот код?

```cpp
std::vector<int> v1 = {1, 2, 3};
std::vector<int> v2 = {1, 2, 3};
v1.reserve(100);
std::cout << (v1 == v2);
```

A) 0 (false)
B) 1 (true)
C) Ошибка компиляции
D) Неопределенное поведение 