Зачем сбрасывать буфер
Вывод сообщений в поток принято завершать переводом на новую строку. Это можно сделать двумя способами:
#include <iostream>
using namespace std
int main() {
    std::cout << "I\n"s;
    std::cout << "love"s << std::endl;
    std::cout << "C++"s << std::endl;
}
В первом случае мы просто добавили \n в конце литерала, а во втором использовали endl.
Сообщения будут на разных строках:
I
love
C++
Чтобы понять, чем различаются между собой эти способы напишем программу вывода сообщений в файл:
#include <fstream>
#include <string>
using namespace std;
int main() {
    ofstream out_file("ballad.txt"s);
    for (int i = 0; i < 10; ++i) {
        out_file << "С любимыми не расставайтесь\n"s;
    }

    throw;
}
Для открытия файла ballad.txt используется поток ofstream из библиотеки <fstream>. Мы подробно рассмотрим тонкости работы с файлами уже в следующей теме. А пока сосредоточьтесь на программе, в особенности на переводе строки.
Обратите внимание на throw в последней строке main. Эта конструкция вызывает аварийное завершение программы, которое не даст выполнить код деинициализации. По идее, throw происходит уже после записи в файл, значит, повлиять на содержимое файла не может.
Соберите и запустите программу локально. Рядом с исполняемым файлом должен появиться файл ballad.txt. Вне зависимости от числа запусков программы в файле не появляется ни строчки. Дело в том, что поток вывода оптимизирован. Записывать на диск 10 раз по одному символу — намного дольше, чем один раз записать 10 символов. Поэтому выведенный в поток текст вместо немедленной записи сохраняется в некоторое промежуточное хранилище и сбрасывается на диск только по мере наполнения этого хранилища либо в случае явной команды flush. Такая оптимизация называется буферизацией, а промежуточное хранилище буфером.
Проверим на примере. Если увеличить количество строк с 10 до 10000, то буфера точно не хватит, и что-нибудь всё-таки попадёт в файл:
0001 С любимыми не расставайтесь
0002 С любимыми не расставайтесь
...
9924 С любимыми не расставайтесь
9925 С любимыми не расставайтесь
Раз результат работы программы выглядит подобным образом, значит, гипотеза оказалась верна: в некоторый момент данные сбросились в файл, но часть всё равно оказалась незаписанной. А теперь заменим \n на endl:
#include <fstream>
#include <string>

using namespace std;

int main() {
    ofstream out_file("ballad.txt"s);
    for (int i = 0; i < 10; ++i) {
        out_file << "С любимыми не расставайтесь"s << endl;
    }

    throw;
}
Вуаля, несмотря на аварийное завершение все 10 строк записались в файл. Но нужно проверить, как endl повлиял на эффективность.
Примените LOG_DURATION и измерьте время записи в файл 50 000 строк: отдельно с \n и с endl. Какой способ эффективнее? При тестировании используйте конфигурацию Release.
С \n эффективнее.
Предположим, ваша задача — перевозить уголь из одного места в другое. Уголь поступает разными порциями — бывает и один уголёк, и целая тонна за раз. При поступлении каждой порции вы можете сразу опломбировать груз, вызвать локомотив и отправить вагон, а можете подождать, пока он наполнится, и только потом отправить. Вызов локомотива требует времени, и если делать это сразу, перевозка угля может затянуться. В итоге вы отправите 100 составов, перевозящих по одному угольку: 100 раз потратите время на пломбировку, прицепку вагона, хотя могли бы подождать, пока вагон наполнится, и сделать это только один раз. Потоки в C++ по умолчанию ждут, пока буфер — то есть вагон — наполнится, чтобы отправить сразу большое количество данных.
Сбрасывать буфер можно не только в начале новой строки, но и просто по желанию. Для этого используют манипулятор std::flush и функцию потока flush:
#include <fstream>
#include <string>

using namespace std;

int main() {
    ofstream out_file("ballad.txt"s);
    for (int i = 0; i < 10; ++i) {
        // такой же эффект, как если бы мы написали endl
        out_file << "С любимыми не расставайтесь\n"s << flush;
    }

    throw;
}
Как видим, endl — это вывод конца строки с одновременным сбросом буфера. Однако за всё нужно платить: сброс буфера снижает эффективность программы. Лучше избегать его, когда интерактивность вывода не требуется, но важна производительность.
Используйте endl при отладке или профилировке, если есть риск, что программа упадёт и не успеет выдать нужную информацию. В остальном endl и \n работают одинаково — ваша задача найти баланс между эффективностью и удобством.
Связь потоков: в поисках оптимального ввода и вывода
В прошлом уроке речь шла о том, что замена endl на \n улучшает эффективность. Разберёмся, всегда ли это происходит. Рассмотрим программу для возведения в квадрат чисел, прочитанных из стандартного ввода:
#include <iostream>
#include <string>
#include "log_duration.h"
using namespace std;
// main с аргументами означает, что программа принимает аргументы командной строки,
// при запуске из консоли их количество будет сохранено в переменную argc,
// а значения — в argv.
// Тип const char** будет обсуждаться позже в курсе, работать с ним можно
// отчасти как с вектором: argv[0] — нулевой аргумент, argv[1] — первый. 
// argv[i] можно конвертировать в string
int main(int argc, const char** argv) {
    // Нулевой аргумент — это всегда имя программы,
    // поэтому нам нужен первый
    int arg = stoi(argv[1]);

    if (arg == 1) {
        LOG_DURATION("endl"s);
        int i;
        while (cin >> i) {
            cout << i * i << endl;
        }
    }

    if (arg == 2) {
        // Чтобы "\n" воспринималось не как перевод строки, а как 
        // слэш и буква 'n', добавим перед ним ещё один слеш:
        // два слеша в строковом (и символьном) литерале воспринимаются
        // как один (\) 
        LOG_DURATION("\\n"s);
        int i;
        while (cin >> i) {
            cout << i * i << "\n"s;
        }
    }
}
Эта программа принимает один числовой аргумент: единицу или двойку. Она читает числа из стандартного ввода и выдаёт их квадраты в стандартный вывод, замеряя время. Причём метод завершения строки — \n или endl — можно менять, используя аргумент командной строки. Скомпилируем программу и назовём исполняемый файл sqnums. Запустим её так:
$ sqnums 1
Она будет радостно выводить квадраты всех введенных чисел до тех пор, пока вы не введете символ конца файла. Затем выведет общее время работы и при этом будет использовать endl. Запустим программу иначе:
$ sqnums 2
Тут вместо endl будет простой \n.
Для запуска программы возьмём файл numbers.txt, который содержит 50000 чисел от 0 до 99.
🔗 numbers.txt
Запускать будем, перенаправляя стандартный ввод и вывод:
$ sqnums 1 >numbers2.txt <numbers.txt
Перенаправление символами > и < позволяет проассоциировать потоки cin и cout с файлами. Так программа будет через поток cin получать данные из файла numbers.txt. Благодаря > данные из cout пойдут в файл numbers2.txt, а не в окно консоли. Если хотим использовать \n, меняем параметр 1 на 2:
$ sqnums 2 >numbers2.txt <numbers.txt
Смотрим на результаты:
$ sqnums 1 >numbers2.txt <numbers.txt
endl: 410 ms
$ sqnums 2 >numbers2.txt <numbers.txt
\n: 408 ms
📖  В команде sqnums 2 >numbers2.txt <numbers.txt пробел между 2 и > важен: без него получится конструкция 2>, которая выполняет перенаправление потока cerr.
Не столь впечатляюще. Раньше мы наблюдали чуть не десятикратное различие, а теперь оно едва заметно. Чтобы понять причину этого, обратимся к другой программе:
#include <iostream>
using namespace std;
int main() {
    cout << "Enter x and y: "s;
    cin >> x >> y;
    cout << x + y << endl;
}
Почему мы всегда видим надпись Enter x and y: перед вводом?
Очевидно, потому что выводим её в cout перед вводом.
Как показал предыдущий урок, если мы что-то вывели в поток, это не значит, что оно там окажется сразу же.
Совсем не очевидно, но чтение из cin заставляет буфер cout и cerr опустошаться, как если бы мы добавили cout.flush() перед ним. В этом причина медленной работы программы с \n. К счастью, есть способ исправить ситуацию, отвязав cin от cout так: cin.tie(nullptr);.
Дополним программу еще одной веткой и протестируем скорость:
#include <iostream>
#include <string>

#include "log_duration.h"

using namespace std;

int main(int argc, const char** argv) {
    // не забываем, что один аргумент — это название программы,
    // поэтому argc должно быть как минимум 2
    if (argc < 2) {
        cerr << "Пожалуйста, задайте как минимум 1 аргумент"s << endl;
        return 1;
    }

    int arg = std::stoi(argv[1]);

    if (arg == 1) {
        LOG_DURATION("endl"s);
        int i;
        while (cin >> i) {
            cout << i * i << endl;
        }
    }

    if (arg == 2) {
        LOG_DURATION("\\n"s);
        int i;
        while (cin >> i) {
            cout << i * i << "\n"s;
        }
    }

    if (arg == 3) {
        LOG_DURATION("\\n with tie"s);
        cin.tie(nullptr);
        int i;
        while (cin >> i) {
            cout << i * i << "\n"s;
        }
    }
}
Запускаем:
$ test-stream.exe 3 <numbers.txt >numbers2.txt
\n with tie: 89 ms
Совсем другое дело! Однако будьте осторожны, потому что отвязывание cin от cout повлияет на всё последующее выполнение. Если разрабатываете основную функцию программы, это не так важно. Но если подобное происходит в функции библиотеки, которая будет применяться в разных программах, такой побочный эффект крайне нежелателен. Избежать его просто — в конце работы привяжите обратно:
...
if (arg == 3) {
    LOG_DURATION("\\n with tie"s);
    auto tied_before = cin.tie(nullptr);

    int i;
    while (cin >> i) {
        cout << i * i << "\n"s;
    }

    cin.tie(tied_before);
}
...
Чтобы избежать возможных проблем, используйте для этих целей класс с конструктором и деструктором для выполнения парных действий. В прошлой теме вы так измеряли время.
В этом уроке мы убедились: замена endl на \n серьёзно ускоряет использование потоков, если это критичное место вашей программы.
Еще сильнее ускорить ввод и вывод в cin и cout может магическая команда ios_base::sync_with_stdio(false), с которой хорошо знакомы участники соревнований по программированию. Использовать её следует осторожно. Эта команда способна помешать работе при подключении сторонних библиотек, выводящих информацию в стандартный вывод.
Команда sync_with_stdio отключает синхронизацию между стандартными потоками C и C++, а также между разными потоками выполнения, сохраняя ресурсы.
Не путайте потоки ввода и вывода stream и потоки выполнения thread:
Потоки ввода и вывода stream передают данные между произвольным источником source и потребителем sink.
Потоки выполнения thread позволяют одновременно выполнять несколько операций в программе. Они также используются для ускорения за счет выполнения на разных ядрах процессора. Термины «многопоточный», «потокобезопасный» всегда относятся к потокам выполнения.
Такие разные потоки
Компьютеры, смартфоны и многие другие устройства, способные исполнять программы, трудно представить без важного элемента — энергонезависимого носителя, такого как жесткий или твердотельный диск. У постоянной памяти, размещаемой на этом носителе, есть свои особенности. Главная из них — необходимость в файловой системе, которая структурирует данные на диске. В этой теме рассмотрим работу с файловой системой. Начнем с чтения и записи файлов. Но прежде вспомним, как устроены потоки ввода-вывода, через которые осуществляются основные операции с файлами.
У потока две стороны: одна посылает данные, другая получает. Одна из этих сторон — активная, это функция или метод вашей программы. Задача другой — выдать или принять данные по запросу. Потоки ввода-вывода — замечательный пример разделения ответственности. Эти стороны могут не знать друг о друге ничего: одна посылает данные в поток, не представляя, куда они попадут, другая — обрабатывает данные, не имея понятия о том, откуда они пришли.
Помимо потоков стандартного ввода и вывода есть строковые потоки, которые работают с памятью: istringstream и ostringstream. Потоки cin и cout существуют в одном экземпляре. А строковых потоков можно создать несколько при необходимости.

Поток ввода можно представить ссылкой на istream&. Активная сторона читает данные из него. К потокам ввода относятся cin и istringstream из библиотеки <sstream>.
Поток вывода представляется ссылкой на ostream&. Активная сторона может записывать данные в него. Этот поток содержит кэширование, ускоряющее его работу. К потокам вывода относятся ostringstream из библиотеки <sstream> и знакомый вам cout из <iostream>.
Помимо этих двух потоков существует также тип iostream. Ссылкой этого типа можно представить поток, допускающий как чтение, так и запись. Примером служит stringstream.
Для работы с файлами в стандартной библиотеке есть специальные потоки, которые станут доступны при подключении файла <fstream>:
поток ввода ifstream для чтения из файла,
поток вывода ofstream для записи в файл,
поток fstream для выполнения сразу обеих операций.
При создании потока в конструктор нужно передать имя файла:
#include <fstream>
#include <iostream>
#include <string>

using namespace std;

int main() {
    {
        ifstream in_file("test.txt"s);
        int x; 
        if (in_file >> x) {
            cout << "Из файла прочитано число "s << x << endl;
        }
    }

    {
        ofstream out_file("test.txt"s);
        out_file << 100 << 500 << endl;
    }
}
При первом запуске этой программы в консоль не будет выведено ничего — файла с именем test.txt нет и прочитать из него не получится. Вторая половина программы автоматически создаст этот файл и запишет в него два числа — ofstream автоматически создает файл, если его нет. Имейте в виду, что ofstream не создаёт папки — открытие будет успешным только в том случае, если директория файла уже существует, и на создание файла в ней у программы есть права.
Если всё прошло успешно, после второго запуска появится текст:
Из файла прочитано число 100500
Два записанных числа склеились в одно, поскольку мы не вывели между ними никакого разделителя — пробела или перевода строки. Так произошло бы и при выводе в cout.
После третьего запуска результат не изменится — ofstream очищает файл, если он существует, и начинает с чистого листа. Следует быть осторожными и не открывать через ofstream файл, содержащий нужные данные.
Поскольку указано только имя файла без указания пути, файл будет создан в текущей директории — папке, задаваемой окружением операционной системы. Текущая директория зависит от того, как пользователь запустил программу. Если она вызвана из проводника, текущая директория будет папкой программы. Если из консоли, то активной директорией в консоли. В C++ есть функции для изменения и получения текущей директории. Об этом — в конце темы.
Директория используется для интерпретации относительных путей. Например, если программа обращается к файлу "dir/a.txt" без указания полного пути до него, будет подразумеваться, что этот файл находится в поддиректории dir текущей директории. При запуске из IDE текущая директория задаётся в настройках проекта. Часто текущая папка совпадает с папкой исполняемого файла вашей программы, но так происходит не всегда.
Объекты классов fstream, ifstream, ofstream можно создавать и с пустым конструктором. В этом случае для открытия файла примените метод open, который принимает такие же параметры, как и конструктор. Более того, можно открыть другой файл тем же потоком, вызвав open повторно. Перед этим нужно закрыть файл методом close, который не принимает параметров. Пока файл открыт каким-либо потоком, он зарезервирован за вашей программой. Операционная система может препятствовать другим программам совершать действия с этим файлом, например удалять его. Но это не значит, что нужно вызывать close каждый раз после открытия файла, чтобы снять резерв. В C++ это происходит в деструкторе потока автоматически. Поэтому можно не бояться, что забудете закрыть файл и допустите утечку ресурсов.
Подведем итог этого урока таблицей, содержащей все известные на данный момент потоки:


Стандартный ввод-вывод
Строковый поток
Файловый поток
Заголовочный файл
<iostream>
<sstream>
<fstream>
Поток ввода
cin
istringstream
ifstream
Поток вывода
cout, cerr
ostringstream
ofstream
Двунаправленный поток
—
stringstream
fstream

Ошибки и как с ними бороться
Потоки существуют в C++ с самого момента создания языка и поэтому имеют свою специфику. В этом уроке разберём, как различать ошибки потока и как работать с потоком после ошибки.
В первом примере из прошлого урока мы проверяем корректность чтения в if с условием in_file >> x. Почему это работает?
Поток istream будет конвертироваться в true, только если последняя операция чтения прошла успешно. Перечислим причины, по которым чтение могло не получиться.
Неудача при открытии файла или другая ошибка, произошедшая до чтения. Например, файла нет или недостаточно прав.
Ошибка ввода-вывода. Например, на файл пришёлся битый сектор диска, либо пользователь вынул флешку с файлом во время чтения.
В потоке находится не число.
Достигнут конец файла. Поскольку в примере это первое чтение, значит, файл пуст или состоял из пробелов.
Первая и вторая ситуации — критические. Скорее всего, с потоком уже ничего не получится сделать.
Третья ситуация позволяет выполнять другое чтение. Последняя ситуация — штатная.
Чтобы различить причины неудавшегося чтения в потоке, предусмотрены три флага:
badbit — обозначает критическую ошибку,
failbit — обозначает критическую ошибку,
eofbit — обозначает конец файла. При этом достижение конца файла не означает, что последняя операция была неуспешной. Но он означает, что следующая операция чтения точно будет неуспешной.
Читать и задавать флаги можно сеттером clear и геттерами. Почитайте о них в документации по базовому классу для потоков ввода и вывода std::basic_ios.
Рассмотрим такую программу:
int main(int argc, const char** argv) {
    // открываем файл, указанный в первом аргументе командной строки
    ifstream input(argv[1]);

    while (input) {
        int times;
        string action;

        if (input >> times >> action) {
            for (int i = 0; i < times; ++i) {
                cout << action << "! "s;
            }
            cout << endl;
        } else {
            string action2;
            if (input >> action2) {
                cout << action2 << "!"s << endl;
            }
        }
    }
}
По задумке такая программа должна поддерживать команды двух видов:
Число, действие.
Действие.
Подадим на вход следующий файл:
3 clap
3 jump
turn
3 stomp
Всё просто: трижды хлопнуть, трижды подпрыгнуть, повернуться и три раза топнуть. Запустим программу и увидим такой результат:
clap! clap! clap!
jump! jump! jump!
На прыжках всё закончилось. Дело в том, что после первой ошибки чтение останавливается. Сколько бы вы ни пытались читать из потока, операции ввода-вывода не будут выполняться, если поток имеет установленный флаг failbit или badbit.
Если бы чтения продолжались после ошибки, условие оператора if (input >> times >> action) было бы истинным, поскольку выполнилось бы второе чтение. Значение переменной times оказалось бы не заданным, что должно было привести к неопределенному поведению.

Если ошибка не фатальная, поток может ещё пригодиться. Чтобы продолжить попытки чтения и заставить операцию >> снова работать, нужно сбросить флаги вручную методом clear.
Можно исправить программу, добавив сброс флагов перед попыткой чтения второй команды:
int main(int argc, const char** argv) {
    // открываем файл, указанный в первом аргументе командной строки
    ifstream input(argv[1]);

    while (input) {
        int times;
        string action;

        if (input >> times >> action) {
            for (int i = 0; i < times; ++i) {
                cout << action << "! "s;
            }
            cout << endl;
        } else {
            string action2;

            // сбрасываем флаги ошибок перед новым чтением:
            input.clear();
            if (input >> action2) {
                cout << action2 << "!"s << endl;
            }
        }
    }
}
Работа программы исправилась, вывод корректный:
clap! clap! clap!
jump! jump! jump!
turn!
stomp! stomp! stomp!
По умолчанию потоки не кидают исключений. Однако можно попросить поток делать это при ошибке во время установки флага failbit или badbit. Переключить поток в режим выбрасывания исключений при ошибке ввода-вывода позволит метод exceptions. В этом курсе исключения потоков не понадобятся. Узнать больше о методе exception вы можете из документации.
Поток из условия цикла конвертируется к bool. При этом значение false будет получаться, если у потока установлен флаг ошибки: failbit или badbit. Используйте этот факт, чтобы ответить на вопрос:
Одной лишней итерации можно избежать, если заменить условие на input.good(). Метод good потока будет возвращать false также при наличии флага eofbit, а значит, позволит не гонять цикл, когда все операции чтения точно будут неуспешны.
На самом деле, даже использование good не даст гарантии корректных чтений. В потоке может остаться пробел или перевод строки, и, с точки зрения потока, это ещё не конец. Однако good лучше подходит по семантике в данном случае:
конвертацию к bool уместно применять после чтения, чтобы проверить, прошло ли оно успешно;
метод good уместно применять перед чтением, чтобы проверить, есть ли у последующего чтения шансы.
Тонкости открытия файлов
Вы узнали о двух режимах открытия файла — через ifstream для чтения и через ofstream для записи. Открывать для чтения можно только существующий файл, открывать для записи — существующий и несуществующий. При открытии через ofstream несуществующий файл будет создан, а существующий — очищен.
Есть также универсальный вариант — fstream, который позволяет осуществлять как чтение, так и запись. fstream позволяет всё, что могут делать ifstream и ofstream.
Особенности его поведения можно устанавливать специальными флагами. Их задают при открытии файла конструктором или методом open:
ios::in — разрешить чтение,
ios::out — разрешить запись,
ios::app — писать только в конец файла, дополняя его,
ios::ate — первая запись будет в конец файла,
ios::trunc — удалить содержимое файла при открытии,
ios::binary — бинарный режим. Будет рассмотрен в следующих уроках.
Комбинировать флаги вы можете операцией |. Например, режим по умолчанию для fstream — это ios::in | ios::out. Все возможные комбинации флагов и особенности их работы есть в документации по basic_filebuf.
Эти флаги можно указывать и для однонаправленных потоков, чтобы изменить их поведение. Например, если для ofstream укажете ios::app, поток будет не удалять содержимое файла, а дописывать все данные в конец.
Рассмотрим пример:
#include <fstream>
#include <iostream>
#include <string>

using namespace std;

int main(int argc, const char** argv) {
    // 1
    {
        fstream fout("telefon.txt", ios::out);
        fout << "У меня зазвонил телефон."s << endl;
        fout << "- Кто говорит?"s << endl;
    }

    // 2
    {
        fstream fout("telefon.txt", ios::in | ios::out);
        fout << "- Слон."s << endl;
    }

    // 3
    {
        fstream fin("telefon.txt", ios::in);
        string str;
        while (getline(fin, str)) {
            cout << str << endl;
        }
    }
}
В этом примере файл telefon.txt открывался трижды. Вначале файл был создан или очищен, в него записался текст. Во второй секции мы дописали текст «- Слон.», а в третьей вывели содержимое файла на экран.
Обратите внимание, что файл во второй секции был открыт сразу на чтение и запись. Это позволяет в числе прочего не удалять содержимое файла при открытии: прочитать сохранённые данные и при необходимости внести в них изменения.
Результат получился такой:
- Слон.
зазвонил телефон.
- Кто говорит?
Слово «Слон» записалось поверх слов «У меня», и получилась бессмыслица. Произошло это потому, что файл состоит из байтов, и при записи новый текст не вставляется, как в методе insert у вектора, а записывается поверх уже существующего текста. Ошибка в том, что мы пишем в начало файла, а правильно было бы писать в конец. Дело во флагах  ios::in | ios::out. При таком режиме открытия указатель записи ставится на начало файла, и запись производится поверх уже существующего текста. Если бы файл открывался с флагами ios::out | ios::app, данные попали бы в конец, как и нужно. Используйте эту комбинацию, если просто хотите дописать в файл, не производя чтений.
📖  Чтение не понадобилось, ios::in тут исключительно для сохранения данных. В реальных программах не стоит включать лишние флаги доступа, поскольку они могут помешать открытию файла. Например, если файл имеет права -wx, его можно открыть только на запись, но не на чтение.
Чтобы исправить ситуацию, укажем позицию записи методом seekp. Последняя буква p, от слова put, говорит, что этот метод меняет именно позицию записи. Есть также метод, предназначенный, чтобы узнать эту позицию — tellp.
Заменим вторую секцию на такую:
   // 2
    {
        fstream fout("telefon.txt", ios::in | ios::out);
        fout.seekp(72);
        fout << "- Слон."s << endl;
        cout << "Writing at pos: "s << fout.tellp() << endl;
    }
Содержимое файла исправилось. И вывод программы тоже:
Writing at pos: 83
У меня зазвонил телефон.
- Кто говорит?
- Слон.
Видно, что после записи новых символов позиция записи увеличилась. Здесь мы подставили явно число 72, заранее вычислив количество символов в файле на данный момент. Так делать неудобно, поэтому у seekp есть второй параметр, обозначающий точку отсчёта. Он может принимать следующие значения:
ios::beg — отсчитывать от начала файла,
ios::end — отсчитывать от конца файла,
ios::cur — отсчитывать от текущего места.
При использовании ios::end и ios::cur допустимо отрицательное значение позиции. Например, если мы хотим сместиться на десять символов назад, можно написать stream.seekp(-10, ios::cur). Перейти при записи в самый конец файла можно командой stream.seekp(0, ios::end). Слегка модифицируем авторский текст, заменив второй блок на такой:
   // 2
    {
        fstream fout("telefon.txt", ios::in | ios::out);
        fout.seekp(-17, ios::end);
        fout << "на линии?"s << endl << "- Слон."s << endl;
        cout << "Writing at pos: "s << fout.tellp() << endl;
    }
Запустим и проверим вывод:
Writing at pos: 84
У меня зазвонил телефон.
- Кто на линии?
- Слон.
📖  Указано число 17, превышающее количество букв и символов, которые мы прошли назад от конца файла. Это связано с тем, что литералы в исходном коде записаны в кодировке UTF-8, и в ней же они будут сохраняться в файл. В этой кодировке каждая русская буква занимает два байта. Знак вопроса занимает один байт, а перевод строки — два байта. Всего получается 17 байт. Вид перевода строки зависит от операционной системы и режима открытия. Под MacOS и Linux он будет занимать один байт, под Windows — два.
У методов seekp и tellp есть аналоги, получающие и устанавливающие позицию чтения. Эти методы работают аналогичным образом, но влияют на операции чтения. Они называются seekg и tellg — последняя буква от слова get означает, что речь идёт о чтении.
Бинарные файлы: читаем и пишем байты
В файлах хранятся байты. Поэтому не всегда удобно использовать операции >> и <<, которые читают и пишут данные определенного формата. Иногда задача в том, чтобы прочитать или записать определенное количество байтов.
В потоках чтения есть метод get. Если вызвать его без параметров, он прочтет один байт и возвращает целое число. Обычно оно находится в пределах от 0 до 255, но если достигнут конец файла или произошла ошибка, это число равно специальному отрицательному значению, которое можно получить вызовом istream::char_traits::eof(). Название этого метода — аббревиатура от end of file.
Чтобы прочитать N байтов, можно использовать такой цикл:
size_t ReadExact(istream& input, char* dst, size_t count) {
    for (size_t i = 0; i < count; ++i) {
        int c = input.get();
        if (c == istream::traits_type::eof() || !input) {
            return i;
        }
        dst[i] = static_cast<char>(c);
    }

    return count;
}
Указатель здесь позволяет не ограничиваться определённой структурой данных. Можно вызывать этот метод для чтения в string, vector<char>, array<char, N> и другие типы. Однако у сырого указателя есть свои минусы: даже при включении отладочных определений выход за пределы памяти не будет обнаружен. Подобная концепция идёт ещё из языка C, она будет подробно разобрана в спринте 12.
Делать свою функцию ReadExact необязательно — для чтения определенного количества байтов у потока istream есть специальный метод read. Он устроен аналогично, за исключением типа возврата — результатом будет не количество прочитанных символов, как в функции ReadExact, а сам поток, как во многих других методах потоков. Чтобы узнать количество прочитанных символов, после read вызовите метод gcount. Сравним по скорости собственную реализацию, использующую get, со встроенным методом read:
#include "log_duration.h"

#include <fstream>
#include <iostream>
#include <random>
#include <string>

using namespace std;

size_t ReadExact(istream& input, char* dst, size_t count) {
    for (size_t i = 0; i < count; ++i) {
        int c = input.get();
        if (c == istream::traits_type::eof() || !input) {
            return i;
        }
        dst[i] = static_cast<char>(c);
    }

    return count;
}

string GenerateRandomString(size_t size) {
    string random_str(size, 0);
    static mt19937 engine;

    for (char& c : random_str) {
        c = static_cast<char>(uniform_int_distribution<int>('A', 'Z')(engine));
    }

    return random_str;
}

int main() {
    // размер файла 10 мегабайт
    static const int FILE_SIZE = 10 * 1024 * 1024;
    static const int READ_COUNT = 10;

    // создаём файл нужного размера
    {
        ofstream test_out("test.txt");
        test_out << GenerateRandomString(FILE_SIZE);
    }

    vector<char> buffer(FILE_SIZE);

    // прочитаем его заданное количество раз двумя способами
    {
        LOG_DURATION("multiple get");
        ifstream test_in("test.txt");
        for (int i = 0; i < READ_COUNT; ++i) {
            test_in.seekg(0);
            ReadExact(test_in, buffer.data(), FILE_SIZE);
        }
    }

    {
        LOG_DURATION("stream read");
        ifstream test_in("test.txt");
        for (int i = 0; i < READ_COUNT; ++i) {
            test_in.seekg(0);
            test_in.read(buffer.data(), FILE_SIZE);
        }
    }
}
Каждым методом прочитано в общей сложности 100 мегабайт. Посмотрим на результат:
multiple get: 8933 ms
stream read: 351 ms
В этом примере метод read читает со скоростью примерно 280 Мбайт/с, а многократные get показывают всего 11 Мбайт/с.
Справедливости ради стоит отметить, что измерение скорости операций с файлом не всегда надежно. Из-за особенностей диска время может сильно варьироваться. Чтение даже одного байта в некоторых ситуациях может занимать десятки секунд. Напротив, если файл был недавно прочитан, его содержимое, скорее всего, находится в кэше диска, и чтение будет очень быстрым. Но в нашем случае результат воспроизводимый.
Можно сделать такой вывод: get хорош, если требуется ровно один символ, в зависимости от которого нужно решить, что делать дальше. Но для чтения большого файла он не годится. Можно также использовать знакомый getline, чтобы прочитать всё до определенного символа. Запомните: каждая потоковая операция выполняет несколько вспомогательных вызовов, обрабатывает флаги ошибок и требует немалых накладных расходов. Следует свести количество потоковых операций к минимуму.
Также get неприемлем, если нужно прочитать файл целиком и что-нибудь сделать с каждым символом. Вместо этого используйте буфер — не слишком маленький, но и не занимающий много памяти. Хороший размер буфера — один килобайт. В этом случае накладные расходы сокращаются более чем в тысячу раз и становятся незначительными по сравнению с самим чтением данных.
Аналоги get и read для записи — методы put и write. На них распространяются те же правила, что и на методы чтения: не следует использовать put для записи многих символов подряд. Напишем собственную версию утилиты cp, которая копирует файлы. При этом применим буфер:
#include <array>
#include <fstream>
#include <iostream>
#include <string>

using namespace std;

int main(int argc, const char** argv) {
    // при неверных аргументах выводим ошибку и выходим с кодом
    if (argc != 3) {
        cerr << "Usage: "s << argv[0] << " <in file> <out file>"s << endl;
        return 1;
    }

    ifstream in_file(argv[1]);
    if (!in_file) {
        cerr << "Can't open input file"s << endl;
        return 2;
    }

    ofstream out_file(argv[2]);
    if (!out_file) {
        cerr << "Can't open output file"s << endl;
        return 2;
    }

    // размер буфера один килобайт
    static const int BUFF_SIZE = 1024;
    std::array<char, BUFF_SIZE> buffer;

    do {
        in_file.read(buffer.data(), BUFF_SIZE);
        out_file.write(buffer.data(), in_file.gcount());
    } while (in_file);
}

Вам могло показаться странным, что сначала прочитанное пишется в файл, и только потом проверяется корректность операции чтения. Но таковы особенности работы с read — операция считается успешной, только если прочитано ровно столько символов, сколько мы запросили. Последняя часть файла, скорее всего, окажется меньше буфера, и поток будет считать, что read не удался. Надёжный способ узнать, сколько символов прочитано, — метод gcount. Даже если случилась какая-либо ошибка во время чтения, его значение будет 0, и write ничего не запишет.
Протестируем программу, назвав ее my_cp. Копируем текстовый файл canterburry.txt и сравним его с исходным утилитой diff:
my_cp canterburry.txt canterburry-copy.txt
diff canterburry.txt canterburry-copy.txt
Вывод diff пуст, значит, файл скопировался правильно. Пусть теперь программа копирует саму себя:
my_cp "my_cp.exe" "my_cp_copy.exe"
my_cp_copy "canterburry.txt" "canterburry-copy.txt"
При попытке запуска этих команд под Windows выскакивает такое сообщение:

Файл скопировался неправильно. Выходит, программа работает некорректно и не может скопировать бинарный файл.
Это опасная ошибка, которая исправляется добавлением флага binary при открытии обоих файлов — входного и выходного. Без этого флага поток может вносить некоторые изменения в данные при чтении и записи. Например, автоматически исправлять концы строк или пропускать некоторые непечатные символы. Используйте binary везде, кроме случаев, когда вы уверены, что придётся работать именно с текстовым файлом.
Нужно модифицировать две строки с объявлением потоковых переменных, добавив в вызов конструктора второй параметр:
   ifstream in_file(argv[1], ios::in | ios::binary);
    if (!in_file) {
        cerr << "Can't open input file"s << endl;
        return 2;
    }

    ofstream out_file(argv[2], ios::out | ios::binary);
    if (!out_file) {
        cerr << "Can't open output file"s << endl;
        return 2;
    }
Тернистые пути: работаем с файловой системой
Пройдя почти все уроки этой темы, вы научились выполнять только базовые операции с файлами: чтение, запись и создание нового файла. Вы узнали о способах проверить существование файла и определить его размер, но такие способы правильно работают только при наличии прав на чтение, а это избыточно. Для других операций с файлами в C++ существует стандартная библиотека filesystem.
📖  При компоновке программ с использованием filesystem могут потребоваться дополнительные опции компиляции. Для gcc до версии 9.1 нужен ключ -lstdc++fs.
Пути
В разных ОС файловые системы имеют свои особенности. В одних разделитель пути обозначается прямым слешем, в других — обратным. В одних все абсолютные пути начинаются с диска либо с указания на сетевую папку, в других достаточно слеша в начале. Предназначение filesystem — дать наиболее универсальный интерфейс файловой системы, который бы работал корректно на разных платформах.
Базовое понятие filesystem — путь. Он представляется классом std::filesystem::path. Это может быть как абсолютный, так и относительный путь. Он способен задавать существующий или несуществующий файл. Путь состоит из секций — промежуточных папок. При комбинировании путей можно не задумываться о том, какой слеш нужен в данной операционной системе, и использовать операцию /:
#include <filesystem>
#include <iostream>

using namespace std;

int main() {
    using filesystem::path;

    path p = path("a") / path("folder") / path("and") / path("..") / path("a") / path("file.txt");

    // выводим естественное представление пути в std::string
    cout << p.string() << endl;
}
Под Windows вывод такой:
a\folder\and\..\a\file.txt
Под Linux и MacOs слеши прямые:
a/folder/and/../a/file.txt
📖  Другое различие путей в разных операционных системах — кодировка. В Windows используются 16-битные кодировки, в распространенных дистрибутивах Linux — utf-8. Поэтому в Windows путь нельзя сохранить в string без потери поддержки путей, содержащих буквы разных языков. Для представления пути под Windows подходит тип wstring, полностью аналогичный string за тем исключением, что вместо char в нём wchar_t. Класс filesystem::path способен корректно обработать любые пути. Он содержит псевдоним path::string_type строкового типа, подходящего для путей в данной операционной системе. Если ваша программа принимает пути к файлам через аргументы командной строки, то под Windows не получится обойтись функцией main с параметрами int, const char**. Вместо этого выберите другую точку входа: int wmain(int argc, const wchar_t** argv). Чтобы устранить неоднозначность, все пути можно сразу конвертировать к filesystem::path. У него есть конструкторы, принимающие как string, так и wstring.
Литерал для путей
В примере мы записывали путь довольно длинно и сложно, многократно повторяя имя типа: path("a") / path("folder") / path("and") / path("..") / path("a") / path("file.txt"). Как упростить выражение и получить абсолютно такой же объект path? Выберите один или несколько вариантов.
Не использовать тип path.
Записать всё в один конструктор: path("a/folder/and/../a/file.txt").
Убрать переход к родительской папке и саму папку: path("a") / path("folder") / path("a") / path("file.txt").
Тоже правильный ответ
Использовать специальный строковый суффикс для пути по аналогии с ""s.
Строковые литералы с суффиксом s позволяют создавать объект string эффективно и коротко. Аналогичного суффикса для создания путей в стандартной библиотеке нет. Но невелика беда, ведь ничто не мешает создать его самим!
Суффикс, который определяет программа, должен начинаться со знака подчёркивания. Так можно избежать конфликтов с литералами стандартной библиотеки, которые уже существуют или будут добавлены в будущем. Определим для пути суффикс _p:
path operator""_p(const char* data, std::size_t sz) {
    return path(data, data + sz);
}
Ещё одно преимущество такой записи — оператор принимает размер литерала, вычисляемый на этапе компиляции. Это даёт небольшой выигрыш в производительности: не нужно проходить второй раз, чтобы определить её длину. Именно поэтому мы стремимся везде использовать s и sv. Сам path создан конструктором, принимающим два указателя — на начальный символ и на конечный.
Такой суффикс значительно сокращает запись пути:
"a"_p / "folder"_p / "and"_p / ".."_p / "a"_p / "file.txt"_p
Операции с путями
Пути можно использовать вместо string в конструкторах файловых потоков fstream, ofstream, ifstream, чтобы открыть файл. Опишем другие возможные применения путей.
Получение абсолютного пути из относительного
Если путь относительный, его можно сделать абсолютным, приписав к началу текущую папку. Вам понадобится функция absolute. Если путь уже абсолютный, функция ничего не изменит:
path p = "a"_p / "folder"_p / "and"_p / ".."_p / "a"_p / "file.txt"_p;

cout << "Исходный вид: "s << p.string() << endl;
p = filesystem::absolute(p);
cout << "После absolute(): "s << p.string() << endl;
p = filesystem::absolute(p);
cout << "После второго absolute(): "s << p.string() << endl;
Возможный вывод:
Исходный вид: a/folder/and/../a/file.txt
После absolute(): /tmp/1610305631.7592149/a/folder/and/../a/file.txt
После второго absolute(): /tmp/1610305631.7592149/a/folder/and/../a/file.txt
Функция выбрасывает исключение filesystem_error в случае ошибки. Если указать второй параметр типа std::error_code&, вместо исключения в него будет записываться ошибка.
Создание папки
В filesystem есть две функции для создания папок:
create_directory
create_directories
Обе принимают путь и необязательный параметр типа std::error_code&, наличие которого запрещает исключения. Отличие первой функции от второй в том, что она может создать только одну папку, а вторая — сразу серию вложенных. Если папка уже существует, функция не сообщает об ошибке, в отличие от реализации аналогичной функции в некоторых других языках.
Приведем пример:
#include <filesystem>
#include <fstream>
#include <iostream>

using namespace std;
using filesystem::path;

path operator""_p(const char* data, std::size_t sz) {
    return path(data, data + sz);
}

void CreateFile(path p) {
    ofstream file(p);
    if (file) {
        cout << "Файл создан: "s << p.string() << endl;
    } else {
        cout << "Ошибка создания файла: "s << p.string() << endl;
    }
}

int main() {
    error_code err;

    path p = "tmp"_p / "a"_p / "folder"_p;

    CreateFile(p / "file.txt"_p);

    filesystem::create_directory(p, err);
    if (err) {
        cout << "Ошибка создания папки через create_directory: "s << err.message() << endl;
    } else {
        cout << "Успешно создана папка через create_directory: "s << p.string() << endl;
    }

    filesystem::create_directories(p, err);
    if (err) {
        cout << "Ошибка создания папки через create_directories: "s << err.message() << endl;
    } else {
        cout << "Успешно создана папка через create_directories: "s << p.string() << endl;
    }

    CreateFile(p / "file.txt"_p);

    path p2 = p.parent_path() / "folder2"_p;
    filesystem::create_directory(p2, err);
    if (err) {
        cout << "Ошибка создания папки через create_directory: "s << err.message() << endl;
    } else {
        cout << "Успешно создана папка через create_directory: "s << p2.string() << endl;
    }

    CreateFile(p2 / "file.txt"_p);
}
Возможный вывод:
Ошибка создания файла: tmp/a/folder/file.txt
Ошибка создания папки через create_directory: No such file or directory
Успешно создана папка через create_directories: tmp/a/folder
Файл создан: tmp/a/folder/file.txt
Успешно создана папка через create_directory: tmp/a/folder2
Файл создан: tmp/a/folder2/file.txt
Различение файла и папки
Чтобы получить информацию об объекте файловой системы, используйте filesystem::status. Эта функция принимает путь и возвращает объект типа filesystem::file_status. Как и другие функции библиотеки filesystem, она имеет необязательный второй параметр типа std::error_code, заменяющий исключения.
Имея file_status, можно проверить, является ли объект файлом или папкой:
void PrintFileOrFolder(filesystem::path p) {
    error_code err;
    auto status = filesystem::status(p, err);
    
    if (err) {
        return;
    }

    if (status.type() == filesystem::file_type::regular) {
        cout << "Путь "s << p.string() << " указывает на файл"s << endl;
    } else if (status.type() == filesystem::file_type::directory) {
        cout << "Путь "s << p.string() << " указывает на папку"s << endl;
    } else {
        cout << "Путь "s << p.string() << " указывает на другой объект"s << endl;
    }
}
Функция status не считает ошибкой ситуацию, когда путь указывает на несуществующий объект.
Получение всех файлов в папке
Можно пройтись циклом for по всем объектам в папке, используя класс filesystem::directory_iterator:
#include <filesystem>
#include <fstream>
#include <iostream>

using namespace std;
using filesystem::path;

path operator""_p(const char* data, std::size_t sz) {
    return path(data, data + sz);
}

...

int main() {
    path p = "a"_p / "folder"_p;
    filesystem::create_directories(p);
    filesystem::create_directory(p / "subfolder"_p);
    std::ofstream(p / "file.txt"_p) << "File content"s;

    for (const auto& dir_entry: filesystem::directory_iterator(p)) {
        PrintFileOrFolder(dir_entry.path());
    }
}
Возможный вывод:
Путь a/folder/file.txt указывает на файл
Путь a/folder/subfolder указывает на папку
Порядок обхода директории не регламентирован. Гарантируется только, что каждый файл будет пройден один раз.
Элемент папки dir_entry имеет тип filesystem::directory_entry, который помимо самого пути уже содержит в себе закешированный статус и другую информацию. Чтобы не выполнять лишних обращений к файловой системе, можно использовать этот статус, изменив функцию PrintFileOrFolder:
void PrintFileOrFolder(filesystem::file_status status) {
    if (status.type() == filesystem::file_type::regular) {
        cout << "Путь указывает на файл"s << endl;
    } else if (status.type() == filesystem::file_type::directory) {
        cout << "Путь указывает на папку"s << endl;
    } else {
        cout << "Путь указывает другой объект"s << endl;
    }
}
void PrintFileOrFolder(filesystem::path p) {
    error_code err;
    auto status = filesystem::status(p, err);
    
    if (err) {
        return;
    }

    PrintFileOrFolder(status);
}
Цикл в функции main тоже нужно заменить:
   for (const auto& dir_entry: filesystem::directory_iterator(p)) {
        PrintFileOrFolder(dir_entry.status());
    }
Больше о путях
У пути есть два формата строкового представления: native и generic. В native-формате путь выглядит так, как он должен быть представлен в операционной системе. Метод path::string возвращает путь в этом представлении. Оно рекомендуется в большинстве случаев.
Формат generic одинаковый на всех операционных системах. Он определяет папки прямым слешем. Чтобы получить generic-представление, вызовите метод generic_string. Это метод класса path. Такой формат полезен при конструировании пути из string. Например, путь, аналогичный пути из прошлого урока, можно задать так:
path p = path("a/folder/and/../a/file.txt"s, path::generic_format);
Тут вы видите второй параметр при конструировании пути из string. По умолчанию он равен path::generic_format::auto_format. Это значение подразумевает, что компилятор постарается универсальным образом интерпретировать путь.
Под Windows путь в native-формате иногда содержит оба вида слешей, но предпочтительнее обратный. Можно явно заменить в переменной типа path все слеши на предпочтительные методом make_preferred:
path p = path("a/folder/and/../a/file.txt"s, path::generic_format);

cout << "p.string():                      "s << p.string() << endl;
p.make_preferred();
cout << "p.string() после make_preferred: "s << p.string() << endl;
cout << "p.generic_string():              "s << p.generic_string() << endl;
Возможный вывод:
p.string():                      a/folder/and/../a/file.txt
p.string() после make_preferred: a\folder\and\..\a\file.txt
p.generic_string():              a/folder/and/../a/file.txt
Рассмотрим другие операции с путями, которые не вошли в прошлый урок.
Нормализация
Пути, содержащие элементы папки., папки .. или несколько слешей подряд, легко упростить. Это делается методом lexically_normal:
path p = "a"_p / "folder"_p / "and"_p / ".."_p / "a"_p / "file.txt"_p;

cout << "Исходный вид: "s << p.string() << endl;
p = p.lexically_normal();
cout << "После lexically_normal(): "s << p.string() << endl;
Возможный вывод:
Исходный вид: a/folder/and/../a/file.txt
После lexically_normal(): a/folder/a/file.txt
Полученный путь называется нормальным.
Получение родительской папки
Чтобы получить родительскую папку, используйте метод пути parent_path. Но он действует довольно наивно — просто убирает последний элемент пути, если это был не единственный элемент.
Другое
В библиотеке filesystem есть и другие функции, которые устроены по аналогии с описанными. Полный их список — на сайте cppreference.
Вот некоторые из них:
exists — проверка существования файла или папки. Может принимать статус или путь.
copy, copy_file — копирование файлов и папок.
current_path — получение и изменение текущего пути.
equivalent — проверка, что два пути указывают на один объект.
file_size — получение размера файла.
remove, remove_all — удаление файлов и папок.
resize_file — изменение размера файлов. Увеличивать размер можно потоком ofstream, а уменьшать — этой функцией.
Нет никакой гарантии, что за время, прошедшее с проверки условия if до попытки открытия, другая программа не удалит файл. К тому же, за это время кто-нибудь может создать папку на его месте. Более того, в программе есть серьёзная ошибка: если вы не указали второй параметр у функции status, он может выбросить исключение, которое точно не будет обработано, поскольку этот код расположен прямо в main.
Может показаться маловероятным, что файл удаляется сразу после проверки существования. Но следует учитывать две вещи:
Для программиста не существует понятия «маловероятно». Любая ошибка может не проявляться лишь до поры до времени.
Некоторые программы устанавливают обработчики событий на изменение файловой системы. Например, на создание файлов. Так делают антивирусы. Когда проверяете на существование только что созданный файл, какой-нибудь антивирус может одновременно пытаться его удалить, заподозрив в нём вредоносный код.
В условиях совместного доступа всех программ к файловой системе следует всегда контролировать ошибки, даже если предыдущие проверки показали, что ошибки быть не должно. Операционная система в некоторых случаях будет вам помогать, оберегая открытые файлы от модификации другими программами. В общем случае в различных ОС есть возможности для совместной работы с файловой системой. Они не входят в стандартную библиотеку и в этот курс тоже.
Свой препроцессор с регулярными выражениями и сырыми литералами
В задании к этому уроку предлагаем вам написать препроцессор C++, который будет подставлять содержимое файлов на место #include-директив.
При выполнении задания пригодятся регулярные выражения. В C++ функции для работы с регулярными выражениями располагаются в стандартном заголовочном файле <regex>. Они подробно описаны в документации на cppreference. В этом уроке кратко перечислены возможности, полезные для решения задачи.
Регулярное выражение представляется объектом класса std::regex. Его можно сконструировать из строки или строкового литерала. Для проверки строки на соответствие регулярному выражению используйте алгоритм regex_match, принимающий следующие параметры:
str — строка или литерал, которую нужно проверять на соответствие. Можно также указывать два итератора на символы;
m (необязательный) — ссылка на объект типа smatch, в который будет записан результат сопоставления;
e — само регулярное выражение;
flags (необязательный) — параметры соответствия.
Функция возвращает true, если соответствие найдено. При этом метод empty параметра m будет возвращать false.
Рассмотрим регулярное выражения для чисел с плавающей точкой, окруженных любым количеством пробельных символов. Ещё оно поможет выделить целую и дробную часть числа:
#include <iostream>
#include <regex>

using namespace std;

void PrintFloatInfo(const std::string& text) {
    static regex num_reg("\\s*([+-]?[0-9]+)\\.([0-9]*)(e[+-]?[0-9]+)?\\s*");
    smatch m;

    if (!regex_match(text, m, num_reg)) {
        cout << text << " - не число с плавающей точкой"s << endl;
    } else {
        cout << text << " - число с целой частью "s << m[1]
                     << ", дробной частью "s << m[2] << endl;
    }
}

int main() {
    PrintFloatInfo("aaabbb"s);
    PrintFloatInfo("3.1415926535"s);
    PrintFloatInfo("  123.\t"s);
    PrintFloatInfo("1.2.3"s);
    PrintFloatInfo("10.5a"s);
    PrintFloatInfo("10.5e+05"s);
}
Программа выведет:
aaabbb - не число с плавающей точкой
3.1415926535 - число с целой частью 3, дробной частью 1415926535
  123.     - число с целой частью 123, дробной частью 
1.2.3 - не число с плавающей точкой
10.5a - не число с плавающей точкой
10.5e+05 - число с целой частью 10, дробной частью 5
В этом выражении использованы группы — скобки, которые помечают определённые фрагменты регулярного выражения. Так мы получили целую и дробную части.
Формальное описание синтаксиса регулярных выражений, используемых в C++, есть в документации. Более простое и живое описание дано на русском языке в этой статье.
Также допустимы другие форматы регулярных выражений. Формат задаётся флагом при создании объекта regex.
Регулярное выражение из примера выглядело так: \s*([+-]?[0-9]+)\.([0-9]*)(e[+-]?[0-9]+)?\s*. Читать его непросто, но для записи в коде пришлось экранировать все слеши, что ещё сильнее затрудняет чтение. Вместо этого можно было использовать сырой литерал — разновидность строкового литерала, позволяющую не экранировать спецсимволы: слеши, переводы строк и даже кавычки.
Чтобы задать сырой литерал в C++, поставьте перед кавычкой букву R. Литерал позволяет задать произвольную последовательность конца литерала, которая пишется между кавычкой и открывающей скобкой. Чтобы показать, где литерал закончился, закройте скобку и повторите эту последовательность. Для регулярного выражения можно использовать последовательность конца из одного символа /:
static regex num_reg(R"/(\s*([+-]?[0-9]+)\.([0-9]*)(e[+-]?[0-9]+)?\s*)/");

## Лучшие практики / Плохие практики (стандарт до C++17 включительно)

### Управление буферами

**Хорошо:**
```cpp
// Используйте \n вместо endl для лучшей производительности
cout << "Быстрый вывод\n";

// Принудительно сбрасывайте буфер только при необходимости
cout << "Критичные данные" << flush;

// Используйте большие буферы для файловых операций
const size_t BUFFER_SIZE = 8192;
vector<char> buffer(BUFFER_SIZE);
```

**Плохо:**
```cpp
// endl сбрасывает буфер каждый раз - медленно!
cout << "Медленный вывод" << endl;

// Ненужное частое сбрасывание
cout << "данные" << flush << "ещё данные" << flush;

// Побайтовое чтение больших файлов
char c;
while (file.get(c)) {
    // обработка одного символа - очень медленно
}
```

### Синхронизация потоков

**Хорошо:**
```cpp
// Отвяжите cin от cout для более быстрого ввода-вывода
cin.tie(nullptr);

// Отключите синхронизацию C/C++ stdio
ios_base::sync_with_stdio(false);

// Используйте RAII для управления привязками
class StreamUntier {
    ostream* old_tie;
public:
    StreamUntier() : old_tie(cin.tie(nullptr)) {}
    ~StreamUntier() { cin.tie(old_tie); }
};

// Восстанавливайте состояние в библиотечном коде
auto old_tie = cin.tie(nullptr);
// ... операции ...
cin.tie(old_tie);
```

**Плохо:**
```cpp
// Оставление стандартной синхронизации в спортивном программировании
// cin.tie() остается привязанным к cout - принуждает сброс буферов

// Не восстанавливать состояние привязки в библиотечном коде
cin.tie(nullptr); // Может неожиданно повлиять на другой код
```

### Файловые операции

**Хорошо:**
```cpp
// Всегда используйте бинарный режим для не-текстовых файлов
ifstream file("data.bin", ios::binary);

// Используйте буферизованное чтение для больших файлов
const size_t BUFFER_SIZE = 1024;
array<char, BUFFER_SIZE> buffer;
while (file.read(buffer.data(), BUFFER_SIZE)) {
    // обработать buffer.data(), file.gcount() байт
}

// Проверяйте файловые операции
if (!file) {
    cerr << "Файловая операция не удалась\n";
}

// Используйте подходящие флаги открытия
ofstream file("log.txt", ios::app); // дописывание в конец
```

**Плохо:**
```cpp
// Чтение бинарных файлов без флага binary - может повредить данные
ifstream file("data.bin"); // Отсутствует ios::binary

// Не проверять файловые операции
ifstream file("nonexistent.txt");
string data;
file >> data; // Может тихо завершиться неудачей

// ofstream перезаписывает файл по умолчанию
ofstream file("important_data.txt"); // Удалит существующие данные!
```

### Обработка ошибок

**Хорошо:**
```cpp
// Проверяйте состояние потока перед операциями
if (stream.good()) {
    stream >> data;
}

// Используйте error_code чтобы избежать исключений
error_code ec;
auto status = filesystem::status("file.txt", ec);
if (!ec) {
    // обработать status
}

// Сбрасывайте флаги ошибок когда уместно
stream.clear(); // Сбросить флаги ошибок
if (stream >> fallback_data) {
    // попытка другого формата данных
}
```

**Плохо:**
```cpp
// Игнорирование состояния потока
stream >> data; // Может не работать если у потока установлены флаги ошибок

// Проверка существования файла, затем открытие (состояние гонки)
if (filesystem::exists("file.txt")) {
    ifstream file("file.txt"); // Файл может быть удален между проверкой и открытием
}

// Не обрабатывать ошибки filesystem
filesystem::create_directories("path"); // Может выбросить filesystem_error
```

### Память и производительность

**Хорошо:**
```cpp
// Используйте строковые потоки для форматирования
ostringstream oss;
oss << "Значение: " << value << "\n";
string result = oss.str();

// Резервируйте место для операций известного размера
string buffer;
buffer.reserve(estimated_size);

// Используйте подходящие размеры буферов (обычно оптимально 1KB-64KB)
vector<char> buffer(8192);

// Статические regex объекты для повторного использования
static const regex pattern(R"(\d{3}-\d{2}-\d{4})");
```

**Плохо:**
```cpp
// Множественные малые конкатенации строк
string result = "Значение: ";
result += to_string(value);
result += "\n"; // Множественные перевыделения памяти

// Создание regex объектов в циклах
for (const string& text : texts) {
    regex pattern("\\d+"); // Пересоздается каждую итерацию - медленно!
    // ...
}

// Использование стандартных крошечных буферов для больших операций
array<char, 1> tiny_buffer; // Слишком мал, вызывает много I/O операций
```

### Пути и операции файловой системы

**Хорошо:**
```cpp
// Используйте filesystem::path для переносимых путей
namespace fs = std::filesystem;
fs::path p = fs::path("folder") / "subfolder" / "file.txt";

// Создайте пользовательский литерал пути для удобства
fs::path operator""_p(const char* str, size_t len) {
    return fs::path(str, str + len);
}
// Тогда можно писать: "folder"_p / "file.txt"_p

// Всегда обрабатывайте ошибки файловой системы
error_code ec;
fs::create_directories("deep/nested/path", ec);
if (ec) {
    cerr << "Не удалось создать директорию: " << ec.message() << "\n";
}

// Нормализуйте пути для сравнения
auto normalized = path.lexically_normal();
```

**Плохо:**
```cpp
// Жестко закодированные разделители путей - не переносимо
string path = "folder\\subfolder\\file.txt"; // Только Windows
string path = "folder/subfolder/file.txt";   // Только Unix

// Не обрабатывать исключения filesystem
fs::create_directories("path"); // Может выбросить filesystem_error

// Сравнение не нормализованных путей
if (path1.string() == path2.string()) { // Может не работать для "a/b" vs "a/./b"
```

### Регулярные выражения и сырые литералы

**Хорошо:**
```cpp
// Используйте сырые литералы для regex паттернов
regex pattern(R"(\d{3}-\d{2}-\d{4})"); // Паттерн SSN
regex email_pattern(R"([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})");

// Статические regex объекты для повторного использования
static const regex num_pattern(R"([+-]?\d+\.?\d*)");

// Используйте именованные группы когда возможно
regex date_pattern(R"((\d{4})-(\d{2})-(\d{2}))"); // год-месяц-день
```

**Плохо:**
```cpp
// Экранирование обратных слешей делает regex нечитаемым
regex pattern("\\d{3}-\\d{2}-\\d{4}");

// Создание regex объектов многократно в циклах
for (const string& text : texts) {
    regex pattern("\\d+"); // Пересоздается каждую итерацию - медленно!
    // ...
}
```

### Оптимизации для спортивного программирования

**Хорошо:**
```cpp
// Стандартная настройка I/O для спортивного программирования
ios_base::sync_with_stdio(false);
cin.tie(nullptr);
cout.tie(nullptr);

// Используйте '\n' вместо endl в плотных циклах
for (int i = 0; i < n; ++i) {
    cout << results[i] << '\n';
}

// Читайте большими блоками для больших входных данных
vector<int> data(n);
for (int i = 0; i < n; ++i) {
    cin >> data[i];
}
```

**Плохо:**
```cpp
// Использование endl в спортивном программировании
for (int i = 0; i < 100000; ++i) {
    cout << i << endl; // Крайне медленно из-за сброса буфера
}

// Оставление стандартной синхронизации
// (стандартные настройки медленнее для чистого C++ I/O)

// Чтение по одному элементу в больших циклах
for (int i = 0; i < 1000000; ++i) {
    int x;
    cin >> x; // Много накладных расходов на каждое чтение
    process(x);
}
```
