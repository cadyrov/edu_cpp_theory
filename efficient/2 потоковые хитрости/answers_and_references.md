# Ответы к тесту: Потоковые хитрости и оптимизация I/O

## Правильные ответы:

1. **b** - Ни одной строки не будет записано (буфер не сброшен до аварийного завершения)
2. **b** - endl переводит строку и сбрасывает буфер, \n только переводит строку
3. **b** - Вариант B (без сброса буфера на каждой итерации)
4. **b** - Отвязывает cin от cout, устраняя автоматические сбросы буфера
5. **b** - Потому что операция чтения cin автоматически сбрасывает буфер cout
6. **c** - Порядок вывода не определен (отключена синхронизация C/C++ stdio)
7. **c** - 1-64 КБ (оптимальный баланс производительности)
8. **b** - Отсутствует флаг ios::binary (для изображений критично)
9. **a** - file.get() (для одного символа оптимизирован)
10. **b** - Количество символов, прочитанных последней операцией read
11. **b** - "World" (второй ofstream очищает файл)
12. **b** - Добавляет данные в конец файла
13. **b** - Только вариант B (требуется binary режим)
14. **b** - Флаги состояния потока
15. **c** - При критической ошибке ввода-вывода
16. **b** - Сбрасывает флаги ошибок потока
17. **c** - Оба правильные (разные подходы к обработке ошибок)
18. **b** - Класс для работы с путями файловой системы
19. **b** - "folder/subfolder"
20. **b** - Вариант B более читаемый (сырые литералы)
21. **b** - Regex создается в каждой итерации (неэффективно)
22. **b** - Перемещает указатель записи в конец файла
23. **a** - "Hello" (перемещение указателя чтения в начало)
24. **b** - tellg для чтения, tellp для записи
25. **c** - Поток устанавливает флаги ошибок
26. **b** - Использование endl вместо '\n'
27. **a** - Вариант A (ostringstream эффективнее для множественных конкатенаций)
28. **b** - Итератор для обхода файлов в директории
29. **b** - endl медленнее из-за сброса буфера
30. **c** - Заменяет слеши на предпочтительные для ОС
31. **b** - Состояние гонки - файл может быть удален между проверкой и открытием
32. **b** - Вариант B (большие буферы эффективнее)
33. **a** - "Valid email" (корректный email адрес)
34. **b** - Строки без экранирования спецсимволов
35. **b** - Автоматически восстанавливает состояние при выходе из области видимости
36. **b** - Код B быстрее (менее накладных расходов I/O)
37. **b** - Не переносимо между ОС (Windows-специфичные слеши)
38. **b** - stream.good() (проверяет перед операцией)
39. **b** - "Not equal" (пути не нормализованы)
40. **b** - Производительность улучшится значительно

## Объяснения к сложным вопросам:

### Вопрос 1
Буферизация означает, что данные сначала накапливаются в памяти и записываются на диск большими блоками. При аварийном завершении буфер не успевает сброситься.

### Вопрос 6  
После отключения синхронизации с `sync_with_stdio(false)` порядок вывода между C++ потоками (cout) и C функциями (printf) становится неопределенным.

### Вопрос 13
Бинарные файлы могут содержать нулевые байты и специальные символы, которые getline воспринимает как разделители. Только binary режим гарантирует корректное копирование.

### Вопрос 21
Создание regex объекта - дорогая операция. Лучше создать его один раз как static переменную.

### Вопрос 27
ostringstream внутренне управляет буфером и растет эффективно, тогда как operator+= может вызывать множественные перевыделения памяти.

### Вопрос 31
Между проверкой существования файла и его открытием другой процесс может удалить файл. Это классическая проблема "время проверки vs время использования" (TOCTOU).

### Вопрос 39
Путь "a/b/../c" не нормализован и строково не равен "a/c", хотя указывает на то же место. Нужно использовать lexically_normal() для сравнения. 