# Тест: Потоковые хитрости и оптимизация I/O

## Вопрос 1
Что произойдет с данными при аварийном завершении программы в следующем коде?
```cpp
ofstream out_file("test.txt");
for (int i = 0; i < 5; ++i) {
    out_file << "Line " << i << "\n";
}
throw;
```

a) Все 5 строк будут записаны в файл
b) Ни одной строки не будет записано
c) Будет записано случайное количество строк
d) Программа не скомпилируется

## Вопрос 2
Чем отличается `endl` от `"\n"`?

a) endl только переводит строку, \n еще и сбрасывает буфер
b) endl переводит строку и сбрасывает буфер, \n только переводит строку
c) Никакой разницы нет
d) endl работает только с файлами, \n только с консолью

## Вопрос 3
Какой код будет работать быстрее для записи 100000 строк?
```cpp
// Вариант A
for (int i = 0; i < 100000; ++i) {
    cout << i << endl;
}

// Вариант B
for (int i = 0; i < 100000; ++i) {
    cout << i << "\n";
}
```

a) Вариант A
b) Вариант B
c) Одинаково быстро
d) Зависит от компилятора

## Вопрос 4
Что делает команда `cin.tie(nullptr)`?

a) Отключает поток cin
b) Отвязывает cin от cout, устраняя автоматические сбросы буфера
c) Привязывает cin к cout
d) Очищает буфер cin

## Вопрос 5
Анализируйте код:
```cpp
int main() {
    cout << "Enter number: ";
    int x;
    cin >> x;
    cout << "You entered: " << x << endl;
}
```
Почему приглашение "Enter number: " всегда видно перед вводом?

a) Потому что cout быстрее cin
b) Потому что операция чтения cin автоматически сбрасывает буфер cout
c) Потому что endl принудительно выводит данные
d) Потому что это особенность компилятора

## Вопрос 6
Что произойдет после выполнения этого кода?
```cpp
ios_base::sync_with_stdio(false);
cin.tie(nullptr);
cout << "Hello";
printf("World");
```

a) Выведет "HelloWorld"
b) Выведет "WorldHello"
c) Порядок вывода не определен
d) Программа не скомпилируется

## Вопрос 7
Какой размер буфера оптимален для чтения больших файлов?

a) 1 байт
b) 16 байт
c) 1-64 КБ
d) 1 МБ

## Вопрос 8
Что неправильно в этом коде?
```cpp
ifstream file("image.jpg");
char buffer[1024];
while (file.read(buffer, 1024)) {
    // обработка данных
}
```

a) Слишком маленький буфер
b) Отсутствует флаг ios::binary
c) Неправильный размер буфера
d) Нет проверки на ошибки

## Вопрос 9
Какой метод быстрее для чтения одного символа?

a) `file.get()`
b) `file.read(&c, 1)`
c) Одинаково быстро
d) Зависит от размера файла

## Вопрос 10
Что возвращает `file.gcount()` после операции `read`?

a) Общее количество прочитанных символов с начала работы с файлом
b) Количество символов, прочитанных последней операцией read
c) Размер файла в байтах
d) Текущую позицию в файле

## Вопрос 11
Анализируйте код:
```cpp
ofstream file("test.txt");
file << "Hello";
file.close();
ofstream file2("test.txt");
file2 << "World";
```
Что будет в файле test.txt?

a) "HelloWorld"
b) "World" 
c) "Hello"
d) Пустой файл

## Вопрос 12
Что делает флаг `ios::app`?

a) Открывает файл в бинарном режиме
b) Добавляет данные в конец файла
c) Создает новый файл
d) Открывает файл только для чтения

## Вопрос 13
Какой код корректно копирует бинарный файл?
```cpp
// Вариант A
ifstream in("source.bin");
ofstream out("dest.bin");
string line;
while (getline(in, line)) {
    out << line << "\n";
}

// Вариант B
ifstream in("source.bin", ios::binary);
ofstream out("dest.bin", ios::binary);
char buffer[1024];
while (in.read(buffer, 1024)) {
    out.write(buffer, in.gcount());
}
```

a) Только вариант A
b) Только вариант B
c) Оба варианта
d) Ни один из вариантов

## Вопрос 14
Что такое флаги `badbit`, `failbit`, `eofbit`?

a) Флаги компиляции
b) Флаги состояния потока
c) Флаги открытия файла
d) Флаги буферизации

## Вопрос 15
Анализируйте код:
```cpp
ifstream file("numbers.txt");
int x;
while (file >> x) {
    cout << x << " ";
}
if (file.bad()) {
    cout << "Critical error";
}
```
Когда выведется "Critical error"?

a) Когда файл не существует
b) Когда достигнут конец файла
c) При критической ошибке ввода-вывода
d) Когда в файле не число

## Вопрос 16
Что делает метод `stream.clear()`?

a) Очищает содержимое потока
b) Сбрасывает флаги ошибок потока
c) Закрывает поток
d) Удаляет файл

## Вопрос 17
Какой код правильно обрабатывает ошибки filesystem?
```cpp
// Вариант A
try {
    filesystem::create_directories("path");
} catch (filesystem_error& e) {
    cout << e.what();
}

// Вариант B
error_code ec;
filesystem::create_directories("path", ec);
if (ec) {
    cout << ec.message();
}
```

a) Только A
b) Только B
c) Оба правильные
d) Оба неправильные

## Вопрос 18
Что такое `filesystem::path`?

a) Строка с именем файла
b) Класс для работы с путями файловой системы
c) Указатель на файл
d) Дескриптор файла

## Вопрос 19
Анализируйте код:
```cpp
namespace fs = std::filesystem;
fs::path p = "folder/subfolder/file.txt";
cout << p.parent_path().string();
```
Что выведется?

a) "folder/subfolder/file.txt"
b) "folder/subfolder"
c) "file.txt"
d) "folder"

## Вопрос 20
Что лучше для regex паттернов?
```cpp
// Вариант A
regex pattern("\\d{3}-\\d{2}-\\d{4}");

// Вариант B
regex pattern(R"(\d{3}-\d{2}-\d{4})");
```

a) Вариант A более читаемый
b) Вариант B более читаемый
c) Одинаково читаемые
d) Вариант A быстрее

## Вопрос 21
В чем проблема этого кода?
```cpp
for (const string& text : texts) {
    regex pattern("\\d+");
    if (regex_match(text, pattern)) {
        // обработка
    }
}
```

a) Неправильный паттерн
b) Regex создается в каждой итерации
c) Неправильное использование regex_match
d) Проблем нет

## Вопрос 22
Что делает `file.seekp(0, ios::end)`?

a) Перемещает указатель чтения в конец файла
b) Перемещает указатель записи в конец файла
c) Перемещает указатель в начало файла
d) Удаляет содержимое файла

## Вопрос 23
Анализируйте код:
```cpp
fstream file("test.txt", ios::in | ios::out);
file << "Hello";
file.seekg(0);
string word;
file >> word;
cout << word;
```
Что выведется?

a) "Hello"
b) Ничего
c) Ошибка компиляции
d) Неопределенное поведение

## Вопрос 24
Какая разница между `tellg()` и `tellp()`?

a) tellg для записи, tellp для чтения
b) tellg для чтения, tellp для записи  
c) Никакой разницы
d) tellg работает только с текстовыми файлами

## Вопрос 25
Что происходит при открытии несуществующего файла через `ifstream`?

a) Файл создается автоматически
b) Выбрасывается исключение
c) Поток устанавливает флаги ошибок
d) Программа завершается

## Вопрос 26
Анализируйте код для спортивного программирования:
```cpp
ios_base::sync_with_stdio(false);
cin.tie(nullptr);
int n;
cin >> n;
for (int i = 0; i < n; ++i) {
    cout << i << endl;
}
```
Какая ошибка производительности?

a) Отсутствует cout.tie(nullptr)
b) Использование endl вместо '\n'
c) Неправильная последовательность оптимизаций
d) Ошибок нет

## Вопрос 27
Что лучше для больших объемов данных?
```cpp
// Вариант A
ostringstream oss;
for (int i = 0; i < 10000; ++i) {
    oss << "value" << i << "\n";
}
string result = oss.str();

// Вариант B  
string result;
for (int i = 0; i < 10000; ++i) {
    result += "value" + to_string(i) + "\n";
}
```

a) Вариант A
b) Вариант B
c) Одинаково эффективно
d) Зависит от компилятора

## Вопрос 28
Что такое `filesystem::directory_iterator`?

a) Указатель на директорию
b) Итератор для обхода файлов в директории
c) Размер директории
d) Права доступа к директории

## Вопрос 29
Анализируйте код:
```cpp
ifstream file("test.txt");
string line;
while (getline(file, line)) {
    cout << line << "\n";
}
```
Почему не используется `endl`?

a) endl не работает со строками
b) endl медленнее из-за сброса буфера
c) endl только для чисел
d) Это ошибка, нужно использовать endl

## Вопрос 30
Что делает `make_preferred()` у `filesystem::path`?

a) Делает путь абсолютным
b) Нормализует путь
c) Заменяет слеши на предпочтительные для ОС
d) Проверяет существование пути

## Вопрос 31
В чем проблема этого кода?
```cpp
if (filesystem::exists("file.txt")) {
    ifstream file("file.txt");
    // работа с файлом
}
```

a) Неправильный синтаксис
b) Состояние гонки - файл может быть удален между проверкой и открытием
c) Нужно использовать exception handling
d) Проблем нет

## Вопрос 32
Какой код эффективнее?
```cpp
// Вариант A
vector<char> buffer(1);
while (file.read(buffer.data(), 1)) {
    process(buffer[0]);
}

// Вариант B
vector<char> buffer(8192);
while (file.read(buffer.data(), 8192)) {
    for (int i = 0; i < file.gcount(); ++i) {
        process(buffer[i]);
    }
}
```

a) Вариант A
b) Вариант B
c) Одинаково эффективно
d) A эффективнее по памяти

## Вопрос 33
Анализируйте код:
```cpp
regex email_pattern(R"([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})");
string text = "test@example.com";
if (regex_match(text, email_pattern)) {
    cout << "Valid email";
}
```
Что выведется?

a) "Valid email"
b) Ничего
c) Ошибка компиляции
d) Исключение

## Вопрос 34
Что такое сырые литералы (raw literals)?

a) Неинициализированные строки
b) Строки без экранирования спецсимволов
c) Бинарные данные
d) Числовые константы

## Вопрос 35
В чем преимущество RAII для управления потоками?
```cpp
class StreamUntier {
    ostream* old_tie;
public:
    StreamUntier() : old_tie(cin.tie(nullptr)) {}
    ~StreamUntier() { cin.tie(old_tie); }
};
```

a) Быстрее работает
b) Автоматически восстанавливает состояние при выходе из области видимости
c) Использует меньше памяти
d) Предотвращает ошибки компиляции

## Вопрос 36
Анализируйте производительность:
```cpp
// Код A
for (int i = 0; i < 1000000; ++i) {
    int x;
    cin >> x;
    cout << x * x << "\n";
}

// Код B  
vector<int> data(1000000);
for (int i = 0; i < 1000000; ++i) {
    cin >> data[i];
}
for (int i = 0; i < 1000000; ++i) {
    cout << data[i] * data[i] << "\n";
}
```

a) Код A быстрее
b) Код B быстрее
c) Одинаково быстро
d) B использует больше памяти, но не быстрее

## Вопрос 37
Что неправильно в этом пути?
```cpp
string path = "folder\\subfolder\\file.txt";
ifstream file(path);
```

a) Синтаксическая ошибка
b) Не переносимо между ОС
c) Файл не откроется
d) Нет проблем

## Вопрос 38
Какой метод лучше для проверки состояния потока перед чтением?

a) `stream`
b) `stream.good()`
c) `stream.bad()`
d) `stream.eof()`

## Вопрос 39
Анализируйте код:
```cpp
filesystem::path p1 = "a/b/../c";
filesystem::path p2 = "a/c";
if (p1.string() == p2.string()) {
    cout << "Equal";
} else {
    cout << "Not equal";
}
```
Что выведется?

a) "Equal"
b) "Not equal"
c) Ошибка компиляции
d) Исключение

## Вопрос 40
Что произойдет с производительностью при такой настройке?
```cpp
ios_base::sync_with_stdio(false);
cin.tie(nullptr);
cout.tie(nullptr);
// множественные операции cin/cout
```

a) Производительность ухудшится
b) Производительность улучшится значительно
c) Изменений не будет
d) Возможны ошибки синхронизации 