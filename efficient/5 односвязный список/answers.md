# Ответы на тест: Односвязный список и работа с массивами

## Правильные ответы:

1. **c)** O(N) - Доступ к N-му элементу требует прохода по всем предыдущим элементам
2. **b)** Неопределенное поведение - Использование delete вместо delete[] для массива
3. **c)** before_begin() - Нужен итератор на позицию перед первым элементом
4. **b)** Постфиксный инкремент - Параметр int указывает на постфиксную форму
5. **b)** std::forward_iterator_tag - Односвязный список поддерживает только движение вперед
6. **b)** Неопределенное поведение - Обращение за границы массива
7. **c)** Для поддержки итератора before_begin() - Основная причина использования фиктивного узла
8. **b)** Обменивает содержимое двух списков - Функция swap обменивает содержимое
9. **b)** const Type* - Константный итератор возвращает указатель на константу
10. **c)** Неопределенное поведение - Использование итератора после очистки списка
11. **b)** Вторая реализация более безопасна - Использует идиому copy-and-swap
12. **c)** SingleLinkedList может обращаться к приватным членам BasicIterator
13. **b)** 2 - p указывает на arr[2], p[-1] это arr[1]
14. **b)** Предупреждает, если возвращаемое значение игнорируется
15. **a)** O(1) - Вставка в начало выполняется за константное время
16. **b)** Утечка памяти - Нет деструктора для освобождения памяти
17. **b)** Type& operator*() const - Возвращает ссылку для возможности модификации
18. **b)** Удаляет элемент после позиции pos - EraseAfter удаляет следующий элемент
19. **c)** std::ptrdiff_t - Стандартный тип для разности указателей
20. **c)** Неопределенное поведение - Разыменование указателя за границами массива
21. **b)** Вторая реализация более эффективна - Проверяет размеры перед сравнением
22. **c)** Сохраняет категорию значения (lvalue/rvalue) - Perfect forwarding
23. **b)** Get() - Возвращает указатель без передачи владения (в стандартных умных указателях)
24. **c)** Неопределенное поведение - Использование указателя после clear()
25. **a)** Префиксная (++it) - Не создает временный объект
26. **b)** Конструктор перемещения - Принимает rvalue ссылку
27. **d)** Все варианты верны - Все перечисленные недостатки справедливы
28. **b)** Неопределенное поведение - Разность указателей на разные массивы
29. **d)** Все варианты правильные - Все способы инициализации корректны
30. **a)** Создает список {0, 1, 2, 3, 4} - Последовательная вставка после текущей позиции
31. **b)** Постфиксный инкремент не сохраняет старое значение
32. **b)** Итератор поддерживает движение только вперед
33. **b)** 30 10 - p[1] это arr[2], p[-1] это arr[0]
34. **d)** Все варианты верны - Copy-and-swap решает все перечисленные задачи
35. **c)** Не обеспечивает строгую гарантию безопасности исключений
36. **b)** Неопределенное поведение - Возврат указателя на локальную переменную
37. **c)** Все методы, которые не могут выбросить исключение
38. **b)** Обменивает указатели на массивы - Обмен сырых указателей
39. **c)** O(N) - Нужно удалить все элементы списка
40. **c)** Неопределенное поведение - Использование итератора после Clear()

## Статистика по темам:

### Временная сложность операций: 1, 15, 39
### Работа с памятью и массивами: 2, 6, 16, 20, 24, 28, 29, 36
### Итераторы: 3, 4, 5, 9, 10, 17, 19, 25, 31, 32, 37, 40
### Структура односвязного списка: 7, 8, 13, 18, 27, 30
### Безопасность исключений: 11, 34, 35
### Ключевые слова и атрибуты: 12, 14, 22, 26
### Операторы сравнения: 21, 33
### Умные указатели: 23, 38
### Лучшие практики: 1, 11, 21, 25, 35, 37 