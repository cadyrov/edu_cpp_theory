# Практические задания: Односвязный список

## Задание 1: Реализация базового односвязного списка

**Описание:** Реализуйте базовый односвязный список с методами PushFront, PopFront, IsEmpty, GetSize.

**Тесты:**
1. Создание пустого списка - IsEmpty() возвращает true
2. Вставка одного элемента - GetSize() возвращает 1
3. Вставка нескольких элементов - правильный размер
4. PopFront из пустого списка - корректная обработка
5. PopFront из списка с одним элементом - список становится пустым
6. Последовательность PushFront/PopFront - правильный порядок
7. Вставка 1000 элементов - корректный размер
8. Очистка списка через PopFront - размер становится 0
9. Проверка значений после вставки - правильные данные
10. Смешанные операции - корректность состояния

## Задание 2: Реализация итераторов

**Описание:** Добавьте поддержку итераторов (Iterator, ConstIterator) с методами begin(), end(), before_begin().

**Тесты:**
1. begin() пустого списка равен end()
2. Инкремент итератора - переход к следующему элементу
3. Разыменование итератора - получение значения
4. Сравнение итераторов - операторы == и !=
5. Обход списка через итераторы - все элементы доступны
6. Константные итераторы - только чтение
7. before_begin() указывает на позицию перед первым элементом
8. Постфиксный инкремент - возврат старого значения
9. Range-based for - корректный обход
10. Смешанное использование Iterator и ConstIterator

## Задание 3: Операции вставки и удаления

**Описание:** Реализуйте InsertAfter и EraseAfter для произвольной позиции.

**Тесты:**
1. InsertAfter в пустой список через before_begin()
2. InsertAfter в середину списка
3. InsertAfter в конец списка
4. EraseAfter из середины списка
5. EraseAfter последнего элемента
6. Последовательные вставки в одну позицию
7. Удаление всех элементов через EraseAfter
8. Возвращаемые итераторы корректны
9. Размер списка обновляется правильно
10. Цепочка операций InsertAfter/EraseAfter

## Задание 4: Конструкторы и присваивание

**Описание:** Реализуйте конструктор копирования, оператор присваивания и конструктор из initializer_list.

**Тесты:**
1. Конструктор копирования пустого списка
2. Конструктор копирования непустого списка
3. Самоприсваивание - корректная обработка
4. Присваивание пустого списка непустому
5. Присваивание непустого списка пустому
6. Конструктор из initializer_list
7. Глубокое копирование - изменения в копии не влияют на оригинал
8. Безопасность исключений при копировании
9. Правильный порядок элементов после копирования
10. Корректность размеров после операций

## Задание 5: Операторы сравнения

**Описание:** Реализуйте операторы ==, !=, <, >, <=, >= для сравнения списков.

**Тесты:**
1. Сравнение пустых списков - равны
2. Сравнение пустого и непустого списков
3. Сравнение списков одинакового размера с равными элементами
4. Сравнение списков одинакового размера с разными элементами
5. Лексикографическое сравнение - первый элемент меньше
6. Лексикографическое сравнение - списки разной длины
7. Сравнение списков с одинаковыми префиксами
8. Все операторы сравнения работают корректно
9. Транзитивность сравнений
10. Сравнение списков с одним элементом

## Задание 6: Метод swap и идиома copy-and-swap

**Описание:** Реализуйте метод swap и используйте его для безопасного присваивания.

**Тесты:**
1. Обмен двух пустых списков
2. Обмен пустого и непустого списков
3. Обмен двух непустых списков
4. Размеры списков обмениваются корректно
5. Содержимое списков обменивается полностью
6. swap не выбрасывает исключений
7. Использование swap в операторе присваивания
8. Безопасность исключений при присваивании
9. Эффективность swap - O(1)
10. Корректность состояния после swap

## Задание 7: Умный указатель ArrayPtr

**Описание:** Реализуйте RAII-обертку ArrayPtr для управления массивами в динамической памяти.

**Тесты:**
1. Создание ArrayPtr с заданным размером
2. Доступ к элементам через operator[]
3. Конструктор из сырого указателя
4. Метод Release() передает владение
5. Метод swap() обменивает указатели
6. Деструктор корректно освобождает память
7. Запрет копирования - удаленные операторы
8. Конструктор перемещения
9. Работа с массивами объектов
10. Корректность при размере 0

## Задание 8: Безопасность исключений

**Описание:** Обеспечьте строгую гарантию безопасности исключений во всех операциях.

**Тесты:**
1. Исключение в конструкторе копирования не приводит к утечкам
2. Исключение при вставке элемента - состояние не изменяется
3. Исключение в операторе присваивания - объект остается валидным
4. Исключение в конструкторе из initializer_list
5. Исключение при создании узла - память освобождается
6. Исключение в деструкторе элемента - обработка
7. Исключение при копировании элемента
8. Множественные исключения - корректная обработка
9. Исключение в пользовательском типе
10. Проверка отсутствия утечек памяти

## Задание 9: Оптимизация производительности

**Описание:** Оптимизируйте операции для максимальной производительности.

**Тесты:**
1. PushFront выполняется за O(1)
2. Вставка N элементов - линейная сложность
3. Обход списка - оптимальная скорость
4. Операции с итераторами не замедляют работу
5. Минимальное использование памяти
6. Кэш-эффективность при возможности
7. Отсутствие ненужных копирований
8. Эффективность операций сравнения
9. Быстрый swap - константное время
10. Оптимизация для часто используемых операций

## Задание 10: Расширенная функциональность

**Описание:** Добавьте дополнительные методы: front(), Clear(), PushBack(), PopBack().

**Тесты:**
1. front() возвращает первый элемент
2. front() для пустого списка - обработка ошибки
3. Clear() очищает список полностью
4. PushBack() добавляет элемент в конец
5. PopBack() удаляет последний элемент
6. PopBack() из пустого списка - корректная обработка
7. Комбинация PushFront/PushBack
8. Комбинация PopFront/PopBack
9. Все методы поддерживают корректный размер
10. Итераторы остаются валидными при возможности 