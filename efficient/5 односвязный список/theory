Как устроен односвязный список
В предыдущих уроках вы использовали контейнеры стандартной библиотеки. Даже в основе вспомогательного класса PtrVector лежал контейнер vector. Теперь у вас достаточно знаний, чтобы с нуля создать первый собственный контейнер — односвязный список. Это позволит разобраться в том, как устроены связные структуры данных.
Односвязный список еще называют линейным однонаправленным списком. Эта структура данных состоит из элементов одного типа. Их логически связывают между собой указатели. Каждый элемент списка указывает на следующий, а последний — на nullptr. Хранятся элементы списка, как правило, в динамической памяти.

Каждый элемент односвязного списка ссылается на следующий элемент
Структура односвязного списка такова, что передвигаться по его элементам можно только в прямом направлении. Узнать адрес предыдущего элемента, опираясь лишь на содержимое текущего элемента, невозможно.
Односвязный список допускает следующие операции:
вставка элемента в начало или конец списка,
вставка элемента после некоторого элемента списка,
удаление элемента, следующего за данным элементом списка,
проверка списка на пустоту,
определение количества элементов в списке.
Достоинства односвязного списка:
вставка и удаление элемента выполняются за константное время, то есть не зависят от количества элементов и позиции вставляемого или удаляемого элемента;
размер списка ограничен лишь объемом доступной памяти.
Недостатки односвязного списка следуют из особенностей его структуры:
Узнать адрес элемента по его порядковому номеру — операция линейной сложности. Чтобы определить адрес N-го элемента списка, нужно последовательно перебрать все N-1 элементов, начиная с первого элемента.
Неэффективное расходование памяти: помимо данных, каждый элемент списка хранит указатель на следующий элемент. Кроме того, при каждом создании объекта в динамической памяти пара десятков байт расходуется на поддержание структуры кучи.
Не такая высокая эффективность вставки и удаления. Каждая вставка и каждое удаление обращаются к операциям работы с кучей: new или delete. Считается, что эти операции работают за константное время, однако константа может быть достаточно большой. При этом выполняется сложный код синхронизации между потоками, и могут быть задействованы низкоуровневые механизмы работы с памятью.
Соседние элементы списка могут располагаться в памяти непоследовательно, что снижает эффективность работы кэш-памяти.
Тем не менее односвязный список — одна из базовых связанных структур данных. Понять, как он работает, — значит сделать первый шаг к разработке более сложных структур. В стандартной библиотеке односвязный список представлен шаблоном класса forward_list. Вам предстоит разработать его аналог — SingleLinkedList, то есть односвязный список.
Контейнер способен хранить данные произвольного типа, поэтому соответствующий класс следует объявить шаблонным:
template <typename Type>
class SingleLinkedList {
    ...
};
Элемент списка называется «узел». Элемент списка можно представить в виде структуры Node, которая содержит значение элемента и указатель на следующий узел. Можно сделать структуру Node шаблонной, а можно просто поместить её внутрь шаблонного класса SingleLinkedList. В этом случае полное имя SingleLinkedList<Type>::Node будет содержать информацию о типе значения, которое хранится в узле:
template <typename Type>
class SingleLinkedList {
    // Узел списка
    struct Node {
        Node() = default;
        Node(const Type& val, Node* next)
            : value(val)
            , next_node(next) {
        }
        Type value;
        Node* next_node = nullptr;
    };
    ...
};
Каждый узел списка знает, где находится следующий за ним элемент, а информацией о местоположении первого узла владеет сам класс списка. Так класс списка может управлять своим содержимым — достаточно знать адрес первого элемента, чтобы добраться до всех остальных.
В простейшем случае списку, чтобы управлять своими элементами, достаточно хранить указатель на первый элемент.

Список содержит указатель на первый элемент
Если представить список так, для его хранения потребуется минимум памяти в области стека — всего четыре или восемь байт в зависимости от размера указателя. Все остальные данные хранятся в области кучи. Но у такого способа есть недостаток — узнать количество элементов в списке можно, только пройдясь по всем его элементам.
Чтобы время вычисления длины списка не зависело от количества его элементов, можно пожертвовать четырьмя или восемью байтами и добавить в список дополнительное поле, которое хранило бы размер списка.

Чтобы не тратить время на подсчёт элементов списка, в него добавили поле size_
Пользовательский код не должен иметь возможности обратиться к узлам односвязного списка, так как:
Пользовательский код может случайно модифицировать структуру данных односвязного списка и нарушить её целостность. Это чревато сбоями в работе программы или утечками памяти.
Прямой доступ к элементам списка усложняет обход его элементов и вынуждает пользователей применять указатели.
Изменения в реализации списка или его узлов могут повлиять на работоспособность пользовательского кода.
Поэтому для доступа к элементам стандартных контейнеров применяют вспомогательные объекты — итераторы, которые:
«Знают» о внутреннем устройстве контейнера и умеют перемещаться с одного элемента на другой.
Скрывают служебные данные от пользовательского кода и предоставляют простой интерфейс. Используя его, можно обращаться к значениям элементов списка и к следующему элементу.
Играют роль указателей на элементы контейнера в операциях вставки и удаления элементов.
Служат посредниками между контейнерами и алгоритмами, благодаря чему один и тот же алгоритм можно использовать с разными контейнерами.
Итератор односвязного списка хранит указатель на текущий узел. Этих данных достаточно, чтобы иметь доступ к значению узла и перемещаться к следующему узлу.

Итератор хранит указатель на узел списка
Операции вставки и удаления элемента из односвязного списка требуют указателя на элемент, предшествующий позиции вставки/удаления. В этих операциях такой объект используется как опорный. Поэтому помимо знакомых вам итераторов begin и end, присущих другим контейнерам, односвязному списку нужен итератор before_begin. Данный итератор ссылается на позицию перед первым элементом:

Итераторы before_begin, begin и end
Итератор, хранящий позицию before_begin, обычно ссылается на фиктивный узел списка. Этот узел можно создать при инициализации списка и использовать лишь для хранения указателя на первый «настоящий» элемент и никогда — для хранения данных. Поэтому его можно хранить не только в куче, но и в самом списке, вместо указателя на первый элемент.

Узлы, на которые ссылаются итераторы begin, before_begin и end
template <typename Type>
class SingleLinkedList {
    struct Node { ... };
private:
    Node head_;
    size_t size_;
};
Далее вы примените теорию на практике и шаг за шагом реализуете односвязный список. Начнем с пустого списка.
Вставка элементов и очистка списка
В предыдущем уроке вы познакомились с новой структурой данных — односвязным списком и создали каркас шаблонного класса SingleLinkedList, который реализует функциональность пустого списка. В этом уроке вы научитесь динамически добавлять элементы в начало и очищать список.
Вставка элемента в начало списка
Пусть дан список, где уже есть несколько элементов {5, 42, 8}.

Односвязный список с элементами {5, 42, 8}
Поле next_node фиктивного узла head_ хранит указатель на первый элемент списка. В случае пустого списка head_.next_node равен nullptr:

В пустом списке указатель head_.next_node равен nullptr
Чтобы вставить новый элемент в начало списка, нужно создать новый узел. Следующим элементом этого узла будет текущий первый элемент списка, то есть значение head_.next_node:

Чтобы вставить значение 17 в начало списка {5, 42, 8}, создадим новый узел, который ссылается на первый узел списка
Этот узел должен стать новым первым узлом списка. Обновим указатель head_.next_node и увеличим размер списка на единицу:

Вставленный узел становится первым узлом списка. Размер списка увеличивается
Очистка односвязного списка
Рассмотрим алгоритм очистки на примере односвязного списка {5, 42, 8}.

Односвязный список с элементами {5, 42, 8}
Процесс очистки продолжается, пока список непустой — то есть указатель head_.next_node на первый элемент списка ненулевой. После первой итерации head_.next_node будет ссылаться на второй элемент со значением 42 по адресу head_.next_node->next_node, а первый элемент со значением 5 удаляется:

Голова списка ссылается на его второй элемент, а первый элемент удаляется
На следующих итерациях происходит то же самое. Указатель head_.next_node смещается на второй элемент списка {42, 8}, а первый элемент удаляется:

Голова списка ссылается на значение 8, а значение 42 удаляется
Когда в списке останется один элемент, его удаление приведёт к тому, что head_.next_node будет ссылаться на nullptr:

Удаляется последний элемент списка. Голова указывает на значение nullptr
На этом процесс очистки списка заканчивается. Остаётся обнулить размер списка. Получится пустой список:

Покоряем итераторы
Ваш односвязный список содержит методы IsEmpty и GetSize, которые позволяют узнать о наличии и количестве элементов, а также методы PushFront и Clear для вставки элемента и очистки списка. Но полноценная работа со списками предполагает не только возможность помещать внутрь него элементы, но и проходить по элементам списка.
Стандартные контейнеры вводят концепцию итератора — специального объекта, который играет роль указателя на элемент контейнера. Используем пару итераторов, чтобы задать подлежащий обходу диапазон [начало, конец) элементов контейнера.

Итераторы begin, before_begin и end и узлы, на которые они указывают
Итераторы и полуинтервалы — абстракции, которые прячут особенности внутреннего устройства конкретного контейнера за унифицированным интерфейсом. Итераторы разных контейнеров похожи: они предоставляют операции * и -> для доступа к элементам, операции ++ и -- для обхода элементов в прямом и обратном направлении. Благодаря этой унификации и шаблонам один алгоритм способен обрабатывать содержимое различных контейнеров. Создавать под каждый отдельную версию алгоритма не нужно.
В этом уроке вы реализуете поддержку обхода элементов для класса SingleLinkedList, совместимую со стандартной библиотекой и циклом range-based for.
Как устроен итератор односвязного списка
Чтобы класс или структура с точки зрения стандартных алгоритмов считались итератором, внутри должны быть объявлены вложенные типы:
iterator_category. Задает категорию итератора. Категория итератора сообщает стандартной библиотеке о наборе операций, поддерживаемых итератором. Так как односвязный список поддерживает перебор элементов только в прямом направлении, его категория итератора должна быть равна std::forward_iterator_tag.
value_type. Задает тип элементов, доступ к которым предоставляет итератор. В случае односвязного списка этот тип совпадает с параметром Type шаблона SingleLinkedList.
difference_type. Задает тип для хранения смещения между двумя итераторами. Используется в таких функциях, как std::advance и std::distance. Для SingleLinkedList можно использовать тип std::ptrdiff_t. Это целое число со знаком, разрядность которого совпадает с разрядностью указателя на целевой платформе.
pointer. Задает тип указателя, возвращаемого операцией ->. Для неконстантного итератора SingleLinkedList это Type*, а для константного — const Type*.
reference. Задает тип ссылки, которую возвращает операция разыменования *. В зависимости от константности итератора SingleLinkedList это либо Type&, либо const Type&.
#include <cstddef>
#include <iterator> // Содержит объявления категорий итераторов
template <typename Type>
class SingleLinkedList {
    // Шаблон класса «Базовый Итератор»
    // определяет поведение итератора на элементы односвязного списка
    // ValueType — совпадает с Type (для Iterator) либо с const Type (для ConstIterator)
    template <typename ValueType>
    class BasicIterator {
    public:
        using iterator_category = std::forward_iterator_tag;
        using value_type = Type;
        using difference_type = std::ptrdiff_t;
        using pointer = ValueType*;
        using reference = ValueType&;
        ...
    };
    ...
};
Константный итератор подобен указателю на константу. Он предоставляет доступ к элементам контейнера только для чтения, при этом значение самого итератора можно менять. Стандартные контейнеры имеют константную и не константную версии методов begin и end, которые возвращают константный и неконстантный итераторы соответственно.
Итератор категории std::forward_iterator_tag соответствует категории однонаправленного итератора. В нём должны быть объявлены следующие операции:
Операции == и !=. Итераторы одного и того же списка равны, если указывают на одну и ту же позицию. Константные и неконстантные итераторы одного и того же списка можно сравнивать друг с другом.
Операция инкремента ++. Перемещает итератор на следующую позицию в списке.
Операции * и -> для доступа к элементу списка. Возвращают ссылку и указатель на значение, хранящееся в списке, а не на весь узел списка, задаваемый вложенной структурой Node. Помните, итераторы должны скрывать внутреннее устройство контейнера от внешнего мира.
template <typename Type>
class SingleLinkedList {
    template <typename ValueType>
    class BasicIterator {
    public:
        ...
        [[nodiscard]] bool operator==(const BasicIterator<const Type>& rhs) const noexcept {...}
        [[nodiscard]] bool operator!=(const BasicIterator<const Type>& rhs) const noexcept {...}
        [[nodiscard]] bool operator==(const BasicIterator<Type>& rhs) const noexcept {...}
        [[nodiscard]] bool operator!=(const BasicIterator<Type>& rhs) const noexcept {...}

        BasicIterator& operator++() noexcept {...}
        BasicIterator operator++(int) noexcept {...}

        [[nodiscard]] reference operator*() const noexcept {...}
        [[nodiscard]] pointer operator->() const noexcept {...}
    ...
    };
    ...
};
Чтобы использовать == и != для сравнения константных и неконстантных итераторов, нужно объявить две версии этих операций.
Обратите внимание на перегрузку операции инкремента. Вспомним, что в C++ есть префиксная и постфиксная формы операции инкремента и декремента.
Префиксная версия модифицирует объект и возвращает ссылку на текущий экземпляр класса.
Постфиксная версия модифицирует объект и возвращает копию прежнего значения объекта.
Постфиксная форма операций инкремента и декремента принимает фиктивный параметр типа int, который не используется и только подсказывает компилятору, какая версия переопределена. Как правило, постфиксная форма основывается на функционале префиксной:
class MyType {
public:
    // Перегрузка префиксной формы
    MyType& operator++() {
        /* изменяем текущий объект */
        return *this;
    }
    // Перегрузка постфиксной формы
    MyType operator++(int) {
        auto old_value(*this); // Сохраняем прежнее значение объекта для последующего возврата
        ++(*this); // используем логику префиксной формы инкремента
        return old_value;
    }
    ...
};
Во внутреннем представлении итератор односвязного списка хранит указатель на узел списка. В операциях * и -> этот указатель разыменовывать, а после инкремента итератора ссылается на следующий узел списка.
Чтобы защитить внутреннюю структуру списка от доступа извне, создавать итератор, ссылающийся на позицию внутри списка, можно только внутри SingleLinkedList. Для этого в конструктор итератора передается указатель на приватную структуру Node.
Приватные члены класса доступны внутри него. Так, например, BasicIterator находится внутри класса SingleLinkedList, поэтому итератору доступны все приватные члены SingleLinkedList, в том числе Node. Но наоборот это не работает: SingleLinkedList находится не внутри, а снаружи BasicIterator. Списку доступ к приватным членам итератора закрыт.
Но некоторым операциям списка может понадобиться доступ к указателю на узел внутри итератора. В C++ класс или структура могут объявить о своем безграничном доверии другому классу, структуре или функции, назвав их дружественными. Для этого применяют ключевое слово friend. Класс открывает друзьям доступ к своей приватной области.
Пользуйтесь этой возможностью осторожно: неаккуратная работа с приватными полями класса способна нарушить целостность состояния объекта. Например, после изменения приватной части класса программист может забыть внести нужные правки в логику работы его друзей. Вероятность этой ситуации повышается, если класс и его друзья находятся в разных файлах. В лучшем случае код не скомпилируется, а в худшем — скомпилируется, но ошибка долго останется незамеченной.
По умолчанию класс SingleLinkedList не имеет доступа к приватной области своего итератора. Объявив список своим другом, итератор разрешит ему, и только ему обращаться к своей внутренней части. В данном случае такое доверие обоснованно, так как и список, и итератор работают с одной и той же структурой данных, скрытой от внешнего мира:
template <typename Type>
class SingleLinkedList {
    template <typename ValueType>
    class BasicIterator {
       ...
    private:
        // Разрешаем SingleLinkedList обращаться к приватной области
        friend class SingleLinkedList;
        explicit BasicIterator(Node* node) {...}
        Node* node_ = nullptr;
    };

public:
    using Iterator = BasicIterator<Type>;
    using ConstIterator = BasicIterator<const Type>;

    [[nodiscard]] Iterator begin() noexcept {
        // Благодаря дружбе SingleLinkedList имеет доступ к приватному конструктору своего итератора
        return Iterator{head_.next_node};
    }
    ...
};
Дружба — это чудо!＊
＊Отношение дружбы — самая сильная связь в C++. Гибкие и надежные архитектуры строятся из компонентов, минимально осведомленных об устройстве друг друга. Классу редко следует открывать внешнему коду доступ к своей приватной области. Контейнер и его итератор — один из случаев, когда это может быть оправдано.
Компилятор интерпретирует конструкцию friend во время настройки класса SingleLinkedList на конкретный тип. Имя SingleLinkedList в этот момент — сокращение для SingleLinkedList<Type>, и дружба будет применяться только к этой специализации. Если вы хотите подружить класс со всеми возможными специализациями шаблонного класса, то саму конструкцию friend можно сделать шаблонной:
#include <utility>
class Alibaba;
// Разбойник — это объект шаблонного класса
// Разбойники разных специализаций имеют разные шаблонные параметры
template <typename LootType>
class Thief {
public:
    void GreetAlibaba(Alibaba& alibaba);

    LootType ConvertMoneyToLoot(int money);

private:
    LootType loot_;
};

class Alibaba {
    // Али-Баба дружит с разбойниками всех специализаций
    // Конструкцию friend делаем шаблонной
    template <typename T>
    friend class Thief;

private:
    int money_ = 100;
};

template <typename T>
void Thief<T>::GreetAlibaba(Alibaba& alibaba) {
    int stolen = 0;
    // Благодаря дружбе с Али-Бабой разбойник получил доступ к 
    // его приватному полю и обнулил это поле
    std::swap(stolen, alibaba.money_);
    loot_ += ConvertMoneyToLoot(stolen);
}
Поддержка обхода элементов
Как и многое в C++, проход по элементам циклом range-based for — не привилегия, доступная лишь стандартным контейнерам. Поддержку этого цикла можно добавить любому классу, включив в него публичные методы begin и end. Они возвращают STL-совместимые итераторы, задающие диапазон элементов контейнера:
template <typename Type>
class SingleLinkedList {
public:
    [[nodiscard]] Iterator begin() noexcept {...}
    [[nodiscard]] Iterator end() noexcept {...}
    // Константные версии begin/end для обхода списка без возможности модификации его элементов
    [[nodiscard]] ConstIterator begin() const noexcept {...}
    [[nodiscard]] ConstIterator end() const noexcept {...}
    // Методы для удобного получения константных итераторов у неконстантного контейнера
    [[nodiscard]] ConstIterator cbegin() const noexcept {...}
    [[nodiscard]] ConstIterator cend() const noexcept {...}
    ...
};

int main() {
    SingleLinkedList<int> list;
    ...
    // Благодаря методам begin и end SingleLinkedList поддерживает range-based for
    for (int& item : list) {
        *item *= 2;
    }
}
Сравнение, копирование и присваивание
В прошлом уроке вы реализовали поддержку STL-совместимых итераторов. Теперь можно обходить элементы списка и проводить над ними различные манипуляции. В частности, вам стал доступен широкий спектр стандартных алгоритмов, принимающих прямые и входные итераторы. Например, std::find:
int main() {
    using namespace std;
    SingleLinkedList<int> numbers;
    ...
    if (const auto it = std::find(numbers.cbegin(), numbers.cend(), 42); it != numbers.cend()) {
        cout << "The list contains 42"s << endl;
    } else {
        cout << "The list doesn't contain 42"s << endl;
    }
}
Сравнение списков
Содержимое стандартных контейнеров, таких как vector, можно сравнивать, используя операции ==, !=, >=, <=, >, <, когда эти операции определены для их элементов.
Два контейнера одного типа считаются равными, когда их размеры равны и в них содержатся равные элементы. Теперь, когда список поддерживает итераторы, реализовать операцию == можно, применив алгоритм std::equal.
Операция < возвращает true, когда левый список лексикографически предшествует правому списку. Её можно реализовать, используя алгоритм std::lexicographical_compare. Например, список {1, 2, 3} лексикографически предшествует спискам {1, 2, 4}, {1, 3} и {1, 2, 3, 1}.
Остальные операции можем реализовать на основе == и <. Например, выражение list1 > list2 эквивалентно list2 < list1, а list1 <= list2 — противоположно list2 < list1.
Обмен содержимого списков
У многих классов стандартной библиотеки есть метод swap, обменивающий состояние объекта с другим объектом того же типа без выбрасывания исключений. Функция swap лежит в основе идиомы copy-and-swap и помогает писать код, устойчивый к исключениям. Когда разработаете метод swap в классе SingleLinkedList, вам станет проще реализовать надёжное конструирование, копирование и присваивание односвязных списков.
Реализовать метод swap довольно просто. Элементы списка хранятся в динамической памяти, а сам список хранит лишь адрес своего первого элемента и размер. Чтобы обменять содержимое двух списков, надо обменять размеры списков и указатели на первые элементы.

Процесс обмена содержимого списков
Такой обмен не требует выделения динамической памяти и не выбрасывает исключений.
Для удобства реализуем шаблонную функцию swap, использующую метод swap. Она позволит без лишнего копирования и выбрасывания исключений обменивать содержимое двух списков, как это делает std::swap. Для каждого из стандартных контейнеров есть специализированная версия функции swap, основанная на вызове метода swap соответствующего контейнера:
template <typename Type>
class SingleLinkedList {
public:
    void swap(SingleLinkedList& other) noexcept {...}
    ...
};

template <typename Type>
void swap(SingleLinkedList<Type>& lhs, SingleLinkedList<Type>& rhs) noexcept {
    lhs.swap(rhs);
}

int main() {
    SingleLinkedList<int> list_1;
    SingleLinkedList<int> list_2;
    ...
    swap(list_1, list_2);
}
Декларация шаблонной функции должна быть доступна при её настройке, поэтому шаблонные функции нужно размещать в h-файле. Если вам заранее известен перечень всех возможных специализаций, тело функции можно разместить в cpp-файле, явно указывая, какие специализации потребуются.
Создание списка из std::initializer_list
Стандартные контейнеры поддерживают свою инициализацию путём передачи набора элементов напрямую в конструктор:
#include <cassert>
#include <vector>
using namespace std;
int main() {
    vector<int> numbers{10, 20, 30, 40, 50};
    assert(numbers.size() == 5u);
    assert(numbers[2] == 30);
}
Это не какая-нибудь магия, доступная только классам стандартной библиотеки. Компилятор, встречая список элементов внутри фигурных скобок, конструирует экземпляр класса std::initializer_list. Применив этот легковесный шаблонный класс, можно получить доступ к созданному списку элементов. Один из конструкторов класса vector принимает параметр типа initializer_list и конструирует вектор, содержащий копию элементов переданного списка. Подобный конструктор есть и у других классов стандартной библиотеки.
initializer_list имеет методы size, begin и end. Они позволяют узнать его размер и перебрать элементы списка инициализации:
#include <initializer_list>
#include <cassert>
int main() {
    std::initializer_list<int> items = {2, 3, 4};
    
    assert(items.size() == 3);
    
    int sum = 0;
    for (auto item : items) {
        sum += item;
    }
    assert(sum == 9);
    
    auto it = items.begin();
    int product = 1;
    while (it != items.end()) {
        product *= *it;
        ++it;
    }
    assert(product == 24);
}
Добавим классу SingleLinkedList конструктор, принимающий initializer_list, и сможем совместить инициализацию списка с наполнением его элементами.

initializer_list и список, который из него сконструирован
template <typename Type>
class SingleLinkedList {
public:
    SingleLinkedList(std::initializer_list<Type> values) {...}
    ...
};

int main() {
    SingleLinkedList<int> list{1, 2, 3, 4};
    assert(list.GetSize() == 4);
    assert(*list.begin() == 1);
}
initializer_list принимают по значению, так как это легковесный объект. При его копировании не происходит глубокое копирование элементов.
Копирование списка
Как вы наверняка догадались, сгенерированный компилятором конструктор копирования для класса SingleLinkedList не подойдёт. Копия будет использовать те же узлы, что и оригинальный список, и при разрушении одного из списков указатель на первый узел второго списка станет невалидным, что приведёт к неопределённому поведению. Точь-в-точь как у осьминогов со сросшимися щупальцами. А это значит, что для односвязного списка нужен пользовательский конструктор копирования, который создаст копию элементов исходного списка.
Конструктор копирования важно сделать безопасным к возникновению исключений — их выбрасывание во время работы не должно приводить к утечкам памяти и неопределенному поведению. Ещё следует помнить, что при выбрасывании исключения во время конструирования объекта деструктор создаваемого объекта вызван не будет.
Один из самых простых способов сделать надежный конструктор копирования — применить идиому copy-and-swap:
Создать внутри конструктора копирования временный односвязный список и последовательно скопировать внутрь него элементы исходного списка. Если на этом этапе будет выброшено исключение, деструктор временного списка освободит память от его элементов.
Когда временный список будет содержать копию исходного списка, останется использовать метод swap и обменять состояние текущего экземпляра класса и временного списка.
template <typename Type>
class SingleLinkedList {
public:
    SingleLinkedList(const SingleLinkedList& other) {
        // Сначала надо удостовериться, что текущий список пуст
        assert(size_ == 0 && head_.next_node == nullptr);

        SingleLinkedList tmp;
        
        /* скопировать внутрь tmp элементы other */

        // После того как элементы скопированы, обмениваем данные текущего списка и tmp
        swap(tmp);
        // Теперь tmp пуст, а текущий список содержит копию элементов other
    }
    ...
};
Чтобы написать надёжный код на C++, используйте идиому RAII. С ней код будет ещё и более простым, так как своевременный вызов деструктора обеспечивается компилятором.
Вы встречались с этой идиомой ранее, когда писали профилировщик. Идиома RAII заключается в том, что время жизни ресурса неразрывно связывается со временем жизни объекта — в конструкторе происходит получение ресурса, а в деструкторе — освобождение.
Здесь владение элементами списка временно поручается локальной переменной tmp. Так копируемые элементы списка будут находиться под управлением этой переменной, пока не совершится операция обмена.
Вы ещё вернётесь к подробному изучению идиомы RAII в будущих спринтах, а пока можете ознакомиться с ней здесь: https://en.cppreference.com/w/cpp/language/raii
При конструировании односвязного списка на основе initializer_list также пригодится идиома copy-and-swap.
Присваивание списка
Операцию присваивания, последнюю из «Правила трёх», можно легко и надежно реализовать, применив идиому copy-and-swap:
Проверьте, не выполняется ли присваивание списка самому себе, сравнив адреса левого и правого аргументов операции присваивания.
Сконструируйте временную копию правого аргумента. Выбрасывание исключения на этом этапе никак не повлияет на состояние текущего объекта (левый аргумент операции присваивания).
Используйте метод swap, чтобы обменять содержимое временной копии и текущего объекта. Операция swap исключений не выбрасывает и выполняется быстро. Временная копия будет содержать предыдущее значение левого аргумента, а текущий экземпляр — копию правого аргумента операции присваивания.
При выходе из операции = временный объект будет разрушен, освободив память от предыдущего содержимого списка.
Вставка и удаление в произвольной позиции
В прошлом уроке вы реализовали операции над списком в целом: сравнение, присваивание, обмен содержимым. На практике часто возникает потребность в точечной модификации списка: вставка и удаление элементов из произвольной позиции списка. В этом уроке вы разработаете эти операции.
Вставка элемента в произвольную позицию списка
Вспомним структуру односвязного списка. Его элементы хранятся в узлах, последовательно связанных друг с другом. Эти узлы представлены структурой Node, которая хранит значение элемента и указатель на следующий узел.
Итак, чтобы вставить новый узел, нужно иметь доступ к узлу, который предшествует позиции вставки. Проблема возникнет при вставке в начало: полноценного предшествующего узла в этом случае не будет. Тут пригодится фиктивный узел head_, который расположен «‎перед первым элементом»‎. Чтобы получить итератор на него, используем методы before_begin и cbefore_begin:
template <typename Type>
class SingleLinkedList {
public:
    [[nodiscard]] Iterator before_begin() noexcept;
    [[nodiscard]] ConstIterator cbefore_begin() const noexcept;
    [[nodiscard]] ConstIterator before_begin() const noexcept;
    ...
};

Список из трёх элементов и итераторы begin, before_begin, end
Вот алгоритм вставки значения X после узла N:
Создаём новый узел со значением X.
С нового узла ссылаемся на N.next_node.
С N ссылаемся на новый узел.

Вставка числа 50 после элемента 20 в список с элементами 10, 20, 30, 40. pos показывает позицию вставки, а  p — возвращаемый итератор
После вставки нужно увеличить размер списка и вернуть итератор, который ссылается на вновь созданный узел. Возвращаемый итератор можем использовать, например, для вставки следующего элемента:
int main() {
    SingleLinkedList<int> list;
    auto pos = list.InsertAfter(list.cbefore_begin(), 1);
    pos = list.InsertAfter(pos, 2);
    list.InsertAfter(pos, 3);
    // Список содержит {1, 2, 3}
}
При вставке нужно выделить динамическую память и скопировать вставляемое значение. Это может привести к выбрасыванию исключения. Чтобы метод InsertAfter обеспечивал строгую гарантию безопасности исключений, примените подход, использованный в методе PushFront, — сначала создайте узел в динамической памяти, а потом обновите связи между узлами и размер списка.
Удаление элемента из начала списка
Обозначим первый узел как N и опишем процесс его удаления:
указатель фиктивного элемента начинает указывать на N.next_node,
узел N удаляется.
Эта операция выполняется за время O(1). Она не требует динамического выделения памяти, поэтому не выбрасывает исключений. Если, конечно, их не выбрасывает деструктор типа Type.

Процесс удаления первого узла из списка с элементами 10, 20, 30, 40
К пустому списку операцию удаления первого элемента применить нельзя.
Удаление элемента в произвольной позиции
Чтобы удалить элемент в произвольной позиции односвязного списка, нужен доступ к узлу, который предшествует удаляемому элементу. После удаления указатель с предшествующего узла будет ссылаться на узел, следующий за удаляемым. Эта операция не требует доступа к другим узлам односвязного списка.
Такая операция не выбрасывает исключений, потому что не требует динамического выделения памяти. Операция delete, вызываемая, чтобы удалить узел списка, тоже не выбрасывает исключений. Исключения могут возникнуть, если их выбросит деструктор типа Type, но это нетипичная ситуация — лучше никогда не выбрасывать исключений в деструкторах.

Удаление элемента 30 из списка с элементами 10, 20, 30, 40. Итератор pos обозначает удаляемый узел, а p — узел, следующий за удаленным
Метод EraseAfter возвращает итератор, который ссылается на элемент, следующий за удаленным, либо на end, если произошло удаление последнего элемента списка. Возвращаемый итератор можно использовать для обработки следующих элементов.
Работаем с массивами
Представьте, что вы с друзьями решили сходить в кино, и каждый из вас независимо от других купил билет на сайте кинотеатра. Придя на сеанс вы, скорее всего, обнаружите, что сидите не все вместе, а как повезёт. В тёмном зале единственный способ найти ваших друзей — это знать, на каких местах они сидят.
Так как даже тупой карандаш лучше острой памяти, вы решаете записать места друг друга до входа в зал. На беду у всех разрядились телефоны, но у каждого из вас есть небольшой лист бумаги, вмещающий информацию только об одном месте. Поэтому все кроме одного записывают ряд и номер места кого-нибудь из друзей так, чтобы не было повторов.

Пример расположения зрителей в зале
Оставим за скобками культурный аспект передвижения по залу во время сеанса и подумаем. Если вы хотите найти своего k-го друга, придётся дойти до первого человека, записанного на вашем листе бумаги, узнать у него номер места следующего и двигаться так до тех пор, пока не пройдете k человек.
Очевидно, что чем больше компания, тем больше в среднем вы будете затрачивать времени, чтобы дойти до нужного друга.
Эта аналогия описывает процесс доступа к элементу односвязного списка по его порядковому номеру. Каждый узел односвязного списка может быть в произвольном месте динамической памяти. Поэтому для связи между ними приходится хранить указатель на следующий узел списка. Чтобы добраться до i-го элемента, нужно последовательно передвигаться с начала списка, пока не пройдете i - 1 предыдущих элементов.
Знакомьтесь, массивы
Наилучшим решением было бы всем сразу купить билеты на соседние места на одном ряду.

Когда зрители сидят в одном ряду, найти нужного человека проще
В этом случае каждому человеку достаточно знать, где находится его кресло относительно кресла с наименьшим номером. Ваше кресло — третье слева, если считать с нуля. Значит, чтобы дойти до Даши, которая сидит на пятом, нужно перейти на два кресла вправо. Листочки бумаги уже не понадобятся — всё упрощается, когда купленные места расположены последовательно.
Структура данных, где все элементы имеют одинаковый размер и хранятся в непрерывной области памяти один за другим, называется массивом. Доступ к элементу массива осуществляется по его индексу.
Зная адрес begin начала массива и размер item_size одного элемента, легко вычислить адрес k-го элемента: addr(k) = begin + item_size * k



Массив из 10 элементов размером 4 байта каждый
На иллюстрации показан массив из десяти элементов, каждый из которых занимает в памяти четыре байта. Элемент с индексом 7 располагается по адресу:
0x0000000000400004 + 7*4 = 0x0000000000400004 + 0x1c = 0x0000000000400020
Такая структура данных используется контейнером vector.  Чтобы узнать адрес любого элемента массива, достаточно одного сложения с умножением.
Работа с массивами доступна не только классу vector. Самый простой способ создать массив — объявить переменную и указать после её имени размер массива в квадратных скобках. Этот массив располагается в автоматической или статической области памяти, в зависимости от места своего объявления:
// Массив из 10 int-ов со статическим временем жизни
int global_array[10];
int main() {
    // Массив из 5 int-ов с автоматическим временем жизни
    int numbers[5];

    numbers[2] = 3;
}
Размер массива в статической или автоматической области памяти должен быть константой времени компиляции. Компилятору нужно знать размер кадра стека функции, которая использует массивы.
Увеличить или уменьшить размер такого массива нельзя — сколько в нём было элементов при объявлении, столько останется до окончания его времени жизни. Операций копирования и присваивания для массивов тоже нет.
Эти ограничения связаны с тем, что C++ унаследовал массивы от своего предшественника, языка C. Их и называют C-массивы.
Когда работаете с массивами переменного размера в C++, выбирайте контейнер vector. Для хранения небольших массивов фиксированного размера в области стека можно использовать контейнер std::array. Это удобная обёртка над C-массивом. В следующем спринте вы познакомитесь с std::array ближе.
В этом уроке узнаете, какие возможности С++ предоставляет для низкоуровневой работы с массивами в динамической памяти. Это поможет понять, как устроены контейнеры, подобные vector.
Массивы в динамической памяти
Для создания массива в динамической памяти служит специальная форма операции new — new Тип[размер]. В отличие от массива на стеке или в статической области памяти, размер массива в куче может быть произвольным значением, а не константой. Оператор new[] возвращает указатель на первый элемент созданного массива:
size_t size;
cin >> size;
// Создаёт в куче массив из size элементов
int* numbers = new int[size];
Элементы созданного так массива инициализируются конструктором по умолчанию для заданного типа. Для примитивных типов вроде int и double элементы не будут проинициализированы. Чтобы выполнить инициализацию элементов, укажите их значения внутри фигурных скобок:
// Создаёт в куче массив {0, 0, 0}
int* all_zeros = new int[3]{};

// Создаёт в куче массив {1, 2, 3, 4, 5}
int* five_numbers = new int[]{1, 2, 3, 4, 5};

// Создаёт в куче массив {1, 2, 3, 4, 5, 0, 0}
int* seven_numbers = new int[7]{1, 2, 3, 4, 5};

// Создаёт в куче пустой массив из нуля элементов
int* empty_array = new int[0];

// Создаёт в куче единичный int, равный 42
int* single_int = new int{42};
Когда закончите работать с массивом в динамической памяти, удалите его, используя операцию delete[]. Эта операция вызывает деструкторы у всех элементов массива и освобождает память.
int* numbers = new int[10];
...
delete[] numbers;
Квадратные скобки [] нужны, чтобы отличать удаление массива объектов от удаления одиночного объекта.
Среда выполнения может использовать различающиеся форматы хранения одиночных объектов и массивов в динамической памяти. Например, помимо самих элементов массива в динамической памяти может храниться его размер, а для одиночных объектов эта информация избыточна. Создатели C++ поставили во главу производительность и возложили на программиста ответственность за выбор между delete и delete[]. Использование непарной версии операции delete, например delete без квадратных скобок после new int[10], приведет к неопределенному поведению.
Связь указателей и массивов, адресная арифметика
Итак, у вас есть указатель, ссылающийся на первый элемент массива. Обратиться к остальным элементам массива вы можете, используя операцию []:
int* my_array = new int[10];
// Следующие две строки делают одно и то же
my_array[0] = 1;
*my_array = 1;

my_array[3] = my_array[2];

delete[] my_array;
Аналогичные действия можно выполнять с указателем, ссылающимся на любой элемент массива, в том числе по отрицательному индексу. В этом случае к элементу массива можно обратиться как по его абсолютному индексу в массиве, так и по смещению относительно другого элемента с известным адресом.

Схема массива из 10-ти элементов. Под ячейками указаны индексы, а над ними — смещения относительно 4-го элемента
int* my_array = new int[10]{};
int* p = &my_array[4];  // указатель на элемент с индексом 4
p[-1] = 42;  // запись в элемент с индексом 3 (3 = 4 - 1)
p[3] = 128;  // запись в элемент массива с индексом 7 (7 = 4 + 3)
// В этом месте массив содержит следующие элементы:
// 0, 0, 0, 42, 0, 0, 0, 128, 0, 0
delete[] my_array;

Имя массива может выступать в роли указателя на его начальный элемент:
int numbers[3];
int* item0_ptr = numbers; // в item0_ptr хранится указатель на начальный элемент массива
assert(item0_ptr == &numbers[0]);
Обращаться к элементам за пределами массива для чтения или записи нельзя — будет неопределённое поведение. При этом неважно, в динамической, автоматической или статической памяти располагался массив:
int* numbers = new int[10];
int* item4_ptr = &numbers[4];

numbers[10] = 0; // неопределённое поведение - выход за пределы массива
numbers[-1] = 0; // неопределённое поведение - выход за пределы массива
item4_ptr[6] = 0; // неопределённое поведение - обращение к элементу массива с индексом 10

delete numbers;  // неопределённое поведение - использование delete вместо delete[]

string names[2];
names[5] = "Ivan"s; // неопределённое поведение - выход за пределы массива
Можно взять адрес ячейки памяти, следующей за последним элементом массива. Разыменовывать этот указатель нельзя, но можно использовать в качестве опорного указателя для доступа к существующим элементам массива.

int* my_array = new int[10];
// Разрешается взятие адреса элемента, следующего за последним:
int* end = &my_array[10];

// Следующие две строки делают одно и то же
end[-1] = 43;
my_array[9] = 43;
assert(&end[-1] == &my_array[9]);
delete[] my_array;
Указатели на элементы массива и целые числа можем использовать в выражениях адресной арифметики, которая включает в себя следующие операции:
разность указателей,
сумма указателя и числа,
разность указателя и числа,
инкремент и декремент указателя,
сравнение указателей.
Если p — указатель на некоторый элемент массива, то:
p+1 — указатель на следующий за ним элемент массива;
p-1 — указатель на предыдущий элемент массива;
p+N — указатель на N-й элемент массива относительно p;
++p выполняет инкремент указателя p, после чего он будет указывать на следующий элемент массива;
--p выполняет декремент указателя p.
Если p и q — указатели на некоторые элементы одного и того же массива, то:
p - q равно количеству элементов после q, которое необходимо добавить, чтобы получить p;
p < q истинно, если p ссылается на элемент массива, предшествующий q;
p == q истинно, если p и q ссылаются на один и тот же элемент массива.

Указатели как итераторы по элементам массивов
Благодаря перегрузке операций итераторы стандартных контейнеров предоставляют множество операций или его часть, в зависимости от контейнера. Этим множеством обладают указатели:
Операция разыменования * указателя возвращает ссылку на объект. Итератор возвращает ссылку на значение элемента контейнера;
Операции инкремента и декремента указателя перемещают его на следующий и предыдущий элементы массива. Инкремент и декремент итератора перемещают его к следующему или предыдущему элементу контейнера;
Операции адресной арифметики над указателями выполняют перемещение вперед или назад за константное время. Аналогичные действия возможны и над итераторами произвольного доступа контейнера vector и deque.
Благодаря сходству интерфейсов указателей и итераторов стандартные алгоритмы С++ можно применять к элементам контейнера и массивов в памяти. Разница между итераторами и указателями — в толщине слоя абстракции от «железа». Операции с указателями выполняются максимально быстро, но ограничены использованием в массивах. Итераторы в этом плане более интеллектуальны, но менее быстры за счет накладных расходов при обходе более сложных структур данных контейнеров. Исключение могут составить разве что итераторы контейнера vector, для которых современные компиляторы способны сгенерировать код, аналогичный используемому указатели.
Объявив массив в статической или автоматической памяти, можно использовать функции std::begin и std::end и получить итераторы на его начало и конец:
#include <algorithm>
int main() {
    using namespace std;

    int numbers[] = {1, 2, 4, 8, 1, 6, 3, 2, 6, 4};
    sort(begin(numbers), end(numbers));
}
Адрес начала данных контейнера vector предоставляет метод data. Возвращенный им указатель задаёт полуинтервал [data(); data() + size()). Внутри этого полуинтервала содержатся элементы контейнера vector. Как правило, метод data() используют для передачи содержимого vector в функции ОС или в низкоуровневые библиотеки:
#include <vector>
struct Point {
    int x;
    int y;
};
// Функция DrawPolygon рисует многоугольник, состоящий из num_points вершин,
// расположенных в массиве по адресу points.
void DrawPolygon(const Point* points, size_t num_points){
    /* ... */
}
int main() {
    using namespace std;
    vector<Point> polygon;
    int num_vertices = 7;
    for (int i = 0; i < num_vertices; ++i) {
        Point vertex;
        /* Вычисляем координаты очередной вершины многоугольника */
        polygon.push_back(vertex);
    }
    // Передаем адрес массива вершин и их количество в функцию рисования многоугольника
    DrawPolygon(polygon.data(), polygon.size());
    const Point triangle_vertices[3] = {{100, 100}, {0, 0}, {200, 0}};
    // DrawPolygon может использоваться и с обычными массивами.
    // Например, для рисования треугольника
    DrawPolygon(triangle_vertices, 3);
}
Создаём RAII-обертку над массивом в динамической памяти
Когда в повседневной работе вам нужен массив, динамически изменяющие свои размеры, выбирайте vector. Это производительный и надёжный контейнер, подходящий для решения большинства прикладных задач.
Но в рамках курса вы намеренно будете отступать от этого правила и заново изобретать велосипед, чтобы узнать о внутреннем устройстве привычных инструментов и лучше понимать их достоинства и недостатки.
В этом уроке вы начнете создавать аналог контейнера vector и сделаете умный указатель для управления массивом в динамической памяти.
Вы уже создавали умный указатель ScopedPtr, упрощающий работу с объектами в динамической памяти.
Можно ли использовать ScopedPtr для управления массивом объектов в динамической памяти?
Деструктор ScopedPtr воспользуется операцией delete вместо delete[], что приведет к неопределенному поведению. Кроме того, у ScopedPtr нет оператора [] для доступа к элементам массива.

Итак, ScopedPtr не подходит для управления массивом. Поэтому рассмотрим особенности, которыми должен обладать новый умный указатель ArrayPtr.
Как и в случае обычного указателя, способного ссылаться на nullptr или на существующий массив, конструкторы ArrayPtr предлагают различные способы создать умный указатель:
template <typename Type>
class ArrayPtr {
public:
    // Инициализирует ArrayPtr значением nullptr
    ArrayPtr() noexcept {...}

    // Инициализирует ArrayPtr значением переданного указателя raw_ptr
    explicit ArrayPtr(Type* raw_ptr) noexcept {...}
    
    // Создаёт в динамической памяти массив из size элементов и инициализирует ArrayPtr его адресом
    explicit ArrayPtr(size_t size) {...}
};
Внутри ArrayPtr должен содержаться сырой указатель, хранящий адрес нулевого элемента массива в динамической памяти. При разрушении ArrayPtr должно происходить удаление массива в куче при помощи delete[].
template <typename Type>
class ArrayPtr {
public:
    ~ArrayPtr() {
        // Удалить массив, адрес которого содержится в поле raw_ptr_
    }
    ...
private:
    Type* raw_ptr_;  // указатель на массив в динамической памяти 
};
Чтобы ArrayPtr мог предоставлять доступ к элементам массива по их индексу, подобно обычным массивами и vector, перегрузим операцию [].
Операция [] принимает один аргумент и перегружается как член класса или структуры. Как правило она возвращает ссылку на соответствующий элемент контейнера. Последующие операции над возвращённой ссылкой, например, присваивание, модифицируют значение элемента:
vector<int> v;
...
// Сначала v[3] вернёт ссылку на третий элемент,
// а затем оператор присваивания изменит значение этого элемента
v[3] = 5;
Часто перегружают две версии операции [] — константную и не константную. Константная версия оператора возвращает константную ссылку на элемент. Благодаря этому можно защитить содержимое контейнера от модификации — модифицировать значение константы нельзя.
Бывают исключения: в контейнере map есть только неконстантная версия операции [].  Если элемента с указанным ключом нет, она вставляет ключ со значением по умолчанию.
Для контейнера ArrayPtr перегруз им обе версии []:
template <typename Type>
class ArrayPtr {
public:
    Type& operator[](size_t index) noexcept { ... }
    const Type& operator[](size_t index) const noexcept { ... }
    ...
};
Чтобы доступ по индексу был максимально быстрым, операции объявлены noexcept. ArrayPtr не хранит размер массива, поэтому следить за корректностью передаваемых индексов должен программист.
Запретив конструктор копирования и операцию присваивания, мы упростим класс, а метод Release позволит передавать этот указатель на массив из одной области видимости в другую без копирования элементов. Метод swap эффективно обменяет значения двух объектов ArrayPtr. Это пригодится при использовании знакомой вам идиомы copy-and-swap:
template <typename Type>
class ArrayPtr {
public:
    ArrayPtr(const ArrayPtr&) = delete;
    ArrayPtr& operator=(const ArrayPtr&) = delete;
    Type* Release() noexcept { ... }
    void swap(const ArrayPtr& other) noexcept { ... }
    ...
};
