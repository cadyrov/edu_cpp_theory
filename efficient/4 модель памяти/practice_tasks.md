# Практические задания по модели памяти C++

## Задание 1: Реализация безопасного умного указателя

**Описание:** Создайте класс `SafePtr<T>`, который автоматически управляет памятью и предотвращает утечки.

**Задача:** Реализовать умный указатель с подсчетом ссылок, аналогичный `shared_ptr`.

**Тесты:**
1. Создание указателя: `SafePtr<int> ptr(new int(42))` → успешно
2. Копирование указателя: `SafePtr<int> ptr2 = ptr1` → счетчик ссылок = 2
3. Разыменование: `*ptr` → 42
4. Доступ к методам: `ptr->method()` → корректный вызов
5. Присваивание nullptr: `ptr = nullptr` → корректное обнуление
6. Автоматическое удаление при выходе из области видимости
7. Проверка на nullptr: `if (ptr)` → корректная проверка
8. Получение сырого указателя: `ptr.get()` → корректный адрес
9. Сброс указателя: `ptr.reset()` → обнуление и уменьшение счетчика
10. Подсчет ссылок: `ptr.use_count()` → корректное количество

## Задание 2: Анализ выравнивания структур

**Описание:** Создайте программу для анализа размеров и выравнивания различных структур.

**Задача:** Написать функцию, которая выводит информацию о размере и выравнивании структур.

**Тесты:**
1. Простая структура: `struct { char a; int b; }` → размер и выравнивание
2. Структура с double: `struct { char a; double b; }` → анализ padding
3. Упакованная структура: `#pragma pack(1)` → сравнение размеров
4. Структура с массивом: `struct { char arr[10]; int x; }` → выравнивание
5. Пустая структура: `struct {}` → размер 1 байт
6. Структура с битовыми полями: анализ размера
7. Наследование: размер базового и производного классов
8. Виртуальные функции: влияние на размер
9. Выравнивание с alignas: принудительное выравнивание
10. Сравнение с union: размер объединения

## Задание 3: Реализация менеджера памяти

**Описание:** Создайте простой менеджер памяти с пулом объектов фиксированного размера.

**Задача:** Реализовать класс `MemoryPool<T>` для быстрого выделения и освобождения памяти.

**Тесты:**
1. Создание пула: `MemoryPool<int> pool(100)` → успешная инициализация
2. Выделение памяти: `pool.allocate()` → корректный указатель
3. Освобождение памяти: `pool.deallocate(ptr)` → успешное освобождение
4. Исчерпание пула: выделение больше доступного → обработка ошибки
5. Повторное использование: освобождение и выделение → тот же адрес
6. Выравнивание: корректное выравнивание для типа T
7. Деструктор пула: автоматическая очистка всей памяти
8. Статистика: количество выделенных/свободных блоков
9. Проверка валидности: является ли указатель из пула
10. Сброс пула: освобождение всех блоков

## Задание 4: Реализация copy-and-swap идиомы

**Описание:** Создайте класс, который корректно реализует копирование и присваивание с использованием copy-and-swap.

**Задача:** Реализовать класс `Resource`, управляющий динамическим массивом.

**Тесты:**
1. Конструктор: `Resource r(10)` → создание массива размером 10
2. Конструктор копирования: `Resource r2(r1)` → глубокое копирование
3. Оператор присваивания: `r2 = r1` → корректное присваивание
4. Самоприсваивание: `r = r` → безопасное выполнение
5. Исключения при копировании: обработка bad_alloc
6. Перемещающий конструктор: `Resource r2(std::move(r1))` → перемещение
7. Перемещающее присваивание: `r2 = std::move(r1)` → перемещение
8. Метод swap: `r1.swap(r2)` → обмен без исключений
9. Доступ к элементам: `r[i]` → корректный доступ
10. Изменение размера: `r.resize(20)` → изменение с сохранением данных

## Задание 5: Детектор утечек памяти

**Описание:** Создайте простой детектор утечек памяти, который отслеживает вызовы new/delete.

**Задача:** Реализовать систему отслеживания выделений памяти.

**Тесты:**
1. Отслеживание new: каждый вызов new регистрируется
2. Отслеживание delete: каждый вызов delete регистрируется
3. Обнаружение утечек: незакрытые new выводятся в отчет
4. Двойное удаление: обнаружение повторного delete
5. Статистика: общее количество выделений/освобождений
6. Размер утечек: общий размер неосвобожденной памяти
7. Трассировка: вывод места выделения памяти
8. Фильтрация: исключение системных выделений
9. Отчет в деструкторе: автоматический вывод при завершении
10. Сброс статистики: очистка всех счетчиков

## Задание 6: Реализация placement new

**Описание:** Создайте класс, который использует placement new для размещения объектов в предварительно выделенной памяти.

**Задача:** Реализовать контейнер с фиксированной емкостью без использования стандартных контейнеров.

**Тесты:**
1. Выделение буфера: создание aligned_storage для объектов
2. Конструирование объекта: использование placement new
3. Разрушение объекта: явный вызов деструктора
4. Добавление элементов: `container.emplace_back(args...)` → создание на месте
5. Удаление элементов: `container.pop_back()` → корректное разрушение
6. Доступ к элементам: `container[i]` → корректный доступ
7. Итераторы: `begin()` и `end()` → корректная итерация
8. Переполнение: обработка превышения емкости
9. Исключения: безопасность при исключениях в конструкторе
10. Очистка: `clear()` → разрушение всех объектов

## Задание 7: Анализ времени жизни объектов

**Описание:** Создайте программу для демонстрации различных времен жизни объектов.

**Задача:** Реализовать класс `LifetimeTracker`, который отслеживает создание и разрушение объектов.

**Тесты:**
1. Локальные переменные: создание и разрушение в блоке
2. Статические переменные: создание при первом использовании
3. Глобальные переменные: создание до main, разрушение после
4. Динамические объекты: создание new, разрушение delete
5. Временные объекты: создание и немедленное разрушение
6. Исключения: разрушение при stack unwinding
7. Порядок разрушения: локальные переменные в обратном порядке
8. Статические в функции: разрушение в обратном порядке создания
9. Глобальные в разных единицах трансляции: неопределенный порядок
10. RAII: автоматическое управление ресурсами

## Задание 8: Реализация кастомного аллокатора

**Описание:** Создайте собственный аллокатор для использования со стандартными контейнерами.

**Задача:** Реализовать аллокатор, который выделяет память блоками фиксированного размера.

**Тесты:**
1. Создание аллокатора: `BlockAllocator<int> alloc(1024)` → инициализация
2. Выделение памяти: `alloc.allocate(n)` → корректный указатель
3. Освобождение памяти: `alloc.deallocate(ptr, n)` → освобождение
4. Использование с vector: `std::vector<int, BlockAllocator<int>>` → работа
5. Использование с map: корректная работа с ассоциативными контейнерами
6. Выравнивание: корректное выравнивание для разных типов
7. Исчерпание блока: выделение нового блока при необходимости
8. Статистика: отслеживание использования памяти
9. Копирование аллокатора: корректное поведение при копировании
10. Освобождение всех блоков: автоматическая очистка в деструкторе

## Задание 9: Реализация RAII для файлов

**Описание:** Создайте RAII-обертку для работы с файлами, которая автоматически закрывает файл.

**Задача:** Реализовать класс `FileHandle`, который безопасно работает с файлами.

**Тесты:**
1. Открытие файла: `FileHandle fh("test.txt", "r")` → успешное открытие
2. Автоматическое закрытие: выход из области видимости → файл закрыт
3. Проверка валидности: `fh.is_open()` → корректная проверка
4. Чтение данных: `fh.read(buffer, size)` → корректное чтение
5. Запись данных: `fh.write(data, size)` → корректная запись
6. Перемещение: `FileHandle fh2 = std::move(fh1)` → передача владения
7. Запрет копирования: попытка копирования → ошибка компиляции
8. Исключения: безопасность при исключениях в конструкторе
9. Получение FILE*: `fh.get()` → сырой указатель для C API
10. Явное закрытие: `fh.close()` → принудительное закрытие

## Задание 10: Анализ производительности аллокаций

**Описание:** Создайте программу для измерения производительности различных способов выделения памяти.

**Задача:** Сравнить производительность malloc/free, new/delete, и пулов памяти.

**Тесты:**
1. Бенчмарк malloc/free: измерение времени для множественных аллокаций
2. Бенчмарк new/delete: сравнение с malloc/free
3. Бенчмарк пула памяти: измерение времени для пула
4. Фрагментация: влияние на производительность
5. Размер блоков: производительность для разных размеров
6. Количество аллокаций: влияние на время выполнения
7. Паттерны доступа: последовательный vs случайный
8. Многопоточность: производительность в многопоточной среде
9. Память vs время: компромиссы между скоростью и использованием памяти
10. Профилирование: анализ узких мест в выделении памяти

## Дополнительные рекомендации:

1. **Используйте современные возможности C++17**: auto, range-based for, умные указатели
2. **Обрабатывайте исключения**: особенно std::bad_alloc при работе с памятью
3. **Следуйте принципу RAII**: ресурсы должны управляться автоматически
4. **Тестируйте граничные случаи**: nullptr, пустые контейнеры, исчерпание памяти
5. **Используйте инструменты**: valgrind, AddressSanitizer для поиска ошибок
6. **Документируйте код**: особенно требования к времени жизни объектов
7. **Избегайте сырых указателей**: используйте умные указатели где возможно
8. **Проверяйте выравнивание**: особенно при работе с низкоуровневой памятью 