# Тест по модели памяти C++

## Вопрос 1
Что такое выравнивание (alignment) в контексте модели памяти C++?
a) Размер объекта в байтах
b) Степень двойки, определяющая допустимые адреса размещения объекта
c) Время жизни объекта
d) Способ инициализации объекта

## Вопрос 2
Какой результат выведет следующий код?
```cpp
struct Test {
    char a;
    int b;
    char c;
};
std::cout << sizeof(Test) << std::endl;
```
a) 6
b) 8
c) 12
d) 16

## Вопрос 3
Что произойдет при выполнении этого кода?
```cpp
int* ptr = new int(42);
delete ptr;
*ptr = 10;
```
a) Программа выведет 10
b) Программа выведет 42
c) Неопределенное поведение
d) Программа завершится с ошибкой компиляции

## Вопрос 4
Какая область памяти используется для хранения локальных переменных?
a) Куча (heap)
b) Стек (stack)
c) Статическая память
d) Регистры процессора

## Вопрос 5
Что делает операция `alignof(T)`?
a) Возвращает размер типа T
b) Возвращает требования к выравниванию типа T
c) Выравнивает объект типа T в памяти
d) Создает объект типа T с правильным выравниванием

## Вопрос 6
Какой из следующих указателей является константным указателем на константу?
a) `const int* ptr`
b) `int* const ptr`
c) `const int* const ptr`
d) `int const* ptr`

## Вопрос 7
Что произойдет при выполнении этого кода?
```cpp
int* p = nullptr;
delete p;
```
a) Неопределенное поведение
b) Программа завершится с ошибкой
c) Ничего не произойдет
d) Будет выброшено исключение

## Вопрос 8
Какое время жизни у глобальных переменных?
a) Автоматическое
b) Динамическое
c) Статическое
d) Временное

## Вопрос 9
Что делает следующий код?
```cpp
int value = 42;
int& ref = value;
int* ptr = &ref;
```
a) Создает указатель на ссылку
b) Создает указатель на переменную value
c) Приводит к ошибке компиляции
d) Создает копию переменной value

## Вопрос 10
Какой размер будет у указателя на 64-битной системе?
a) 4 байта
b) 8 байт
c) 16 байт
d) Зависит от типа, на который указывает

## Вопрос 11
Что такое утечка памяти?
a) Когда программа использует больше памяти, чем доступно
b) Когда выделенная память не освобождается
c) Когда указатель указывает на неверный адрес
d) Когда происходит переполнение стека

## Вопрос 12
Какой результат выведет этот код?
```cpp
struct A {
    A() { std::cout << "A"; }
    ~A() { std::cout << "~A"; }
};

void func() {
    A a;
}

int main() {
    func();
    std::cout << "main";
}
```
a) A~Amain
b) A~A
c) Amain~A
d) main~A

## Вопрос 13
Что произойдет при двойном удалении объекта?
```cpp
int* ptr = new int(42);
delete ptr;
delete ptr;
```
a) Программа выведет предупреждение
b) Неопределенное поведение
c) Программа завершится корректно
d) Будет выброшено исключение std::bad_alloc

## Вопрос 14
Какая операция используется для получения адреса объекта?
a) *
b) &
c) ->
d) ::

## Вопрос 15
Что делает операция `sizeof`?
a) Возвращает количество элементов в массиве
b) Возвращает размер типа или объекта в байтах
c) Возвращает адрес объекта
d) Возвращает время жизни объекта

## Вопрос 16
Какой из следующих способов создания объекта размещает его в куче?
a) `int x = 42;`
b) `int* x = new int(42);`
c) `static int x = 42;`
d) `const int x = 42;`

## Вопрос 17
Что произойдет при выполнении этого кода?
```cpp
class Test {
public:
    Test() { std::cout << "Constructor"; }
    ~Test() { std::cout << "Destructor"; }
};

int main() {
    Test* t = new Test();
    return 0;
}
```
a) Constructor
b) ConstructorDestructor
c) Destructor
d) Ничего не выведется

## Вопрос 18
Какое значение будет у неинициализированной локальной переменной?
a) 0
b) nullptr
c) Неопределенное значение
d) Значение по умолчанию для типа

## Вопрос 19
Что делает следующий код?
```cpp
int* ptr = new int[10];
delete ptr;
```
a) Корректно удаляет массив
b) Приводит к неопределенному поведению
c) Удаляет только первый элемент
d) Приводит к ошибке компиляции

## Вопрос 20
Какой оператор используется для разыменования указателя?
a) &
b) *
c) ->
d) .

## Вопрос 21
Что произойдет при выполнении этого кода?
```cpp
void func() {
    int arr[1000000];
    func();
}

int main() {
    func();
}
```
a) Программа выведет результат
b) Переполнение стека
c) Утечка памяти
d) Программа завершится корректно

## Вопрос 22
Какой тип имеет `nullptr`?
a) `void*`
b) `int*`
c) `nullptr_t`
d) `null`

## Вопрос 23
Что делает операция `new`?
a) Только выделяет память
b) Только вызывает конструктор
c) Выделяет память и вызывает конструктор
d) Только возвращает указатель

## Вопрос 24
Какой результат выведет этот код?
```cpp
int x = 10;
int* p1 = &x;
int* p2 = p1;
*p2 = 20;
std::cout << x;
```
a) 10
b) 20
c) Неопределенное значение
d) 0

## Вопрос 25
Что такое "висячий указатель" (dangling pointer)?
a) Указатель, равный nullptr
b) Указатель на удаленный объект
c) Неинициализированный указатель
d) Указатель на статическую переменную

## Вопрос 26
Какой из следующих способов безопасен для проверки указателя?
```cpp
int* ptr = getPointer();
```
a) `if (ptr) { ... }`
b) `if (ptr != nullptr) { ... }`
c) `if (ptr != 0) { ... }`
d) Все перечисленные

## Вопрос 27
Что произойдет при выполнении этого кода?
```cpp
struct Base {
    int a;
    double b;
};
struct Derived : Base {
    char c;
};
std::cout << sizeof(Derived);
```
a) 13
b) 16
c) 17
d) 24

## Вопрос 28
Какая операция используется для доступа к члену класса через указатель?
a) .
b) ->
c) ::
d) *

## Вопрос 29
Что делает следующий код?
```cpp
int* createArray() {
    int arr[10];
    return arr;
}
```
a) Возвращает корректный указатель на массив
b) Возвращает указатель на локальную переменную (неопределенное поведение)
c) Приводит к ошибке компиляции
d) Возвращает nullptr

## Вопрос 30
Какой из следующих операторов может выбросить исключение `std::bad_alloc`?
a) `delete`
b) `new`
c) `sizeof`
d) `alignof`

## Вопрос 31
Что произойдет при выполнении этого кода?
```cpp
class Test {
    int* data;
public:
    Test() : data(new int(42)) {}
    ~Test() { delete data; }
};

int main() {
    Test t1;
    Test t2 = t1;
    return 0;
}
```
a) Программа завершится корректно
b) Двойное удаление памяти
c) Утечка памяти
d) Ошибка компиляции

## Вопрос 32
Какая разница между `delete` и `delete[]`?
a) Нет разницы
b) `delete[]` используется для массивов
c) `delete` быстрее
d) `delete[]` безопаснее

## Вопрос 33
Что делает следующий код?
```cpp
int x = 10;
int* const ptr = &x;
ptr = &y;
```
a) Изменяет значение ptr
b) Приводит к ошибке компиляции
c) Изменяет значение x
d) Ничего не делает

## Вопрос 34
Какой результат выведет этот код?
```cpp
int* ptr = new int(42);
int* ptr2 = ptr;
delete ptr;
ptr = nullptr;
std::cout << *ptr2;
```
a) 42
b) 0
c) Неопределенное поведение
d) Программа не скомпилируется

## Вопрос 35
Что такое RAII?
a) Техника управления ресурсами
b) Способ выделения памяти
c) Тип указателя
d) Алгоритм сортировки

## Вопрос 36
Какой из следующих классов является умным указателем в C++11/14/17?
a) `auto_ptr`
b) `unique_ptr`
c) `raw_ptr`
d) `safe_ptr`

## Вопрос 37
Что произойдет при выполнении этого кода?
```cpp
std::unique_ptr<int> ptr1 = std::make_unique<int>(42);
std::unique_ptr<int> ptr2 = ptr1;
```
a) Программа завершится корректно
b) Ошибка компиляции
c) Два указателя будут владеть одним объектом
d) Утечка памяти

## Вопрос 38
Какой оператор используется для перемещения ресурса?
a) `std::copy`
b) `std::move`
c) `std::swap`
d) `std::forward`

## Вопрос 39
Что делает `std::make_shared`?
a) Создает shared_ptr
b) Создает unique_ptr
c) Копирует объект
d) Перемещает объект

## Вопрос 40
Какой из следующих способов предпочтительнее для создания объекта в динамической памяти?
a) `new int(42)`
b) `std::make_unique<int>(42)`
c) `malloc(sizeof(int))`
d) `std::make_shared<int>(42)` 