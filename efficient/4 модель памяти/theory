Хранение объектов в памяти
C++ — язык программирования высокого уровня, позволяющий создавать программы для разных программно-аппаратных платформ — от микроконтроллеров и мобильных телефонов до суперкомпьютеров.
Архитектурные различия между этими платформами значительны: набор инструкций процессора, устройство памяти, организация ввода-вывода с внешними устройствами. Компилятор берет на себя заботу о том, как преобразовать программу в машинный код для целевой платформы, а стандартная библиотека предоставляет надежные компоненты, подходящие для решения повседневных задач.
Сильная сторона C++ в том, что, когда стандартные решения не подходят, язык даёт вам возможность «спуститься» на более низкий уровень, ближе к железу, чтобы оптимально распорядиться ресурсами компьютера.
Модель памяти C++
Один из таких ресурсов — память, которая используется для хранения кода программы и обработки ее данных. Чтобы код на C++ мог выполняться на разных программно-аппаратных платформах, язык предоставляет программисту модель памяти — абстракцию, скрывающую особенности работы с памятью на конкретной платформе.
С точки зрения C++ память компьютера состоит из одной или нескольких непрерывных последовательностей ячеек. Эти ячейки называются байтами.
Байт — минимальная адресуемая единица памяти. В большинстве современных компьютеров каждый байт состоит из восьми двоичных разрядов, называемых битами, что позволяет ему принимать 2^8=256 различных значений. Каждый байт в памяти имеет уникальный адрес — числовое значение, задающее его местоположение в памяти.



Схематичное представление памяти программы. В ячейке с адресом 0x400018 находится байт со значением 42. Значения остальных ячеек памяти для примера не важны, поэтому на рисунке их нет
Префикс 0x говорит о том, что целое число записано в шестнадцатеричной системе счисления. Эта система счисления часто используется для записи адресов, так как «круглые» числа в ней — это степени числа 16, которые также можно представить как степени двойки.
Объекты в памяти
Программы на C++ не манипулируют содержимым ячеек памяти напрямую. Вместо этого они работают с объектами — создают, разрушают их, считывают и модифицируют состояние объектов. В данной теме под термином «объект» будем по умолчанию подразумевать понятие не из объектно-ориентированного программирования, а более абстрактное. Объектом в C++ называется регион в памяти, который обладает такими свойствами:
Размер в байтах. Типы char, unsigned char, int8_t, uint8_t и std::byte занимают ровно один байт памяти, а другие типы могут требовать несколько байтов. Например, значение типа int в программах, компилируемых для 32-разрядных процессоров, может занимать в памяти четыре байта, а для 16-разрядных — два. Узнать, сколько байтов занимает тип или переменная, позволяет операция sizeof.
Требования к выравниванию в памяти. Выравнивание — степень двойки, число, равное количеству байтов между адресами, по которым могут размещаться объекты данного типа. Операция alignof возвращает значение выравнивания для заданного типа на целевой платформе. В общем случае оно может отличаться от размера объекта, возвращаемого sizeof как в меньшую, так и в большую сторону.
Тип. Позволяет программе правильно работать с областью памяти, которую объект занимает. Например, несмотря на то, что размеры типов float и int могут совпадать, для работы с ними компилятор генерирует различающийся машинный код.
Значение, которое определяется содержимым области памяти, занимаемой объектом. Значение может быть неопределенным — например, при объявлении неинициализированной локальной переменной примитивного типа данных, такого как int или char.
Продолжительность времени жизни. Например, время жизни локальных переменных ограничено блоком, внутри которого они объявлены, а глобальных переменных — продолжительностью работы программы.
Опциональное имя. Имя позволяет обращаться к объекту в программе. Простейший пример — имя переменной. Имя может отсутствовать у временного объекта, который создают как промежуточный результат вычислений. Один объект может быть доступен по нескольким именам. Так, например, ссылка создаст ещё одно имя для уже существующего объекта.
На рисунке ниже — четыре объекта в памяти программы: переменная p типа Point, целое число age, переменная weight типа double и неинициализированная переменная year типа int16_t. Ссылка на объект p позволяет обратиться к нему по альтернативному имени p_ref.



Пример расположения объектов различных типов в памяти. Ссылка p_ref указывает на объект переменной p
Каждый из этих объектов имеет представление в памяти, специфичное для некоторой платформы. Компилятор отвечает за корректное чтение и запись значений объектов в память.
Следующая программа выводит размеры и величину выравнивания для некоторых стандартных и пользовательских типов на целевой платформе:
#include <cstddef>  // cstddef необходим для использования std::byte
#include <cstdint>  // cstdint необходим для использования uint32_t и int64_t
#include <iostream>
using namespace std;
struct Sportsman {
    int id;
    double height;
};
int main() {
    cout << "char: size="s << sizeof(char) << ", alignment="s << alignof(char) << endl;
    cout << "int: size="s << sizeof(int) << ", alignment="s << alignof(int) << endl;
    cout << "double: size="s << sizeof(double) << ", alignment="s << alignof(double) << endl;
    cout << "Sportsman: size="s << sizeof(Sportsman) << ", alignment="s << alignof(Sportsman) << endl;
    return 0;
}
На разных платформах размеры и требования к выравниванию данных могут отличаться. Например, скомпилированная для 64-разрядной ОС Windows программа выводит следующие значения:
char: size=1, alignment=1
int: size=4, alignment=4
double: size=8, alignment=8
Sportsman: size=16, alignment=8
Размер структуры Sportsman получился больше суммарного размера её полей — компилятор добавил пустое пространство внутри структуры, чтобы её поля располагались по выровненным адресам, а размер структуры был кратен величине ее выравнивания.
Сколько объектов создаётся внутри функции main этой программы?
int main() {
    int x = 0;
    double n = 5;
    int& r = x;
}
Объявление переменных x и n создаёт новые объекты. Ссылка r этого не делает, она лишь альтернативный способ доступа к значению переменной x.
Модель памяти — абстракция. C++ вводит её, чтобы описать действия оперативной памяти без привязки к конкретной программно-аппаратной платформе.
Данные, с которыми работает программа, представляются в виде объектов — областей памяти компьютера. У этих областей есть тип, значение, размер и требования к выравниванию.
Указатели. Открываем доступ к памяти
В прошлом уроке вы узнали об устройстве памяти компьютера и о том, как в ней представляются объекты, с которыми работает ваша программа. Сегодня познакомитесь с указателями — средством языка, открывающим доступ к памяти компьютера.
Указатель — переменная, которая хранит адрес объекта в памяти программы. Это как лист бумаги с адресом. Зная адрес своего друга, вы можете его навестить. Точно так же можно обратиться к объекту при наличии указателя на него.
Указатели объявляются подобно обычным переменным, только с использованием символа «звездочка» * после типа. Например, так выглядит указатель, способный хранить адрес объекта типа int:
int* p;
Переменная p может хранить адрес целого числа. Так как переменная-указатель p не инициализирована, использовать ее для доступа к объекту нельзя. Объявление указателя выделяет память для хранения адреса, но не инициализирует эту область памяти.
Размер указателей равен размеру адреса на конкретной платформе и не зависит от размера самих объектов. Рассмотрим пример:
#include <iostream>
#include <map>
#include <string>

struct Vector3D {
    double x;
    double y;
    double z;
};

int main() {
    using namespace std;

    map<string, string>* string_to_string;
    cout << "char*: size:"s << sizeof(char*) << endl;
    cout << "int*: size:"s << sizeof(int*) << endl;
    cout << "double*: size:"s << sizeof(double*) << endl;
    cout << "Vector3D*: size:"s << sizeof(Vector3D*) << endl;
    cout << "map<string, string>*: size:"s << sizeof(string_to_string) << endl;
}
Типичный размер и выравнивание указателя на 32-битной платформе равны четырем байтам, а на 64-разрядной — восьми. Вывод программы на 64-битной платформе:
char*: size:8
int*: size:8
double*: size:8
Vector3D*: size:8
map<string, string>*: size:8
Вывод программы на 32-битной платформе:
char*: size:4
int*: size:4
double*: size:4
Vector3D*: size:4
map<string, string>*: size:4
Инициализация указателя и получение адреса объекта
Чтобы использовать указатель, нужно присвоить ему адрес существующего объекта. Для получения адреса есть специальная унарная операция — &. Её называют операцией взятия адреса. Она применяется к объекту, адрес которого вы хотите получить, и возвращает адрес этого объекта:
int value = 42;
// Указатель value_ptr ещё не инициализирован
int* value_ptr;

// Теперь в value_ptr хранится адрес переменной value
value_ptr = &value;
Если присвоить указателю value_ptr результат выражения &value, указатель будет содержать адрес ячейки памяти, где располагается переменная value.

Так можно представить в памяти переменную value и указатель value_ptr. Адреса ячеек памяти приведены для примера.
Указателю можно присвоить только адрес объекта совместимого типа. Так, присвоить адрес переменной типа double указателю на тип int нельзя:
int int_value = 42;
double double_value = 1.2345;
int* ptr;
// Следующая строка не скомпилируется,
// так как по адресу &double_value располагается объект типа double
ptr = &double_value; // error: cannot convert 'double*' to 'int*' in assignment
Объявление указателя лучше объединить с его инициализацией — так запись короче, и неинициализированных указателей в программе не будет:
int value = 42;
int* value_ptr = &value;
Операцию взятия адреса можно применять не только к отдельным переменным, но и к полям структур и классов:
#include <string>
using namespace std;
struct Point {
    double x;
    double y;
};

int main() {
    Point p;
    // y_ptr хранит адрес координаты Y точки p
    double* y_ptr = &p.y;
}
Указатель y_ptr имеет тип double* и ссылается на поле y точки p:

В C++ ссылки — не объекты. Они вводят новое имя для доступа к уже существующему объекту. Поэтому оператор &, примененный к ссылке, возвращает не указатель на ссылку, а указатель на сам объект:
int main() {
    int answer = 42;
    int& answer_ref = answer;
    // answer_ptr хранит адрес переменной answer
    int* answer_ptr = &answer_ref;
}
И переменная answer, и ссылка answer_ref относятся к одному и тому же объекту. Поэтому взятие адреса ссылки равнозначно взятию адреса объекта:

Указатель answer_ptr хранит адрес переменной answer. На answer также ссылается ссылка answer_ref
Вывод указателя в поток
Операция << может вывести в поток значение указателя.
#include <iostream>
#include <string>
using namespace std;
int main() {
    int value = 42;
    int* value_ptr = &value;
    cout << "value_ptr: "s << value_ptr << endl;
}
Формат вывода адреса зависит от компилятора и платформы. Примеры:
Linux для архитектуры x64, компилятор GCC:
value_ptr: 0x7ffd6596006c
Windows для архитектуры x86, компилятор Microsoft Visual C++ 2019:
value_ptr: 00EFF930
Нулевой указатель
Неинициализированный указатель содержит неопределенное значение. Использовать такой указатель для доступа к объекту нельзя, поведение программы будет неопределенным, как и значение указателя. Также нет смысла сравнивать этот указатель с другими — в общем случае отличить значение неинициализированного указателя от инициализированного невозможно.
Инициализируйте указатель при его объявлении: присвойте ему адрес существующего объекта совместимого типа или специальное значение nullptr — нулевой указатель.
Нулевой указатель хранит значение nullptr. C++ гарантирует, что по адресу nullptr не будет размещаться ни один объект программы. Поэтому перед использованием указателя вы сможете определить, есть ли в нём адрес существующего объекта. Для этого сравните указатель со значением nullptr:
#include <cassert>
#include <iostream>

int main() {
    using namespace std;

    int* p = nullptr;

    //------
    // Пример кода, который может записать в p адрес существующего объекта
    // или оставить указатель равным nullptr
    int value = 0;
    cin >> value;
    if (value >= 0) {
        p = &value;
    }
    //------

    cout << "p: "s << p << endl;

    if (p != nullptr) {
        assert(p == &value);
        cout << "p is not nullptr"s << endl;
        // Можно использовать указатель p для доступа к объекту
    }

    // Аналогично условию p != nullptr
    if (p) {
        assert(p != nullptr);

        // Можно использовать указатель p для доступа к объекту
    }

    if (!p) {
        assert(p == nullptr);
        cout << "p is nullptr"s << endl;
        // Указатель p равен nullptr. Использовать его для доступа к объекту нельзя
    }
}
Как видно из примера, условие p != nullptr можно сократить до p, а p == nullptr — до !p. Так указатели конвертируются в bool.
💡 Указатели разных типов нельзя сравнивать между собой. Исключение — указатель типа void*, который ничего не говорит о данных, расположенных по адресу, который он хранит. Также любой указатель можно сравнивать с nullptr. Это допустимо благодаря тому, что nullptr — не указатель, он имеет специальный тип — nullptr_t.
Разыменование указателя
Чтобы получить доступ к объекту в C++, используют унарную операцию разыменования указателя. Она обозначается символом *. Эта операция выполняет обратное действие. Если её применить к указателю, она вернёт ссылку на объект, адрес которого хранит указатель. Доступ к объекту посредством указателя ещё называют косвенным доступом. Рассмотрим, как указатели дают доступ к переменной:
#include <cassert>
using namespace std;
int main() {
    int value = 1;
    // Указатель value_ptr1, ссылающийся на переменную value
    int* value_ptr1 = &value;
    // Указатель value_ptr2, копия указателя value_ptr1, также ссылается на переменную value
    int* value_ptr2 = value_ptr1;
    // Значения указателей на один и тот же объект будут равны
    assert(value_ptr1 == value_ptr2);
    // Значение объекта value, полученное напрямую и через указатель на него, будет одно и то же
    assert(*value_ptr1 == value && *value_ptr2 == value);
    // Изменение value видно через указатели на него
    value = 2;
    assert(*value_ptr1 == value && *value_ptr2 == value);
    // Изменяем значение value через указатель
    *value_ptr2 = 3;

    // Ожидаемо изменённое значение будет видно как при прямом доступе к объекту по его имени,
    // так и при косвенном обращении через указатель value_ptr1
    assert(*value_ptr1 == value && *value_ptr2 == value);
}
В программе создаются переменная value и указатели value_ptr1 и value_ptr2, ссылающиеся на нее. Доступ к значению value можно получить как напрямую по имени самой переменной, так и косвенно — разыменовать любой из указателей на неё.



Значение value можно получить, разыменовав любой из указателей value_ptr1 и value_ptr2
Какое значение выведет следующая программа?
#include <iostream>
#include <string>

using namespace std;

int main() {
    int x = 10;

    int* p1 = &x;
    int* p2 = &x;

    *p1 = 20;
    cout << *p2 << endl;
}
ОТВЕТ: 20
Указатели p1 и p2 указывают на переменную x. К её значению можно обратиться, используя любой из этих указателей.
Если у вас есть указатель на объект класса или структуры, можно обратиться к его полям и методам через операцию ->. Она автоматически разыменовывает указатель:
#include <cassert>
#include <string>
int main() {
    using namespace std;
    string practicum = "Practicum"s;
    string* paracticum_ptr = &practicum;
    // Прежде чем обратиться к методу length, разыменуем указатель
    assert((*paracticum_ptr).length() == 9);
    // Также обращение к полям и методам структур и классов
    // доступно при помощи операции ->
    assert(paracticum_ptr->substr(2, 3) == "act"s);
}
Операцию разыменования * и операцию доступа к полям и методам -> можно применять только к указателям, которые хранят адрес существующего объекта в памяти. Использовать их с неинициализированным или нулевым указателем нельзя — это приведет к неопределенному поведению. Прежде чем применять указатель, который может потенциально иметь нулевое значение, сделайте проверку на равенство nullptr:
#include <cassert>
#include <iostream>
int main() {
    using namespace std;
    int* p = nullptr;
    //------
    int value = 0;
    cin >> value;
    if (value >= 0) {
        p = &value;
    }
    //------
    if (p != nullptr) {
        // Использовать p можно
        cout << *p << endl;
    }
}
В этом уроке вы познакомились с указателями — объектами, способными хранить адреса других объектов. Избегайте неинициализированных указателей. Они — источник трудно уловимых ошибок.
Указатели и константность
Переменные в C++ можно объявить константными, чтобы защитить их значения от непреднамеренной модификации. При попытке изменить константную переменную компилятор выдаст ошибку.
Указатель на константу
Свойство константности сохраняется и при взятии адреса объекта. Операция & возвращает указатель на константный объект — его ещё называют указателем на константу. Такой указатель разрешает читать значение объекта, но не модифицировать его:
#include <cassert>
int main() {
    const int value = 42;
    // Ошибка: неконстантная ссылка не может ссылаться на константный объект
    // int& value_ref = value;
    // А вот так можно
    const int& const_value_ref = value;
    // Ошибка: указатель на неконстантное значение не может хранить адрес константного объекта
    // int* value_ptr = &value;
    // Указатель на константу типа int.
    const int* const_value_ptr = &value;
    // можно также объявить как int const* - это одно и то же
    // Указатель на константу можно использовать только для чтения значения объекта
    assert(*const_value_ptr == 42);
    // Выполнить модификацию объекта с его помощью нельзя.
    // Следующая строка не скомпилируется:
    // *const_value_ptr = 43;
}
Здесь компилятор не разрешает задать указателю типа int* значение адреса константного объекта. Такой указатель позволил бы изменить состояние объекта. В этом плане указатели на константу похожи на константные ссылки.

Указатель на неизменяемое значение типа const int
Указатель на константу может хранить адрес неконстантного объекта и таким образом предоставить доступ к объекту только для чтения. В этом случае указатель на константу ведёт себя подобно константой ссылке.
Константные ссылки и указатели на константу запрещают модифицировать объект, только если вы используете именно их. Изменять значение объекта иным способом можно.
#include <cassert>

int main() {
    int value = 42;
    // Указатель на константу может хранить адрес неконстантного объекта
    const int* const_value_ptr = &value;
    // Константная ссылка может ссылаться на неконстантный объект
    const int& const_value_ref = value;
    value = 43;
    // Константные ссылки и указатели на константу означают, что
    // через них нельзя изменить значение объекта. Само значение 
    // может быть изменено иным способом.
    assert(const_value_ref == 43);
    assert(*const_value_ptr == 43);
} 
В этой программе доступ к переменной value через указатель const_value_ptr разрешается только для чтения. Саму переменную value можно изменять как обычно.

Указатель типа const int⃰ указывает на изменяемое значение типа int. Изменение через указатель невозможно
Изменение значения указателя
В отличие от ссылок, указатели могут в процессе жизни менять своё значение, храня в разные моменты времени адреса разных объектов. Простейший способ изменить значение указателя — присвоить ему адрес другого объекта:
#include <cassert>
#include <iostream>
#include <string>
using namespace std;

int main() {
    int value = 1;
    // Сначала value_ptr ссылается на value
    int* value_ptr = &value;
    cout << "&value: "s << &value << endl;
    cout << "value_ptr: "s << value_ptr << endl;
    assert(*value_ptr == 1);
    int another_value = 2;
    // Затем ссылается на another_value
    value_ptr = &another_value;
    cout << "&another_value: "s << &another_value << endl;
    cout << "value_ptr: "s << value_ptr << endl;
    assert(*value_ptr == 2);
}
Возможный вывод этой программы:
&value: 00000031D55AFC20
value_ptr: 00000031D55AFC20
&another_value: 00000031D55AFC24
value_ptr: 00000031D55AFC24
Указатель на константу сам константой не будет и может в любой момент начать ссылаться на другой объект:
#include <cassert>
#include <iostream>
#include <string>
using namespace std;

int main() {
    int value = 1;
    // Указатель на константу. Само значение указателя константным не является.
    const int* value_ptr = &value;
    assert(*value_ptr == 1);
    int another_value = 2;
    // Можно присвоить указателю адрес другого объекта.
    value_ptr = &another_value;
    assert(*value_ptr == 2);
}

Два значения типа int и указатель типа  const int⃰, указывающий на одно из них
Константные указатели
Константным может быть не только объект, на который ссылается указатель, но и сам указатель. Значение константного указателя нельзя изменить после инициализации. Чтобы объявить такой указатель, поставьте const справа от знака *. Как и обычная константа, константный указатель должен быть инициализирован при объявлении:
int value = 42;
int* const const_ptr_to_value = &value;
int another_value = 5;
// Ошибка: нельзя изменить значение константного указателя
// const_ptr_to_value = &another_value;

Неизменяемый указатель, указывающий на изменяемое значение
Константные указатели на константу
Как вы могли догадаться, константными могут быть как сам указатель, так и данные, на которые он ссылается. В этом случае разместите ключевое слово const с обеих сторон от символа *:
int value = 42;
const int* const const_ptr_to_const_value = &value;
int another_value = 5;
// Ошибка: нельзя изменить значение константного указателя:
// const_ptr_to_const_value = &another_value;
// Ошибка: нельзя изменить значение данных через указатель:
// *const_ptr_to_const_value = 0;

Неизменяемый указатель, указывающий на неизменяемое значение
📖 В типе int* слово const можно написать не в двух, а в трёх местах: const int*,  int* const и int const *. Первый и последний вариант эквивалентны — это указатели на тип const int, который допустимо записывать как int const. Мы будем пользоваться только первым вариантом, но при чтении чужого кода может встретиться и второй.
Определение типа указателя
Есть простое мнемоническое правило, которое позволяет запомнить, к чему относится const в типе указателя. Для этого прочитайте объявление указателя справа налево, заменяя символ * на слово «указатель». Например:
// p1 - это указатель на данные типа int
int* p1;
// p2 - это указатель на данные типа const int
const int* p2;

int data = 42;

// p3 - это константный указатель на данные типа int
int* const p3 = &data;

// p4 - это константный указатель на данные типа const int
const int* const p4 = &data;
const string *
vector<string> * const
const vector<string*>
map<int, const string> * const
string const *
char const * const
Статическое и автоматическое размещение объектов в памяти
Память для программ на языке C++ можно разделить на несколько независимых областей:
для объектов со статическим временем жизни;
для объектов с автоматическим временем жизни;
для объектов с динамическим временем жизни;
для объектов в локальной памяти потока. В рамках этой темы память потока рассматривать не будем.
Как правило, объекты с разным временем жизни размещаются в разных частях адресного пространства. Такой подход помогает эффективнее использовать доступную память. Вы указываете, как должен храниться объект, а компилятор и среда выполнения отвечают за его размещение в памяти.

Один из способов распределить адресное пространство программы
Области памяти для объектов с автоматическим и динамическим временем жизни «растут» навстречу друг другу, а размер области для объектов со статическим временем жизни остается постоянным.
Память для объектов со статическим временем жизни
Статическим временем жизни обладают глобальные переменные и локальные статические переменные функций. Область памяти для их хранения выделяется при старте программы и освобождается при её завершении:
#include <iostream>
using namespace std;
int value = 0;
void Fn() {
    // Глобальная переменная value существует в единственном экземпляре.
    // Адрес переменной value будет тот же, какой был получен в функции main
    cout << "Fn(): &value="s << &value << endl;
    value = 1;
}
int main() {
    cout << "main(): &value="s << &value << endl;
    cout << "value="s << value << endl;
    Fn();
    // Функция Fn изменила значение переменной value. Это изменение будет
    // видно и в функции main
    cout << "value="s << value << endl;
}
Скопируйте код в свою IDE и запустите. Возможный вывод программы:
main(): &value=00007FF68C874150
value=0
Fn(): &value=00007FF68C874150
value=1
Так как переменная value — глобальная, её адрес остаётся неизменным на протяжении всей работы программы. Любая функция может изменить значение value и повлиять тем самым на работу остальных функций, которые используют эту глобальную переменную.
Автоматическое выделение памяти для хранения объектов
Память для хранения объекта автоматически выделяется при входе в блок, где этот объект объявлен, и освобождается при выходе из блока. Такой способ выделения памяти используют локальные переменные и аргументы функций.
Стандарт C++ не оговаривает, как должно происходить автоматическое выделение памяти для локальных переменных. Распространённые компиляторы хранят локальные переменные в области памяти, где располагается стек вызовов функций.
При входе в функцию программа выделяет кадр стека — блок памяти, способный вместить все локальные переменные текущей функции. При выходе из функции этот кадр удаляется.

Кадры стека вызовов функций main→Func1→Func2
Работу автоматического выделения памяти можно увидеть на примере функции Factorial для рекурсивного вычисления факториала. При каждом вызове она выводит адрес параметра n. Параметры функции выделяются в автоматической области памяти. Так вы можете проследить адрес этой области при каждом вызове функции:
#include <iostream>
using namespace std;
// Функция для рекурсивного вычисления факториала:
// 0! = 1
// n! = n*(n-1)!
int Factorial(int n) {
    cout << "  Factorial("s << n << "): &n="s << &n << endl;
    return n > 0 ? n * Factorial(n - 1) : 1;
}
int main() {
    for (int i = 0; i < 4; ++i) {
        cout << "=== Calculating factorial of "s << i << " ==="s << endl;
        int f = Factorial(i);
        cout << "Result is: "s << f << endl << endl;
    }
}
Скопируйте код себе. Скомпилируйте и запустите его. Цифры зависят от вашего компилятора и операционной системы, поэтому могут получиться иными. Они даже могут различаться при каждом запуске. Важно просто обратить внимание на закономерности в адресах:
=== Calculating factorial of 0 ===
  Factorial(0): &n=0000005D1D0FF9B0
Result is: 1

=== Calculating factorial of 1 ===
  Factorial(1): &n=0000005D1D0FF9B0
  Factorial(0): &n=0000005D1D0FF8E0
Result is: 1

=== Calculating factorial of 2 ===
  Factorial(2): &n=0000005D1D0FF9B0
  Factorial(1): &n=0000005D1D0FF8E0
  Factorial(0): &n=0000005D1D0FF810
Result is: 2

=== Calculating factorial of 3 ===
  Factorial(3): &n=0000005D1D0FF9B0
  Factorial(2): &n=0000005D1D0FF8E0
  Factorial(1): &n=0000005D1D0FF810
  Factorial(0): &n=0000005D1D0FF740
Result is: 6
При первом входе в функцию Factorial адрес, по которому расположена переменная n, всегда один и тот же — 0000005D1D0FF9B0. С каждым следующим рекурсивным вызовом переменная n размещается по адресу, меньшему на 0xD0 — 208 в десятичной системе.
Можно сделать вывод, что размер кадра стека функции Factorial равен 208 байтам. Стек на платформе x86/x64 «растёт» сверху вниз. Этим объясняется уменьшение адреса размещения локальных переменных при вложенных вызовах функции.

Кадры стека при вычислении Factorial(2) и Factorial(3)
Дан текст программы:
int speed = 12;
int Run(int time) {
    int distance = speed * time;
    speed /= 2;
    return distance;
}
int main() {
    int distance = Run(10) + Run(10) + Run(10);
}
Чему будет равно значение переменной distance перед выходом из функции main?
210. Функция Run три раза вызывается с одним и тем же значением time. Однако скорость перемещения после каждого забега уменьшается вдвое. В результате пройденное расстояние будет равно 12∗10+6∗10+3∗10=210. Вот так глобальные переменные неочевидным образом усложняют анализ работы программы.
Что выведет в output эта программа? Введите ответ в одну строку без пробелов.
#include <iostream>
using namespace std;
struct Log {
    explicit Log(int id): id_(id) {
        cout << id_;
    }

    ~Log() {
        cout << "-" << id_;
    }
private:
    int id_;
};

void One() {
    Log local1{1};
}

void Two() {
    Log local2{2};
    One();
    Log local3{3};
}

Log global1{4};

int main() {
    Two();
}
Log global2{5};
4521-13-3-2-5-4
До выполнения функции main конструкторы глобальных переменных global1 и global2 выведут 45.
Функция main вызовет функцию Two, где конструктор переменной local2 выведет 2.
Функция Two вызовет функцию One, где конструктор переменной local1 выведет 1, а её деструктор выведет -1. Произойдёт возврат в функцию Two.
Конструктор переменной local3 внутри функции Two выведет 3. Следом деструкторы local3 и local2 выведут -3-2. Произойдёт выход в функцию main.
После выхода из main запустится процесс разрушения переменных со статическим временем жизни в порядке, обратном их конструированию в текущем .cpp файле. Сначала деструктор переменной global2 выведет -5, а затем деструктор переменной global1 выведет -4.
В этом уроке вы узнали о статическом и автоматическом размещении объектов в памяти программы. Время жизни таких объектов строго детерминировано, и за его соблюдением следит компилятор.
За простоту статического и автоматического хранения приходится платить ограниченными функциональными возможностями. Для хранения локальных переменных при каждом вызове функции выделяется кадр стека фиксированного размера. Объекты со статическим размещением существуют в программе в единственном экземпляре.
Динамическое размещение памяти позволяет программе создавать столько объектов, сколько нужно для решения задачи, а потом удалять эти объекты, когда задача решена. В следующем уроке познакомитесь с динамической памятью.
Динамическое размещение объектов в памяти
В прошлом уроке вы узнали о статическом и автоматическом размещении объектов в памяти. Этих двух способов достаточно для решения задач, где объем обрабатываемых данных известен заранее. Но сегодня такие задачи — скорее исключение, чем правило.
Часто до запуска программы неизвестно, какой объем памяти ей понадобится. В вашу поисковую систему можно добавить несколько сотен и даже тысяч документов. В ней сведения о документах содержатся в стандартных контейнерах, таких как vector, map, set. Они хранят свои элементы в куче — области, предназначенной для динамического выделения и освобождения памяти по запросу программы.
Работу с этой областью памяти легко сравнить с арендой земельных участков в утопическом государстве. Каждый житель может взять в аренду участок нужного размера и использовать по своему усмотрению — например, для выращивания пшеницы. Собрав урожай, житель возвращает участок государству, чтобы эту землю могли использовать другие. Скажем, построить на ней завод. Если страна большая, и арендаторы не забывают возвращать землю государству, все довольны.
Чтобы создать объект в куче, используют операцию new. Она выделяет в куче память нужного размера, конструирует в ней объект и возвращает указатель на него.
Удалить ненужный объект можно операцией delete. Она принимает указатель на объект, который создан операцией new, и выполняет следующие действия:
удаляет объект, вызывая его деструктор,
освобождает память — возвращает её в кучу:
int main() {
    // В куче создаётся объект типа int. Адрес этого объекта сохраняется в value_ptr.
    int* value_ptr = new int;
    // Используем созданный объект по указателю на него
    *value_ptr = 42;
    // Удаляем объект и возвращаем занимаемый им блок памяти обратно в кучу
    delete value_ptr;
}
Операции delete можно безопасно передавать указатель, равный nullptr, — в этом случае она ничего не делает. Поэтому проверка указателя на nullptr перед вызовом delete избыточна. Зато после вызова delete указатель на удаленный объект лучше обнулить, если ещё планируете использовать этот указатель:
#include <cstdlib>
#include <ctime>
#include <iostream>
using namespace std;
int main() {
    int* value_ptr = new int;
    // *value_ptr принимает случайное значение (для примера)
    srand(time(0));
    *value_ptr = rand();
    if (bool delete_now = (*value_ptr % 2) == 0;  // Этот код будет выполнен только для четных значений *value_ptr
        delete_now) {
        // Эта проверка на нулевой указатель перед вызовом delete является избыточной.
        // Оператор delete ничего не делает, если вызвать его с нулевым указателем
        if (value_ptr) {
            delete value_ptr;
            // А вот обнулить указатель после удаления объекта имеет смысл, если
            // этот указатель потенциально может еще использоваться
            value_ptr = nullptr;
        }
    }
    // Указатель мог ранее обнулиться, поэтому здесь его следует проверить
    if (value_ptr) {
        cout << *value_ptr << endl;
    }
    // Удаляем объект, на который ссылается value_ptr. 
    // Проверку на nullptr перед удалением объекта смело пропускаем
    delete value_ptr;
    // value_ptr = nullptr;
    // Обнуление указателя на удаленный объект перед выходом избыточно, если
    // этот указатель далее по коду не используется - 
    // всё равно что помыть пол в доме перед сносом.
}
Операция new позволяет передать параметры конструктору создаваемого объекта. Рассмотрим это на примере. Заодно используем класс LifetimeLogger, чтобы сравнить время жизни обычных локальных переменных и объектов в динамической памяти:
#include <iostream>
#include <string>
using namespace std;
// Уведомляет о своем создании и разрушении
class LifetimeLogger {
public:
    explicit LifetimeLogger(int id):id_(id)  // Сохраняем идентификатор
    {
        cout << "LifetimeLogger "s << id_ << " created"s << endl;
    }
    ~LifetimeLogger() {
        cout << "LifetimeLogger "s << id_ << " destroyed"s << endl;
    }
private:
    int id_;
};

int main() {
    // Создаём LifetimeLogger в куче, передавая его конструктору параметр 1
    LifetimeLogger* logger1 = new LifetimeLogger(1);

    LifetimeLogger logger2(2);

    cout << "Delete logger 1"s << endl;
    delete logger1;

    cout << "Exit main"s << endl;
}
Скомпилируем и запустим программу:
LifetimeLogger 1 created
LifetimeLogger 2 created
Delete logger 1
LifetimeLogger 1 destroyed
Exit main
LifetimeLogger 2 destroyed
Сначала в динамической памяти создаётся объект LifetimeLogger(1), а следом за ним — LifetimeLogger(2). Время жизни LifetimeLogger(1) заканчивается при выполнении операции delete: вызывается деструктор, который выводит сообщение “LifetimeLogger 1 destroyed”, и освобождается память. LifetimeLogger(2) удаляется автоматически после вывода “Exit main”.
Вы могли обратить внимание, что в этой программе не соблюдается правило «объекты уничтожаются в порядке, обратном порядку их конструирования». Это нормально, так как время жизни объектов в куче контролирует программист, а не компилятор.
Забота программиста — удалять созданные в куче объекты, когда в них нет необходимости. Память, как и любой ресурс, ограничена. Когда в куче нет свободного места для создания объекта, оператор new выбрасывает исключение std::bad_alloc. Поймав это исключение, программа может сообщить пользователю о нехватке памяти, предложить выйти из программы или сохранить данные на диск.
Рассмотрим эту ситуацию на примере маленькой, но жадной программы. Она моделирует ситуацию, когда «арендатор», получив земельный участок, «теряет» документы на него. Так как без документов вернуть участок невозможно, все государственные земли быстро станут считаться занятыми, и арендовать будет нечего. Экономика страны продемонстрирует стабильный отрицательный рост с последующей сменой политического режима:
#include <iostream>
#include <new>
#include <string>
using namespace std;
int main() {
    size_t n = 0;
    try {
        // Так создается бесконечный цикл.
        for (;;) {
            // Внимание! Эта программа ведет себя некорректно в иллюстративных целях.
            // Указатель на выделенную в куче строку никуда не сохраняется, что
            // приводит к утечке памяти.
            new string(100'000'000, ' ');
            ++n;
        }
    } catch (const bad_alloc&) {
        // Рано или поздно доступная программе память закончится,
        // и оператор new выбросит исключение bad_alloc
        cout << "bad_alloc after "s << n << " allocations"s << endl;
    }
}
Вступаем в зону экстремального обучения. Скопируйте код выше в свою IDE. Перед запуском программы сохраните данные в открытых приложениях. Во время ее работы системе будет не хватать памяти, что потенциально может негативно повлиять на работу других процессов.
Скомпилируйте и запустите программу. В зависимости от размера памяти на вашем компьютере она проработает от нескольких секунд до нескольких минут и сообщит о пойманном исключении:
bad_alloc after 206 allocations
Запустите диспетчер задач и понаблюдайте за изменением объёма памяти. Программа быстро займёт доступную физическую память и сможет проработать еще некоторое время, используя виртуальную память, которую ей выделяет операционная система. Затем программа столкнется с нехваткой памяти и закончит работу.

График использования памяти компьютера во время работы «жадной» программы
Такие ошибки программы называются «утечки памяти». Они возникают, когда:
программист не удалил объект после использования;
указателю, ссылающемуся на объект в куче, присвоили новое значение, и других указателей на этот объект нет. Объект становится недоступным из кода, хотя продолжает занимать память.
В итоге приложение исчерпает доступный лимит памяти и завершится с ошибкой. Поэтому вовремя удаляйте ненужные объекты. Особенно в программах, которые должны работать долго и бесперебойно.
Чтобы исправить программу, добавьте вызов delete у указателя на строку в динамической памяти:
#include <iostream>
#include <new>
#include <string>
using namespace std;
int main() {
    size_t n = 0;
    try {
        for (; n != 300; ++n) {
            string* p = new string(100'000'000, ' ');
            // Утечка памяти исправлена - объект в куче своевременно удаляется
            delete p;
        }
        cout << "Program completed successfully"s;
    } catch (const bad_alloc&) {
        // Сюда программа, скорее всего, не попадёт,
        // если объем свободной памяти в куче будет больше 100 мегабайт
        cout << "bad_alloc after "s << n << " allocations"s << endl;
    }
}
Запустите программу и убедитесь, что потребление памяти пришло в норму. Теперь программа использует немногим более сотни мегабайт памяти для хранения символов строки.
Вы ведущий программист в команде, разрабатывающей софт для роботов-осьминогов. Один из джуниор-разработчиков прислал вам на ревью код, моделирующий осьминога:
#include <iostream>
#include <string>
#include <vector>
using namespace std;
// Щупальце
class Tentacle {
public:
    explicit Tentacle(int id): id_(id) {}
    int GetId() const {
        return id_;
    }
private:
    int id_ = 0;
};
// Осьминог
class Octopus {
public:
    Octopus() {
        for (int i = 1; i <= 8; ++i) {
            tentacles_.push_back(new Tentacle(i));
        }
    }
private:
    vector<Tentacle*> tentacles_;
};
int main() {
    Octopus octopus;
}
Взглянув на программу, вы сразу обнаруживаете в ней несколько утечек памяти и отправляете код на доработку. Какое исправление должен сделать программист, чтобы устранить найденные вами проблемы? Выберите один верный ответ. Предлагаемые исправления заключены между комментариями:
Вариант 1
#include <iostream>
#include <string>
#include <vector>

using namespace std;

// Щупальце
class Tentacle {
public:
    explicit Tentacle(int id)
        : id_(id) {
    }

    int GetId() const {
        return id_;
    }

private:
    int id_ = 0;
};

// Осьминог
class Octopus {
public:
    Octopus() {
        // <--- Тело конструктора обновлено
        Tentacle* t = nullptr;
        try {
            for (int i = 1; i <= 8; ++i) {
                t = new Tentacle(i);
                tentacles_.push_back(t);
                t = nullptr;
            }
        } catch (const bad_alloc&) {
            Cleanup();
            delete t;
        }
        // --->
    }

    //<--- Добавлен деструктор
    ~Octopus() {
        Cleanup();
    }
    // --->

private:
    // <--- Добавлен метод Cleanup
    void Cleanup() {
        for (Tentacle* t : tentacles_) {
            delete t;
        }
        tentacles_.clear();
    }
    // --->

    vector<Tentacle*> tentacles_;
};

int main() {
    Octopus octopus;
}
Если в процессе конструирования щупалец будет выброшено исключение, обработчик catch их все удалит. Так как пойманное в конструкторе исключение не будет выброшено дальше, конструктор завершится успешно, а клиенту достанется осьминог без конечностей.
Тоже правильный ответ
Вариант 2
#include <iostream>
#include <string>
#include <vector>

using namespace std;

// Щупальце
class Tentacle {
public:
    explicit Tentacle(int id)
        : id_(id) {
    }

    int GetId() const {
        return id_;
    }

private:
    int id_ = 0;
};

// Осьминог
class Octopus {
public:
    Octopus() {
        // <--- Тело конструктора обновлено
        Tentacle* t = nullptr;
        try {
            for (int i = 1; i <= 8; ++i) {
                t = new Tentacle(i);
                tentacles_.push_back(t);
                t = nullptr;
            }
        } catch (const bad_alloc&) {
            Cleanup();
            delete t;
            throw bad_alloc();
        }
        // --->
    }

    // <--- Добавлен деструктор
    ~Octopus() {
        Cleanup();
    }
    // --->

private:
    // <--- Добавлен метод Cleanup
    void Cleanup() {
        for (Tentacle* t : tentacles_) {
            delete t;
        }
        tentacles_.clear();
    }
    // --->

    vector<Tentacle*> tentacles_;
};

int main() {
    Octopus octopus;
}
В деструкторе класса Octopus вызов метода Cleanup удаляет созданные в динамической памяти щупальца. В конструкторе Octopus исключение bad_alloc может быть выброшено как в операции new, так и в методе push_back класса vector. Обработчик исключения учитывает обе ситуации, удаляя сконструированные щупальца, а потом пробрасывает исключение дальше, чтобы отменить конструирование осьминога.
Вариант 3
#include <iostream>
#include <string>
#include <vector>

using namespace std;

// Щупальце
class Tentacle {
public:
    explicit Tentacle(int id)
        : id_(id) {
    }

    int GetId() const {
        return id_;
    }

private:
    int id_ = 0;
};

// Осьминог
class Octopus {
public:
    Octopus() {
        // <--- Тело конструктора обновлено
        try {
            for (int i = 1; i <= 8; ++i) {
                tentacles_.push_back(new Tentacle(i));
            }
        } catch (const bad_alloc&) {
            Cleanup();
            throw bad_alloc();
        }
        // --->
    }

    // <--- Добавлен деструктор
    ~Octopus() {
        Cleanup();
    }
    // --->

private:
    // <--- Добавлен метод cleanup
    void Cleanup() {
        for (Tentacle* t : tentacles_) {
            delete t;
        }
        tentacles_.clear();
    }
    // --->

    vector<Tentacle*> tentacles_;
};

int main() {
    Octopus octopus;
}
Удаление щупалец в деструкторе осьминога реализовано верно. Обработка исключения, которое операция new может выбросить при создании щупальца, тоже правильная. Если в конструкторе метод push_back выбросит исключение, то указатель, возвращаемый операцией new, не будет помещён в контейнер tentacles_ и не будет удалён в блоке catch. Произойдет утечка памяти.
Вариант 4
#include <iostream>
#include <string>
#include <vector>

using namespace std;

// Щупальце
class Tentacle {
public:
    explicit Tentacle(int id)
        : id_(id) {
    }

    int GetId() const {
        return id_;
    }

private:
    int id_ = 0;
};

// Осьминог
class Octopus {
public:
    Octopus() {
        // <--- Тело конструктора обновлено
        Tentacle* t = nullptr;
        try {
            for (int i = 1; i <= 8; ++i) {
                t = new Tentacle(i);
                tentacles_.push_back(t);
                t = nullptr;
            }
        } catch (const bad_alloc&) {
            Cleanup();
            delete t;
            throw bad_alloc();
        }
        // --->
    }

    // <--- Добавлен деструктор
    ~Octopus() {
        Cleanup();
    }
    // --->

private:
    // <--- Добавлен метод Cleanup
    void Cleanup() {
        tentacles_.clear();
    }
    // --->

    vector<Tentacle*> tentacles_;
};

int main() {
    Octopus octopus;
}
В методе Cleanup очищается только контейнер указателей, а сами щупальца так и продолжат занимать память в куче. Для исправления проблемы надо сначала выполнить delete с каждым указателем в контейнере tentacles_.
Вариант 5
#include <iostream>
#include <string>
#include <vector>

using namespace std;

// Щупальце
class Tentacle {
public:
    explicit Tentacle(int id)
        : id_(id) {
    }

    int GetId() const {
        return id_;
    }

private:
    int id_ = 0;
};

// Осьминог
class Octopus {
public:
    Octopus() {
        for (int i = 1; i <= 8; ++i) {
            tentacles_.push_back(new Tentacle(i));
        }
    }

    // <--- Добавлен деструктор
    ~Octopus() {
        for (Tentacle* t : tentacles_) {
            delete t;
        }
    }
    // --->

private:
    vector<Tentacle*> tentacles_;
};

int main() {
    Octopus octopus;
}
Этот код удалит щупальца из динамической памяти при вызове деструктора осьминога. Однако деструктор вызван не будет, если во время работы конструктора осьминога операция new Tentacle либо метод tentacles_.push_back выбросят исключение. Итог — утечка памяти, которую занимают сконструированные щупальца.

В программах на C++ применяют объекты с разным временем жизни. Долгоживущие объекты создаются в статической памяти и существуют на протяжении всей работы программы. Локальные переменные с автоматическим временем жизни наиболее просты в использовании — за их своевременным удалением следит компилятор.
Программа может обрабатывать произвольные объемы данных, при необходимости создавая и удаляя объекты в динамической памяти. Чтобы работать с ними напрямую, нужно хорошо понимать возможные пути выполнения программы, в том числе при выбрасывании исключений.
Как правило, код, который использует низкоуровневые операции с динамической памятью, располагают внутри библиотечных классов и функций. Это позволяет при решении прикладных задач концентрироваться на бизнес-логике, а не на ручном управлении динамической памятью.
В следующих уроках вы научитесь созданию простых в использовании классов, скрывающих трудности работы с динамической памятью.
Копирование объектов. Часть первая
В своих предыдущих программах вы, сами того не подозревая, хранили данные в динамической памяти, когда использовали строки и контейнеры vector, map и set. Эти стандартные классы размещают элементы в куче, а пользователю предоставляют простые и удобные операции вроде вставки и удаления элементов. Благодаря им вы концентрируетесь на прикладных задачах вроде поисковой системы и не отвлекаетесь на преодоление трудностей, которые возникают при работе с динамической памятью.
Когда дело касается объектов, хранящих данные в динамической памяти, многие привычные вещи вроде копирования становятся сложнее в реализации. Вспомним класс «Осьминог» из предыдущего урока.

Представление экземпляра класса Octopus в памяти
В классе «Осьминог» задача искусственно усложнена тем, что в векторе tentacles_ не сами щупальца, а указатели на них. Это сделано намеренно. Так вы увидите трудности, с которыми сталкиваются программисты классов, работающих с динамической памятью.
Чтобы устранить утечки памяти, потребовалось не только добавить деструктор, удаляющий щупальца осьминога, но и обработать возможное исключение bad_alloc в конструкторе класса. Однако в классе Octopus осталась ошибка, которая может проявлять себя очень странно. Создадим в программе еще одного осьминога, проинициализировать его значением первого:
#include <iostream>
#include <string>
#include <vector>

using namespace std;

// Щупальце
class Tentacle {
public:
    explicit Tentacle(int id): id_(id) {}
    int GetId() const {
        return id_;
    }
private:
    int id_ = 0;
};

// Осьминог
class Octopus {
public:
    Octopus() {
        Tentacle* t = nullptr;
        try {
            for (int i = 1; i <= 8; ++i) {
                t = new Tentacle(i);      // Может выбросить исключение bad_alloc
                tentacles_.push_back(t);  // Может выбросить исключение bad_alloc

                // Обнуляем указатель на щупальце, которое уже добавили в tentacles_,
                // чтобы не удалить его в обработчике catch повторно
                t = nullptr;
            }
        } catch (const bad_alloc&) {
            // Удаляем щупальца, которые успели попасть в контейнер tentacles_
            Cleanup();
            // Удаляем щупальце, которое создали, но не добавили в tentacles_
            delete t;
            // Конструктор не смог создать осьминога с восемью щупальцами,
            // поэтому выбрасываем исключение, чтобы сообщить вызывающему коду об ошибке
            // throw без параметров внутри catch выполняет ПЕРЕВЫБРОС пойманного исключения
            throw;
        }
    }

    const Tentacle& GetTentacle(int index) const {
        if (index < 0 || static_cast<size_t>(index) >= tentacles_.size()) {
            throw out_of_range("Invalid tentacle index"s);
        }
        // Чтобы превратить указатель в ссылку, разыменовываем его
        return *tentacles_[index];
    }

    ~Octopus() {
        // Осьминог владеет объектами в динамической памяти (щупальца),
        // которые должны быть удалены при его разрушении.
        // Деструктор - лучшее место, чтобы прибраться за собой.
        Cleanup();
    }

private:
    void Cleanup() {
        // Удаляем щупальца осьминога из динамической памяти
        for (Tentacle* t : tentacles_) {
            delete t;
        }
        // Очищаем массив указателей на щупальца
        tentacles_.clear();
    }

    // Вектор хранит указатели на щупальца. Сами объекты щупалец находятся в куче
    vector<Tentacle*> tentacles_;
};

int main() {
    {
        Octopus octopus;
        // Мы просто хотели еще одного осьминога
        Octopus octopus1 = octopus;
        // Всё было хорошо и не предвещало беды...
        // ... до этого момента
    }
    cout << "Congratulations. Everything is OK!"s << endl;
}
Скопируйте код в свою IDE и запустите. В зависимости от настроек компилятора и ОС программа может вести себя по-разному. Например, так:
Segmentation fault
Или не вывести ничего:


Внесите изменения в функцию main и снова запустите программу:
int main() {
    {
        Octopus octopus;
        // Мы просто хотели ещё одного осьминога
        Octopus octopus1 = octopus;
        cout << "Tentacle id="s << octopus1.GetTentacle(3).GetId() << endl;
    }
    cout << "OK"s << endl;
}
Возможный и ожидаемый вывод программы:
Tentacle id=4
OK
Но вывод может быть другим:
Tentacle id=4
Ситуация, которая возникает в программе, называется «неопределённое поведение». То есть программа может вести себя как угодно: упасть, выдать ожидаемый результат или отправить в прошлое Терминатора, чтобы убить Сару Коннор. Но сейчас нас интересует не то, что программа может сделать, а причины, которые к этому привели.
Данную программу от ранее работавшей отличает создание копии осьминога:
int main() {
    // Оригинальный осьминог
    Octopus octopus;
    // Копия первого осьминога
    Octopus octopus1 = octopus;
}
Первый осьминог инициализируется конструктором по умолчанию. Для инициализации второго осьминога использован копирующий конструктор. Его ещё называют конструктором копирования.
Копирующий конструктор создает новый объект на основе существующего. В качестве своего параметра этот конструктор принимает константную ссылку на объект того же типа:
#include <string>
using namespace std;
class Object {
public:
    // Явно заданный конструктор копирования.
    // Ожидается, что копия будет идентична оригиналу,
    // поэтому поля копии инициализируем значением полей оригинала
    Object(const Object& other)
        : id_(other.id_)
        , name_(other.name_) {
    }
    // ...
private:
    int id_;
    string name_;
};
Вызов копирующего конструктора может быть явным, как у нашего осьминога, и неявным — например, при передаче параметра в функцию по значению или при возврате объекта из функции:
void PlayWithOctopus(Octopus o) {
    cout << "tentacle:"s << o.GetTentacle(1).GetId() << endl;
}
int main() {
    Octopus o1;

    // В функцию PlayWithOctopus будет неявно передана копия объекта o1
    PlayWithOctopus(o1);
    cout << "OK"s << endl;
}
Компилятор может сгенерировать не только конструктор по умолчанию, но и копирующий конструктор. В этом случае для инициализации каждого поля объекта будет вызван его копирующий конструктор. В классе Octopus компилятор генерирует конструктор копирования, который создаст копию массива указателей на щупальца осьминога:
#include <vector>
using namespace std;
// Щупальце
class Tentacle {
    // ...
};
// Осьминог
class Octopus {
public:
    // ...
    // Сгенерированный компилятором конструктор копирования
    // копирует массив указателей на щупальца
    Octopus(const Octopus& other)
        : tentacles_(other.tentacles_) {
    }
    // ...

private:
    // ...
    // Вектор хранит указатели на щупальца. Сами объекты щупалец находятся в куче
    vector<Tentacle*> tentacles_;
};
Получим ситуацию, изображенную на этом рисунке:




Копия осьминога будет ссылаться на те же щупальца, что и оригинал
Когда на один объект ссылаются несколько указателей — это нормально.
Проблемы начинаются при выходе из блока, где объявлены переменные octopus и octopus1. Сначала будет вызван деструктор octopus1. Он удалит щупальца осьминога:


Деструктор octopus1 удалит щупальца осьминога
После удаления octopus1 указатели, которые хранятся в массиве щупалец осьминога octopus, станут невалидными — они более не ссылаются на существующие объекты. Такие указатели нельзя использовать для доступа к объекту. Нельзя даже вызвать операцию delete. Все эти действия приведут к неопределенному поведению при удалении осьминога octopus: в своем деструкторе он передаст в оператор delete невалидный указатель.
Вы познакомились с копирующим конструктором. Он инициализирует экземпляр класса, копируя уже имеющийся. Этот конструктор принимает константную ссылку на копируемый объект. Всякий раз, когда в программе явно или неявно создается копия существующего объекта, используется копирующий конструктор.
Сгенерированный компилятором конструктор копирования создаёт копию объекта, копируя все поля оригинала. Это поведение хорошо работает для классов и структур, хранящих объекты-значения, но плохо для копирования классов, которые содержат данные в динамической памяти. В нашем случае проблема возникла при копировании осьминога. Копия осьминога должна иметь собственный набор щупалец, а не пользоваться щупальцами оригинала.
Когда сгенерированный компилятором конструктор копирования не подходит, вы можете написать его вручную, реализовав желаемую семантику копирования объектов. 
Копирование объектов. Часть вторая
Выбираем способ хранить щупальца
Код осьминога из предыдущего урока был искусственно усложнено тем, что щупальца хранились в динамической памяти. Так вы смогли увидеть трудности своими глазами. Если бы в tentacles_ хранились сами щупальца, а не указатели на них, проблем при копировании осьминога не возникло бы — все его щупальца скопировались бы автоматически.
Чтобы хранение указателей на щупальца вместо самих щупалец было более обоснованным, немного усложним задачу:
щупальце может прицепляться к произвольному щупальцу любого осьминога и отцепляться от него;
осьминог при создании может иметь произвольное количество щупалец. По умолчанию их восемь;
разрешается добавлять осьминогу новые щупальца, используя метод AddTentacle.
class Tentacle {
public:
    explicit Tentacle(int id) noexcept;
    int GetId() const noexcept;

    Tentacle* GetLinkedTentacle() const noexcept {
        return linked_tentacle_;
    }
    void LinkTo(Tentacle& tentacle) noexcept {
        linked_tentacle_ = &tentacle;
    }
    void Unlink() noexcept {
        linked_tentacle_ = nullptr;
    }

private:
    int id_ = 0;
    Tentacle* linked_tentacle_ = nullptr;
};

class Octopus {
public:
    Octopus();
    explicit Octopus(int num_tentacles);

    void AddTentacle();
    size_t GetTentacleCount() const noexcept;
    const Tentacle& GetTentacle(size_t index) const;
    Tentacle& GetTentacle(size_t index);

    ~Octopus();

private:
    void Cleanup() noexcept;

    vector<Tentacle*> tentacles_;
};

int main() {
    Octopus octopus1;
    Octopus octopus2;

    // Два осьминога прицепляются друг к другу щупальцами
    octopus1.GetTentacle(1).LinkTo(octopus2.GetTentacle(3));
    octopus2.AddTentacle();
    octopus2.GetTentacle(octopus2.GetTentacleCount() - 1).LinkTo(octopus1.GetTentacle(0));
}
📖  В коде использован спецификатор noexcept, означающий, что метод или функция не выбрасывает исключений. Он помогает компилятору сгенерировать более быстрый код, а программисту гарантирует, что при вызове метода или функции исключений не будет.
Из-за возможности добавлять осьминогу новые щупальца, а щупальцам — ссылаться друг на друга, хранение щупалец в векторе становится затруднительным:
При добавлении нового щупальца ранее существовавшие ссылки на щупальца станут невалидны из-за особенностей реализации вектора. Почему так происходит, вы узнаете через несколько уроков.
Другие контейнеры могли сохранить валидность ссылок при вставке и удалении элементов, но не справились бы с неожиданным требованием разрешить осьминогам обмениваться щупальцами.
Храня щупальца в динамической памяти, делаем их более независимыми: их адрес не изменится ни при модификации контейнера, ни при передаче другому осьминогу. На практике такая задача может возникать регулярно — например, папки хранят наборы файлов, а гостиницы — наборы постояльцев.
Анализируем код конструктора по умолчанию
Прежде чем начать писать конструктор копирования класса «Осьминог», взгляните на конструктор по умолчанию в классе Octopus:
class Octopus {
public:
    Octopus() {
        Tentacle* t = nullptr;
        try {
            for (int i = 1; i <= 8; ++i) {
                t = new Tentacle(i);      // Может выбросить исключение bad_alloc
                tentacles_.push_back(t);  // Может выбросить исключение bad_alloc

                // Обнуляем указатель на щупальце, которое уже добавили в tentacles_,
                // чтобы не удалить его в обработчике catch повторно
                t = nullptr;
            }
        } catch (const bad_alloc&) {
            // Удаляем щупальца, которые успели попасть в контейнер tentacles_
            Cleanup();
            // Удаляем щупальце, которое создали, но не добавили в tentacles_
            delete t;
            // Конструктор не смог создать осьминога с восемью щупальцами,
            // поэтому выбрасываем исключение, чтобы сообщить вызывающему коду об ошибке
            // throw без параметров внутри catch выполняет ПЕРЕВЫБРОС пойманного исключения
            throw;
        }
    }
    ...
};
Код конструктора получился довольно сложным, так как нужно обработать исключение bad_alloc. Оно может возникнуть при создании щупальца в динамической памяти.
Обработчик исключения должен удалить объекты, на которые ссылаются указатели в векторе tentacles_. Удалить нужно и щупальце по адресу в переменной t. Оно ещё не успело попасть в контейнер tentacles_.
Если в таком же стиле написать конструктор копирования, он будет не менее сложным. Вот был бы способ автоматически удалять объект из динамической памяти, когда указатель, хранящий его адрес, выходит из своей области видимости!
В C++ эту задачу решают умные указатели — классы, которые благодаря перегрузке операций ведут себя как указатели. Они предоставляют операцию разыменования * и доступа к членам класса ->. В отличие от обычных указателей, которые ещё называют «сырыми», умные указатели реализуют семантику владения объектом, то есть автоматически удаляют объект при наступлении определенных условий. Умные указатели также определяют, что должно происходить при копировании указателя. Как правило, умные указатели делают шаблонными, чтобы использовать с объектами разных типов.
В стандартной библиотеке есть классы умных указателей, которые упростили бы решение задачи. Вы обязательно с ними познакомитесь в следующих спринтах. В этом уроке вы создадите свой умный указатель, чтобы потом упростить класс Octopus.
Умный указатель в качестве одного из своих полей хранит обычный указатель, а «умное поведение» реализуется за счёт конструктора, деструктора и специфичных для указателя операций.
Ваш указатель ScopedPtr будет владеть объектом, созданным в куче, и гарантировать, что объект автоматически удаляется при выходе из области видимости указателя.
В повседневной разработке вам вряд ли понадобится писать собственные умные указатели и вручную вызывать new/delete. Скорее всего, использовать вы будете стандартные. Но задания позволят разобраться, как удобные стандартные классы устроены на самом деле, и чего от них ожидать.
Копирование объектов. Часть третья
Вы создали свой первый умный указатель ScopedPtr, который позволил сохранить объект в динамической памяти и автоматически контролировать время его жизни. У ScopedPtr есть и другие полезные свойства:
Исключает неинициализированное состояние. Он либо пустой, либо хранит адрес существующего объекта;
Запрещает копирование указателя. Тем самым исключает ситуацию, когда два указателя одновременно владеют одним объектом;
Вместо неопределённого поведения при разыменовании нулевого указателя ScopedPtr выбрасывает исключение logic_error, которое можно поймать и обработать приложением.
Эти свойства указателя позволяют сделать управление объектами в динамической памяти проще. Вместо такого:
int main() {
    vector<Object*> objects;
    Object* ptr = nullptr;
    try {
        for (int i = 0; i < 5; ++i) {
            ptr = new Object();
            objects.push_back(ptr);
            // Обнуляем ptr (этот указатель уже скопирован в objects)
            ptr = nullptr;
        }
    } catch (...) {
        delete ptr;
    }
    // Удаляем объекты из массива указателей
    for (Object* obj_ptr : objects) {
        delete obj_ptr;
    }
}
Можно написать лаконичнее:
int main() {
    vector<Object*> objects;
    try {
        for (int i = 0; i < 5; ++i) {
            // Пока указатель не добавлен в контейнер objects, им владеет умный указатель
            ScopedPtr<Object> ptr(new Object());
            objects.push_back(ptr.GetRawPtr());

            // Вызываем Release, чтобы указатель не удалил объект, уже 
            // вставленный в вектор.
            ptr.Release();
        }
    } catch (...) {
    }
    for (Object* obj_ptr : objects) {
        delete obj_ptr;
    }
}
Тем не менее удалять объекты, на которые ссылаются указатели внутри вектора, всё ещё приходится вручную. Чтобы автоматизировать процесс, разработаем класс-обертку PtrVector — вектор указателей. Он автоматически удаляет объекты в своем деструкторе. Код станет еще проще:
int main() {
    PtrVector<Object> objects;
    for (int i = 0; i < 3; ++i) {
        ScopedPtr<Object> ptr(new Object());
        objects.GetItems().push_back(ptr.GetRawPtr());
        ptr.Release();
    }
    cout << "PtrVector copy has been destroyed"s << endl;
    // Деструктор PtrVector автоматически удалит объекты, на которые
    // ссылаются хранящиеся внутри него указатели
}
Также PtrVector будет допускать копирование:
PtrVector<Object> objects;
// ...

PtrVector<Object> objects_copy(objects);
Во время которого он создаст копии всех объектов, указатели на которые содержатся в objects.
Присваивание объектов
В прошлых уроках вы научились копировать объекты, содержащие указатели на подобъекты в динамической памяти. Вы разработали умный указатель ScopedPtr, который реализует семантику владения объектом в динамической памяти, и класс PtrVector, автоматизирующий удаление и копирование объектов внутри вектора указателей. Так вы сделали копирование осьминогов не только надёжным, но и простым. В реальных задачах умные указатели и «обёртки» тоже упрощают написание надежного кода.
В этом уроке вы научитесь правильно реализовывать присваивание объектов. Присваивание — одна из специальных операций C++. Для пользовательских типов компилятор может реализовать её автоматически. Поэтому вам не приходилось беспокоиться о ней, когда вы присваивали один объект другому:
#include <cassert>
#include <string>
using namespace std;
struct Cat {
    string name;
    int age = 0;
};
int main() {
    Cat cat1{"Tom"s, 3};
    Cat cat2;
    // Сгенерированный компилятором метод operator= выполнит 
    // присваивание соответствующих полей класса Cat.
    cat2 = cat1;

    assert(cat1.name == cat2.name);
    assert(cat1.age == cat2.age);
}
Операция =, которую сгенерировал компилятор, присваивает значения полей одного объекта соответствующим полям другого. В большинстве случаев это именно то, что нужно!
Но, как вы уже знаете, привычные вещи становятся труднее в реализации, когда объект владеет другими объектами в динамической памяти или иными ресурсами.
В классе Octopus сгенерированная операция = присвоит массив щупалец одного осьминога другому:
int main() {
    {
        Octopus octopus1(3);
        octopus1.GetTentacle(1).LinkTo(octopus.GetTentacle(2));
        Octopus octopus2;
        octopus2 = octopus1;
        // Этот assert выстрелит, так как операция присваивания присвоит массив 
        // указателей на щупальца первого осьминога второму, и осьминоги будут 
        // использовать один и тот же набор щупалец.
        assert(&octopus2.GetTentacle(1) != &octopus1.GetTentacle(1));
        assert(octopus2.GetTentacle(1).GetLinkedTentacle() == &octopus1.GetTentacle(2));
        // После присваивания оба осьминога будут ссылаться на одни и те же щупальца
        // Деструктор octopus2 удалит щупальца, на которые ссылается octopus1,
        // и все указатели octopus1 станут невалидными.

        // Деструктор octopus1 выполнит удаление щупальцев с невалидными указателями,
        // что приведёт к неопределённому поведению.
    }
    cout << "OK"s << endl;
}
В результате оба осьминога будут использовать одни и те же объекты щупалец в динамической памяти.

Программа вновь поведет себя непредсказуемо.
Когда у класса с пользовательским конструктором копирования используется неявно сгенерированная операция присваивания, компилятор может об этом предупредить:
prog.cc:162:20: warning: implicitly-declared 'Octopus& Octopus::operator=(const Octopus&)' is deprecated [-Wdeprecated-copy]
  162 |         octopus1 = octopus;
      |                    ^~~~~~~
prog.cc:125:5: note: because 'Octopus' has user-provided 'Octopus::Octopus(const Octopus&)'
  125 |     Octopus(const Octopus& other) {
      |     ^~~~~~~
Чтобы решить проблему, переопределите эту операцию и реализуйте в ней присваивание значений объектов, а не указателей.
В С++ операцию присваивания можно переопределить только внутри класса в виде метода с именем operator=. Левым аргументом операции присваивания выступает текущий экземпляр класса, а правый аргумент передается через её единственный параметр. Тип правого аргумента операции может быть любым, а самих операций присваивания может быть определено несколько. Как правило, операция присваивания возвращает ссылку на свой левый аргумент. Это позволяет использовать результат операции в составе выражений, например x = y = z.
В С++ действует эмпирическое «Правило трёх». Если класс или структура объявляют один из следующих методов, скорее всего, они должны объявить все три:
деструктор,
конструктор копирования,
операция присваивания.
Эти особые функции класса может сгенерировать компилятор. Если программист переопределил одну из них, значит, сгенерированная компилятором версия не удовлетворяет потребностям класса в одном случае, и, вероятно, не удовлетворит в остальных.
Для структуры Cat операция присваивания, аналогичная сгенерированному компилятором, выглядит так:
struct Cat {
    string name;
    int age = 0;
    Cat& operator=(const Cat& rhs) {
        // оптимизация самоприсваивания
        if (this != &rhs) {
            name = rhs.name;
            age = rhs.age;
        }
        // this - указатель на текущий экземпляр класса.
        // В операции присваивания он ссылается на левый аргумент операции.
        return *this; // возвращаем ссылку на левый аргумент операции присваивания
    }
};
Обратите внимание на защиту от присваивания объекта самому себе. Это идиоматичный способ избежать лишних действий и некорректной работы при самоприсваивании объекта.
Без этой проверки в структуре Cat самоприсваивание приведет в худшем случае к замедлению программы. А вот для класса PtrVector может привести к некорректной работе:
#include <cassert>
#include <vector>
using namespace std;
template <typename T>
class PtrVector {
public:
    ...
    // Внутри шаблона класса можно ссылаться на собственный тип, используя краткую запись:
    // PtrVector вместо PtrVector<T>
    PtrVector& operator=(const PtrVector& rhs) {
        // При присваивании PtrVector самому себе произойдёт удаление не только
        // своих элементов, но и элементов rhs.
        for (auto p : items_) {
            delete p;
        }
        items_.clear();

        items_.reserve(rhs.items_.size());
        for (T* p : rhs.items_) {
            items_.push_back(p ? new T(*p) : nullptr);
        }
        return *this;
    }
private:
    vector<T*> items_;
};

int main() {
    PtrVector<int> v;
    v.GetItems().push_back(new int(1));
    v.GetItems().push_back(new int(2));
    v = v;
    // Этот assert выстрелит, так как элементы v удалятся при самоприсваивании
    assert(v.GetItems().size() == 2);
}
Другая проблема: если при копировании элементов операция new выбросит исключение, PtrVector окажется в промежуточном состоянии. Прежнее содержимое теряется, а новые элементы до конца скопированы не будут.
Удобнее, когда методы класса обеспечивают строгую гарантию безопасности исключений: операция либо завершается успешно, либо происходит выбрасывание исключения и состояние объекта останется прежним. Такая семантика выполнения также называется “commit or rollback”.
Обеспечить строгую гарантию безопасности исключений в пользовательской операции присваивания можно, применив идиому “copy-and-swap”. В ней операция присваивания переиспользует функционал конструктора копирования.
Чтобы создать временную копию присваиваемого объекта, примените конструктор копирования. Если во время создания копии будет выброшено исключение, оно повлияет на временную копию, а не на текущий экземпляр класса.
Обменяйте текущее состояние объекта и временной копии. Эта операция не должна выбрасывать исключений. При выходе из операции присваивания прежнее состояние будет разрушено, а текущее состояние будет равно состоянию правого аргумента.
Применим copy-and-swap и реализуем операцию присваивания:
class Object {
public:
    // копирующий конструктор
    Object(const Object& other);
    // копирующая операция присваивания
    Object& operator=(const Object& rhs) {
        if (this != &rhs) {
            // Реализация операции присваивания с помощью идиомы Copy-and-swap.
            // Если исключение будет выброшено, то на текущий объект оно не повлияет.
            auto rhs_copy(rhs);
            // rhs_copy содержит копию правого аргумента.
            // Обмениваемся с ним данными.
            swap(rhs_copy);
            // Теперь текущий объект содержит копию правого аргумента,
            // а rhs_copy - прежнее состояние текущего объекта, которое при выходе
            // из блока будет разрушено.
        }

        return *this;
    }
    // обменивает состояние текущего объекта с other без выбрасывания исключений
    void swap(Object& other) noexcept;
    ~Object();
};

