# Ответы на тест по модели памяти C++

## Правильные ответы:

1. **b) Степень двойки, определяющая допустимые адреса размещения объекта** - Выравнивание определяет, по каким адресам может быть размещен объект
2. **c) 12** - char(1) + padding(3) + int(4) + char(1) + padding(3) = 12 байт
3. **c) Неопределенное поведение** - Использование указателя после delete приводит к UB
4. **b) Стек (stack)** - Локальные переменные хранятся в стеке
5. **b) Возвращает требования к выравниванию типа T** - alignof возвращает требования к выравниванию
6. **c) const int* const ptr** - Константный указатель на константу
7. **c) Ничего не произойдет** - delete с nullptr безопасен
8. **c) Статическое** - Глобальные переменные имеют статическое время жизни
9. **b) Создает указатель на переменную value** - Ссылка не создает новый объект
10. **b) 8 байт** - На 64-битной системе указатели имеют размер 8 байт
11. **b) Когда выделенная память не освобождается** - Определение утечки памяти
12. **a) A~Amain** - Конструктор, деструктор при выходе из функции, затем main
13. **b) Неопределенное поведение** - Двойное удаление приводит к UB
14. **b) &** - Операция взятия адреса
15. **b) Возвращает размер типа или объекта в байтах** - Определение sizeof
16. **b) int* x = new int(42);** - new размещает объект в куче
17. **a) Constructor** - Вызывается только конструктор, деструктор не вызывается
18. **c) Неопределенное значение** - Локальные переменные не инициализируются автоматически
19. **b) Приводит к неопределенному поведению** - Для массивов нужно использовать delete[]
20. **b) *** - Операция разыменования
21. **b) Переполнение стека** - Рекурсия с большими локальными массивами
22. **c) nullptr_t** - Тип nullptr
23. **c) Выделяет память и вызывает конструктор** - Полное определение new
24. **b) 20** - Все указатели ссылаются на одну переменную
25. **b) Указатель на удаленный объект** - Определение висячего указателя
26. **d) Все перечисленные** - Все способы корректны для проверки указателя
27. **c) 17** - int(4) + double(8) + char(1) + padding(4) = 17, но с учетом выравнивания может быть больше
28. **b) ->** - Операция доступа к членам через указатель
29. **b) Возвращает указатель на локальную переменную (неопределенное поведение)** - Локальный массив разрушается при выходе из функции
30. **b) new** - new может выбросить std::bad_alloc
31. **b) Двойное удаление памяти** - Поверхностное копирование приводит к двойному удалению
32. **b) delete[] используется для массивов** - Разница между delete и delete[]
33. **b) Приводит к ошибке компиляции** - Нельзя изменить константный указатель
34. **c) Неопределенное поведение** - ptr2 указывает на удаленную память
35. **a) Техника управления ресурсами** - Resource Acquisition Is Initialization
36. **b) unique_ptr** - Умный указатель из C++11
37. **b) Ошибка компиляции** - unique_ptr не копируется
38. **b) std::move** - Оператор перемещения
39. **a) Создает shared_ptr** - Функция для создания shared_ptr
40. **b) std::make_unique<int>(42)** - Предпочтительный способ создания unique_ptr

## Дополнительные пояснения:

**Вопрос 2**: Структура выравнивается по наибольшему элементу (int = 4 байта). char занимает 1 байт, но после него добавляется 3 байта padding для выравнивания int.

**Вопрос 12**: Объект создается в функции func(), его деструктор вызывается при выходе из функции, затем выполняется код в main.

**Вопрос 19**: Для массивов, созданных с помощью new[], необходимо использовать delete[], а не delete.

**Вопрос 27**: Размер может отличаться в зависимости от компилятора и настроек выравнивания.

**Вопрос 31**: Класс использует сгенерированный компилятором конструктор копирования, который копирует только указатель, а не данные.

**Вопрос 37**: unique_ptr имеет удаленный конструктор копирования, поэтому код не скомпилируется. 