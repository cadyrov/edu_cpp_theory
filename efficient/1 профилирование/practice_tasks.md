# Практические задания по профилированию и оптимизации

## Задание 1: Создание профилировщика

**Описание**: Реализуйте универсальный профилировщик, который может измерять время выполнения любых функций.

**Требования**:
- Используйте RAII для автоматического измерения
- Поддержка различных единиц времени (мс, мкс, нс)
- Возможность записи результатов в файл
- Статистика: минимум, максимум, среднее, медиана

**Тесты**:
1. Измерение времени сна на 100ms должно быть ~100ms ±5ms
2. Измерение быстрой операции (x = 1 + 1) должно быть < 1мкс
3. Измерение 1000 операций должно дать статистику
4. Результаты должны записываться в файл profile.log
5. Профилировщик должен работать с любыми функциями
6. Должен поддерживать вложенные измерения
7. Статистика должна быть точной для 100+ измерений
8. Файл лога должен содержать timestamp
9. Должен корректно работать в многопоточной среде
10. Память профилировщика не должна расти при длительной работе

```cpp
// Пример использования:
{
    Profiler prof("my_function");
    expensive_operation();
} // автоматический вывод времени

auto stats = Profiler::GetStatistics("my_function");
```

## Задание 2: Оптимизация матричного умножения

**Описание**: Оптимизируйте наивный алгоритм умножения матриц для максимальной производительности.

**Требования**:
- Исходный алгоритм O(n³)
- Оптимизация кэш-локальности
- Использование блочного алгоритма
- Сравнение с наивной реализацией

**Тесты**:
1. Корректность: результат должен совпадать с наивным алгоритмом
2. Производительность: ускорение минимум в 2 раза для матриц 512x512
3. Масштабируемость: ускорение растет с размером матрицы
4. Память: потребление памяти не должно расти значительно
5. Блочный алгоритм должен работать с разными размерами блоков
6. Должен работать с не квадратными матрицами
7. Должен корректно обрабатывать граничные случаи (размер < размера блока)
8. Производительность должна быть стабильной при повторных запусках
9. Должен работать с различными типами данных (int, float, double)
10. Оптимизация должна быть эффективна для больших матриц (1024x1024+)

```cpp
// Сигнатуры функций:
void naive_multiply(const Matrix& A, const Matrix& B, Matrix& C);
void optimized_multiply(const Matrix& A, const Matrix& B, Matrix& C);
```

## Задание 3: Профилирование и оптимизация поиска

**Описание**: Реализуйте и оптимизируйте различные алгоритмы поиска в массиве.

**Требования**:
- Линейный поиск
- Бинарный поиск
- Интерполяционный поиск
- Профилирование каждого алгоритма

**Тесты**:
1. Корректность: все алгоритмы должны находить существующие элементы
2. Корректность: все алгоритмы должны возвращать -1 для несуществующих элементов
3. Производительность: бинарный поиск должен быть быстрее линейного для больших массивов
4. Производительность: интерполяционный поиск должен быть быстрее бинарного для равномерно распределенных данных
5. Масштабируемость: время должно расти согласно теоретической сложности
6. Должен работать с пустыми массивами
7. Должен работать с массивами из одного элемента
8. Должен корректно обрабатывать дубликаты
9. Профилирование должно показывать реальную разницу в производительности
10. Результаты профилирования должны быть воспроизводимы

```cpp
// Сигнатуры функций:
int linear_search(const std::vector<int>& arr, int target);
int binary_search(const std::vector<int>& arr, int target);
int interpolation_search(const std::vector<int>& arr, int target);
```

## Задание 4: Оптимизация обработки строк

**Описание**: Оптимизируйте функции обработки строк для максимальной производительности.

**Требования**:
- Подсчет символов
- Поиск подстроки
- Замена символов
- Сравнение производительности с std::string

**Тесты**:
1. Корректность: подсчет символов должен быть точным
2. Корректность: поиск подстроки должен находить все вхождения
3. Корректность: замена должна заменять все указанные символы
4. Производительность: должна быть не хуже std::string методов
5. Должен работать с пустыми строками
6. Должен работать с очень длинными строками (1MB+)
7. Должен корректно обрабатывать Unicode символы
8. Память: не должно быть утечек памяти
9. Должен быть потокобезопасным
10. Профилирование должно показывать узкие места

```cpp
// Сигнатуры функций:
size_t count_chars(const std::string& str, char c);
std::vector<size_t> find_substring(const std::string& str, const std::string& sub);
std::string replace_chars(const std::string& str, char old_char, char new_char);
```

## Задание 5: Оптимизация сортировки

**Описание**: Реализуйте и оптимизируйте различные алгоритмы сортировки.

**Требования**:
- Bubble sort (для сравнения)
- Quick sort
- Merge sort
- Гибридный алгоритм (как в std::sort)

**Тесты**:
1. Корректность: все алгоритмы должны правильно сортировать массивы
2. Корректность: должны работать с уже отсортированными массивами
3. Корректность: должны работать с обратно отсортированными массивами
4. Производительность: quicksort должен быть быстрее bubblesort
5. Производительность: гибридный алгоритм должен быть быстрее всех
6. Должен работать с пустыми массивами
7. Должен работать с массивами из одного элемента
8. Должен корректно обрабатывать дубликаты
9. Должен быть стабильным (где требуется)
10. Профилирование должно показывать сложность алгоритмов

```cpp
// Сигнатуры функций:
void bubble_sort(std::vector<int>& arr);
void quick_sort(std::vector<int>& arr);
void merge_sort(std::vector<int>& arr);
void hybrid_sort(std::vector<int>& arr);
```

## Задание 6: Оптимизация работы с памятью

**Описание**: Реализуйте пул памяти для эффективного выделения и освобождения небольших объектов.

**Требования**:
- Фиксированный размер блоков
- Быстрое выделение/освобождение
- Минимальная фрагментация
- Профилирование использования памяти

**Тесты**:
1. Корректность: выделенная память должна быть валидной
2. Корректность: освобожденная память должна быть доступна для повторного использования
3. Производительность: должен быть быстрее стандартного new/delete
4. Производительность: должен масштабироваться с количеством операций
5. Память: не должно быть утечек памяти
6. Память: должен эффективно использовать выделенную память
7. Должен работать в многопоточной среде
8. Должен корректно обрабатывать исчерпание пула
9. Должен предоставлять статистику использования
10. Должен поддерживать различные размеры объектов

```cpp
// Пример использования:
MemoryPool pool(1024, 64); // 1024 блока по 64 байта
void* ptr = pool.allocate();
pool.deallocate(ptr);
```

## Задание 7: Оптимизация кэш-эффективности

**Описание**: Реализуйте структуру данных с оптимальной кэш-локальностью.

**Требования**:
- Структура данных для хранения точек в 2D
- Оптимизация для частых запросов в области
- Сравнение с наивной реализацией
- Анализ cache miss'ов

**Тесты**:
1. Корректность: должна корректно хранить и извлекать точки
2. Корректность: поиск в области должен находить все точки в заданном прямоугольнике
3. Производительность: должна быть быстрее наивной реализации для больших данных
4. Производительность: время поиска должно масштабироваться логарифмически
5. Память: должна эффективно использовать память
6. Должна поддерживать динамическое добавление/удаление точек
7. Должна работать с различными типами координат (int, float, double)
8. Должна оптимально работать с различными размерами областей поиска
9. Должна показывать улучшение кэш-локальности в профилировании
10. Должна масштабироваться до миллионов точек

```cpp
// Сигнатуры функций:
class SpatialStructure {
public:
    void insert(const Point& p);
    void remove(const Point& p);
    std::vector<Point> range_query(const Rectangle& rect);
};
```

## Задание 8: Профилирование многопоточности

**Описание**: Реализуйте многопоточный алгоритм и профилировщик для анализа параллельной производительности.

**Требования**:
- Параллельная обработка массива
- Измерение времени каждого потока
- Анализ эффективности распараллеливания
- Поиск оптимального количества потоков

**Тесты**:
1. Корректность: результат должен совпадать с однопоточной версией
2. Корректность: должен работать с различным количеством потоков
3. Производительность: должен показывать ускорение при увеличении потоков
4. Производительность: должен находить оптимальное количество потоков
5. Должен корректно распределять работу между потоками
6. Должен избегать состояний гонки
7. Должен минимизировать накладные расходы на синхронизацию
8. Профилировщик должен показывать время работы каждого потока
9. Должен масштабироваться с количеством ядер процессора
10. Должен показывать эффективность использования ресурсов

```cpp
// Сигнатуры функций:
void parallel_process(std::vector<int>& data, int num_threads);
ThreadProfiler get_thread_statistics();
```

## Задание 9: Оптимизация ввода-вывода

**Описание**: Оптимизируйте операции чтения/записи файлов для максимальной производительности.

**Требования**:
- Буферизованный ввод-вывод
- Асинхронный ввод-вывод
- Сравнение с стандартными методами
- Профилирование различных размеров буферов

**Тесты**:
1. Корректность: записанные данные должны быть идентичны прочитанным
2. Корректность: должен работать с файлами различных размеров
3. Производительность: должен быть быстрее стандартных методов
4. Производительность: должен находить оптимальный размер буфера
5. Должен корректно обрабатывать ошибки ввода-вывода
6. Должен работать с очень большими файлами (GB+)
7. Должен эффективно использовать память
8. Должен поддерживать различные типы данных
9. Асинхронная версия должна показывать преимущества
10. Профилирование должно показывать узкие места ввода-вывода

```cpp
// Сигнатуры функций:
class OptimizedIO {
public:
    void write_file(const std::string& filename, const std::vector<char>& data);
    std::vector<char> read_file(const std::string& filename);
    void async_write_file(const std::string& filename, const std::vector<char>& data);
    std::future<std::vector<char>> async_read_file(const std::string& filename);
};
```

## Задание 10: Комплексная оптимизация

**Описание**: Оптимизируйте реальное приложение, применив все изученные техники.

**Требования**:
- Анализ производительности существующего кода
- Применение различных техник оптимизации
- Измерение улучшений
- Документирование изменений

**Тесты**:
1. Корректность: оптимизированная версия должна давать те же результаты
2. Корректность: должна проходить все существующие тесты
3. Производительность: общее ускорение должно быть минимум 50%
4. Производительность: должна масштабироваться лучше оригинала
5. Память: потребление памяти не должно значительно увеличиться
6. Должна сохранить читаемость кода
7. Должна быть задокументирована каждая оптимизация
8. Должна включать профилирование до и после
9. Должна показывать применение различных техник оптимизации
10. Должна включать рекомендации по дальнейшему улучшению

```cpp
// Пример структуры отчета:
struct OptimizationReport {
    std::string technique;
    double improvement_percent;
    std::string description;
    std::vector<BenchmarkResult> before_after;
};
```

## Общие требования ко всем заданиям:

1. **Код должен компилироваться без предупреждений** с флагами `-Wall -Wextra -O2`
2. **Все тесты должны проходить** на различных платформах
3. **Код должен быть документирован** с комментариями
4. **Должны использоваться современные возможности C++** (до C++17)
5. **Профилирование должно быть воспроизводимым** с указанием условий тестирования
6. **Результаты должны быть статистически значимыми** (несколько запусков)
7. **Код должен следовать лучшим практикам** из теоретического материала
8. **Должны быть приведены графики производительности** для наглядности
9. **Каждое задание должно включать README** с инструкциями по сборке и запуску
10. **Должны быть примеры использования** для каждой функции 