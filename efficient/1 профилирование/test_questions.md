# Тест по профилированию и оптимизации в C++

## Вопрос 1
Какой тип часов из std::chrono лучше всего подходит для измерения временных интервалов?

A) std::chrono::system_clock
B) std::chrono::steady_clock
C) std::chrono::high_resolution_clock
D) std::chrono::utc_clock

## Вопрос 2
Что произойдет с этим кодом?
```cpp
auto start = std::chrono::steady_clock::now();
std::this_thread::sleep_for(std::chrono::seconds(2));
auto end = std::chrono::steady_clock::now();
auto duration = end - start;
```

A) Ошибка компиляции
B) duration будет типа std::chrono::steady_clock::duration
C) duration будет типа std::chrono::seconds
D) duration будет типа int

## Вопрос 3
Какая из реализаций LogDuration правильная?

A) 
```cpp
class LogDuration {
    std::chrono::steady_clock::time_point start_;
public:
    LogDuration() : start_(std::chrono::steady_clock::now()) {}
    ~LogDuration() {
        auto end = std::chrono::steady_clock::now();
        std::cerr << (end - start_).count() << " ms\n";
    }
};
```

B)
```cpp
class LogDuration {
    std::chrono::steady_clock::time_point start_;
public:
    LogDuration() : start_(std::chrono::steady_clock::now()) {}
    ~LogDuration() {
        auto end = std::chrono::steady_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start_);
        std::cerr << duration.count() << " ms\n";
    }
};
```

C) Обе правильные
D) Обе неправильные

## Вопрос 4
Что делает макрос __LINE__?

A) Возвращает текущее время
B) Возвращает номер строки в исходном коде
C) Возвращает имя файла
D) Возвращает имя функции

## Вопрос 5
Какой оператор используется для склеивания токенов в макросах?

A) #
B) ##
C) ###
D) &

## Вопрос 6
Почему эта реализация реверса медленная?
```cpp
vector<int> ReverseVector(const vector<int>& source) {
    vector<int> result;
    for (int x : source) {
        result.insert(result.begin(), x);
    }
    return result;
}
```

A) Используется range-based for
B) Вставка в начало вектора требует сдвига всех элементов
C) Нет резервирования памяти
D) Все перечисленное

## Вопрос 7
Какая версия быстрее?

A)
```cpp
for (int i = 0; i < n; ++i) {
    for (int j = 0; j < m; ++j) {
        matrix[i][j] = process(matrix[i][j]);
    }
}
```

B)
```cpp
for (int j = 0; j < m; ++j) {
    for (int i = 0; i < n; ++i) {
        matrix[i][j] = process(matrix[i][j]);
    }
}
```

C) Скорость одинаковая
D) Зависит от размера матрицы

## Вопрос 8
Что такое кэш-линия?

A) Строка в исходном коде
B) Блок данных в кэше процессора
C) Команда ассемблера
D) Тип данных в C++

## Вопрос 9
Какой размер кэш-линии у большинства современных процессоров?

A) 32 байта
B) 64 байта
C) 128 байт
D) 256 байт

## Вопрос 10
Почему тернарный оператор может быть быстрее if?

A) Короче записывается
B) Избегает условных переходов
C) Использует меньше памяти
D) Всегда быстрее

## Вопрос 11
Что такое правило Парето в контексте оптимизации?

A) 80% кода занимает 20% времени выполнения
B) 20% кода занимает 80% времени выполнения
C) 50% кода занимает 50% времени выполнения
D) 90% кода занимает 10% времени выполнения

## Вопрос 12
Какое первое правило оптимизации?

A) Всегда оптимизировать
B) Избегать преждевременной оптимизации
C) Оптимизировать все функции
D) Использовать только быстрые алгоритмы

## Вопрос 13
Что лучше использовать для вывода отладочной информации?

A) std::cout
B) std::cerr
C) printf
D) std::clog

## Вопрос 14
Какой флаг компилятора включает максимальную оптимизацию?

A) -O1
B) -O2
C) -O3
D) -Ofast

## Вопрос 15
Что делает reserve() для std::vector?

A) Изменяет размер вектора
B) Резервирует память без изменения размера
C) Очищает вектор
D) Сортирует элементы

## Вопрос 16
Какой код эффективнее?

A)
```cpp
std::vector<int> vec;
for (int i = 0; i < 1000; ++i) {
    vec.push_back(i);
}
```

B)
```cpp
std::vector<int> vec;
vec.reserve(1000);
for (int i = 0; i < 1000; ++i) {
    vec.push_back(i);
}
```

C) Эффективность одинаковая
D) Зависит от компилятора

## Вопрос 17
Что такое RAII?

A) Алгоритм оптимизации
B) Идиома управления ресурсами
C) Тип данных
D) Библиотека C++

## Вопрос 18
Какой способ передачи параметра эффективнее для больших объектов?

A) По значению
B) По указателю
C) По константной ссылке
D) По rvalue-ссылке

## Вопрос 19
Что делает std::move?

A) Физически перемещает объект в памяти
B) Приводит к rvalue-ссылке
C) Копирует объект
D) Удаляет объект

## Вопрос 20
В каком случае условный переход наиболее эффективен?

A) Когда условие случайное
B) Когда условие предсказуемое
C) Когда условие сложное
D) Условные переходы всегда неэффективны

## Вопрос 21
Что такое предсказатель веток?

A) Алгоритм в компиляторе
B) Механизм процессора для предсказания условных переходов
C) Инструмент профилирования
D) Библиотека C++

## Вопрос 22
Какой код лучше для производительности?

A)
```cpp
for (int i = 0; i < n; ++i) {
    if (data[i] > threshold) {
        result += data[i];
    }
}
```

B)
```cpp
for (int i = 0; i < n; ++i) {
    result += (data[i] > threshold) ? data[i] : 0;
}
```

C) Зависит от данных
D) Всегда одинаково

## Вопрос 23
Что такое SIMD?

A) Single Instruction Multiple Data
B) Simple Instruction Memory Data
C) System Instruction Multiple Device
D) Secure Instruction Memory Design

## Вопрос 24
Какой профилировщик входит в состав Visual Studio?

A) Intel VTune
B) gprof
C) Встроенный профилировщик Visual Studio
D) Valgrind

## Вопрос 25
Что означает "разворачивание цикла"?

A) Обращение порядка итераций
B) Обработка нескольких элементов за одну итерацию
C) Удаление цикла из кода
D) Замена цикла рекурсией

## Вопрос 26
Какой тип лучше использовать для счетчиков в циклах?

A) int
B) size_t
C) long
D) unsigned int

## Вопрос 27
Что происходит при вызове этого кода?
```cpp
{
    LogDuration timer;
    expensive_operation();
}
```

A) Измерение времени начнется и закончится автоматически
B) Нужно вручную остановить измерение
C) Ошибка компиляции
D) Измерение не произойдет

## Вопрос 28
Какой способ создания вектора эффективнее?

A) std::vector<int> vec(1000);
B) std::vector<int> vec; vec.resize(1000);
C) std::vector<int> vec; vec.reserve(1000);
D) A и B одинаково эффективны

## Вопрос 29
Что такое "холодный кэш"?

A) Кэш при низкой температуре
B) Кэш, не содержащий нужных данных
C) Заблокированный кэш
D) Кэш процессора

## Вопрос 30
Какой алгоритм сортировки используется в std::sort?

A) Quicksort
B) Mergesort
C) Introsort (гибридный)
D) Bubblesort

## Вопрос 31
Что лучше для поиска в отсортированном контейнере?

A) std::find
B) std::binary_search
C) std::lower_bound
D) Линейный поиск

## Вопрос 32
Какой код эффективнее для подсчета элементов?

A)
```cpp
int count = 0;
for (auto x : vec) {
    if (x > 0) ++count;
}
```

B)
```cpp
int count = std::count_if(vec.begin(), vec.end(), 
                         [](int x) { return x > 0; });
```

C) Эффективность одинаковая
D) Зависит от размера вектора

## Вопрос 33
Что такое constexpr?

A) Константа времени выполнения
B) Константа времени компиляции
C) Тип данных
D) Спецификатор доступа

## Вопрос 34
Какой код выполнится быстрее?

A)
```cpp
const int SIZE = 1000;
int arr[SIZE];
```

B)
```cpp
int size = 1000;
int* arr = new int[size];
```

C) Скорость одинаковая
D) Зависит от использования

## Вопрос 35
Что делает атрибут [[likely]] в C++17?

A) Увеличивает вероятность выполнения
B) Подсказывает компилятору о частоте выполнения
C) Гарантирует выполнение
D) Ничего не делает

## Вопрос 36
Какой способ итерации быстрее?

A)
```cpp
for (int i = 0; i < vec.size(); ++i) {
    process(vec[i]);
}
```

B)
```cpp
for (auto it = vec.begin(); it != vec.end(); ++it) {
    process(*it);
}
```

C)
```cpp
for (auto& x : vec) {
    process(x);
}
```

D) Все одинаково быстрые

## Вопрос 37
Что такое RVO (Return Value Optimization)?

A) Оптимизация возвращаемых значений компилятором
B) Алгоритм сортировки
C) Тип данных
D) Библиотека C++

## Вопрос 38
Какой контейнер лучше для частых вставок в середину?

A) std::vector
B) std::list
C) std::deque
D) std::array

## Вопрос 39
Что происходит при превышении capacity у std::vector?

A) Исключение
B) Реаллокация с увеличением размера
C) Перезапись старых элементов
D) Ничего

## Вопрос 40
Какой принцип следует соблюдать при оптимизации?

A) Оптимизировать все подряд
B) Сначала измерить, потом оптимизировать
C) Оптимизировать только медленные функции
D) Никогда не оптимизировать 