# Практические задания по теории быстродействия

## Задание 1: Анализ сложности алгоритмов сортировки

**Описание:** Реализуйте и проанализируйте сложность различных алгоритмов сортировки.

**Задача:** Реализовать функции сортировки пузырьком, вставками и быструю сортировку. Измерить время выполнения для разных размеров массивов.

**Тесты:**
1. Массив [5, 2, 8, 1, 9] → [1, 2, 5, 8, 9]
2. Массив [1, 2, 3, 4, 5] → [1, 2, 3, 4, 5] (уже отсортирован)
3. Массив [5, 4, 3, 2, 1] → [1, 2, 3, 4, 5] (обратный порядок)
4. Массив [1] → [1] (один элемент)
5. Массив [] → [] (пустой массив)
6. Массив [3, 3, 3, 3] → [3, 3, 3, 3] (одинаковые элементы)
7. Массив размером 1000 случайных чисел
8. Массив размером 10000 случайных чисел
9. Массив размером 100000 случайных чисел
10. Сравнить время выполнения всех алгоритмов

## Задание 2: Оптимизация поиска дубликатов

**Описание:** Найти и оптимизировать алгоритм поиска дубликатов в массиве.

**Задача:** Реализовать три варианта: наивный O(n²), с сортировкой O(n log n) и с хеш-таблицей O(n).

**Тесты:**
1. [1, 2, 3, 4, 5] → false (нет дубликатов)
2. [1, 2, 3, 2, 5] → true (есть дубликат 2)
3. [1, 1, 1, 1] → true (все элементы одинаковые)
4. [1] → false (один элемент)
5. [] → false (пустой массив)
6. [5, 3, 8, 3, 1, 8] → true (несколько дубликатов)
7. Массив размером 1000 без дубликатов
8. Массив размером 1000 с одним дубликатом в конце
9. Массив размером 10000 случайных чисел
10. Сравнить производительность всех трех методов

## Задание 3: Эффективный поиск в отсортированном массиве

**Описание:** Реализовать и сравнить линейный и бинарный поиск.

**Задача:** Найти элемент в отсортированном массиве двумя способами и сравнить производительность.

**Тесты:**
1. [1, 3, 5, 7, 9], поиск 5 → индекс 2
2. [1, 3, 5, 7, 9], поиск 1 → индекс 0
3. [1, 3, 5, 7, 9], поиск 9 → индекс 4
4. [1, 3, 5, 7, 9], поиск 4 → -1 (не найден)
5. [1, 3, 5, 7, 9], поиск 0 → -1 (меньше минимального)
6. [1, 3, 5, 7, 9], поиск 10 → -1 (больше максимального)
7. [1], поиск 1 → индекс 0
8. [], поиск 5 → -1 (пустой массив)
9. Массив размером 100000, поиск элемента в начале
10. Массив размером 100000, поиск элемента в конце

## Задание 4: Анализ контейнеров STL

**Описание:** Сравнить производительность различных контейнеров STL для разных операций.

**Задача:** Измерить время вставки, поиска и удаления для vector, list, set, unordered_set.

**Тесты:**
1. Вставка 1000 элементов в конец
2. Вставка 1000 элементов в начало
3. Вставка 1000 элементов в середину
4. Поиск 1000 случайных элементов
5. Удаление 1000 элементов с конца
6. Удаление 1000 элементов с начала
7. Удаление 1000 элементов из середины
8. Итерация по всем элементам
9. Измерить потребление памяти
10. Сравнить результаты с теоретическими оценками

## Задание 5: Оптимизация строковых операций

**Описание:** Сравнить различные способы работы со строками.

**Задача:** Реализовать конкатенацию строк разными способами и измерить производительность.

**Тесты:**
1. Конкатенация 100 строк через operator+=
2. Конкатенация 100 строк через ostringstream
3. Конкатенация 100 строк через reserve() и operator+=
4. Конкатенация 1000 строк всеми способами
5. Поиск подстроки в большой строке
6. Замена символов в строке
7. Сравнение строк разной длины
8. Использование string_view vs string
9. Измерить потребление памяти
10. Сравнить с теоретическими оценками

## Задание 6: Реализация кэша с LRU

**Описание:** Создать кэш с политикой вытеснения LRU (Least Recently Used).

**Задача:** Реализовать кэш фиксированного размера с эффективными операциями get и put.

**Тесты:**
1. Создать кэш размером 2, добавить 3 элемента
2. Проверить вытеснение наименее используемого элемента
3. Обновить существующий элемент
4. Получить элемент и проверить изменение порядка
5. Заполнить кэш и проверить все операции
6. Кэш размером 1000, добавить 1500 элементов
7. Измерить время операций get и put
8. Проверить корректность работы при интенсивном использовании
9. Тест на граничные случаи (размер 0, 1)
10. Сравнить с наивной реализацией

## Задание 7: Алгоритм поиска k-го наименьшего элемента

**Описание:** Реализовать эффективный алгоритм поиска k-го наименьшего элемента.

**Задача:** Сравнить метод с полной сортировкой и алгоритм quickselect.

**Тесты:**
1. [3, 1, 4, 1, 5, 9, 2, 6], k=3 → 3
2. [3, 1, 4, 1, 5, 9, 2, 6], k=1 → 1
3. [3, 1, 4, 1, 5, 9, 2, 6], k=8 → 9
4. [5, 5, 5, 5], k=2 → 5
5. [1], k=1 → 1
6. [2, 1], k=2 → 2
7. Массив размером 1000, k=500
8. Массив размером 10000, k=1
9. Массив размером 10000, k=10000
10. Сравнить производительность обоих методов

## Задание 8: Оптимизация матричных операций

**Описание:** Реализовать и оптимизировать операции с матрицами.

**Задача:** Сравнить наивное и блочное умножение матриц, транспонирование.

**Тесты:**
1. Умножение матриц 2x2
2. Умножение матриц 3x3
3. Умножение матриц 100x100
4. Транспонирование матрицы 100x100
5. Сложение матриц 1000x1000
6. Умножение матриц 500x500 (наивный алгоритм)
7. Умножение матриц 500x500 (блочный алгоритм)
8. Измерить cache miss для разных алгоритмов
9. Сравнить потребление памяти
10. Анализ производительности в зависимости от размера

## Задание 9: Реализация эффективной хеш-таблицы

**Описание:** Создать собственную хеш-таблицу с разрешением коллизий.

**Задача:** Реализовать хеш-таблицу с методом цепочек и открытой адресацией.

**Тесты:**
1. Вставка 100 элементов без коллизий
2. Вставка 100 элементов с коллизиями
3. Поиск существующих элементов
4. Поиск несуществующих элементов
5. Удаление элементов
6. Rehashing при превышении load factor
7. Тест производительности на 10000 элементов
8. Сравнение с std::unordered_map
9. Измерить количество коллизий
10. Анализ различных хеш-функций

## Задание 10: Параллельная обработка данных

**Описание:** Реализовать параллельные алгоритмы и сравнить с последовательными.

**Задача:** Использовать std::execution для параллельной обработки больших массивов.

**Тесты:**
1. Параллельная сортировка массива 100000 элементов
2. Параллельный поиск в массиве 1000000 элементов
3. Параллельное преобразование массива (transform)
4. Параллельная редукция (accumulate)
5. Сравнение с последовательными алгоритмами
6. Измерить speedup на разных размерах данных
7. Анализ overhead параллелизации
8. Тест на разном количестве потоков
9. Влияние размера данных на эффективность
10. Рекомендации по использованию параллельных алгоритмов 