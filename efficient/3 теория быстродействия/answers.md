# Ответы на тест по теории быстродействия алгоритмов

## Правильные ответы:

1. **b) O(n²)** - Двойной цикл, где внутренний цикл выполняется (n-i) раз для каждого i
2. **b) В среднем операция выполняется за константное время при многократном вызове**
3. **c) O(n)** - Нужно сдвинуть все элементы вправо
4. **c) O(n²)** - Двойной цикл, проверяющий все пары элементов
5. **b) O(log n)** - Поиск в сбалансированном дереве
6. **c) std::unordered_map<Key, Value>** - Хеш-таблица с O(1) поиском
7. **b) O(n² log n)** - n строк, каждая сортируется за O(n log n)
8. **c) Правило поглощения** - Оставляем только самое большое слагаемое O(n³)
9. **b) Амортизированная сложность O(1)** - Иногда реаллокация, но в среднем константа
10. **b) O(log n)** - Классический бинарный поиск
11. **c) O(2^n)** - Экспоненциальная рекурсия без мемоизации
12. **b) O(n log n)** - Стандартная сложность эффективной сортировки
13. **b) O(log n)** - Цикл выполняется log₂(n) раз
14. **c) Вставка в произвольное место по итератору** - Константная операция для списка
15. **c) O(n²)** - Классическая пузырьковая сортировка
16. **a) O(1)** - Хеш-таблица в среднем случае
17. **b) std::vector** - Данные лежат непрерывно в памяти
18. **c) O(n²)** - Двойной цикл по всем элементам
19. **c) O(n)** - Нужно сдвинуть элементы после удаляемого
20. **b) Это теоретический минимум для сортировки сравнениями**
21. **c) O(n²)** - Двойной цикл для подсчета инверсий
22. **b) O(log n)** - Бинарный поиск в отсортированном контейнере
23. **b) Уменьшается количество копирований** - string_view не копирует данные
24. **c) O(n²)** - Каждая конкатенация может потребовать копирования всей строки
25. **c) O(1) вставка в начало и конец** - Главное преимущество deque
26. **c) O(n)** - Проход по половине строки в худшем случае
27. **b) O(log n)** - Вставка в кучу (heap)
28. **b) std::ostringstream** - Более эффективен для множественных конкатенаций
29. **c) O(n²)** - Сортировка выбором
30. **b) O(log n)** - Вставка в сбалансированное дерево
31. **b) O(log n)** - Бинарный поиск
32. **c) O(n)** - Может потребоваться копирование всех элементов
33. **b) Код, который обращается к памяти последовательно** - Эффективное использование кэша
34. **b) O(n log n)** - Сортировка слиянием
35. **d) clear()** - Удаление всех элементов
36. **c) O(n)** - Один проход по массиву
37. **b) O(n log n)** - Гарантированная сложность std::sort
38. **c) std::list** - Константная вставка/удаление по итератору
39. **d) O(2^n)** - Генерация всех подмножеств
40. **c) Избежать ненужных копирований** - Основная цель move-семантики 